<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pathfinding System - CS2 Modding Research</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="top-bar">
  <a href="index.html" class="site-title">CS2 Modding Research</a>
  <span class="attribution">Generated with Claude | Supervised by repository owner</span>
</div>

<div class="page-layout">

    <aside class="sidebar">
    <h3>Events &amp; Simulation</h3>
    <a href="event-entity-archetype.html">Event Entity Archetype</a>
    <a href="fire-ignition.html">Fire Ignition</a>
    <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
    <a href="crime-trigger.html">Crime Trigger</a>
    <a href="citizen-sickness.html">Citizen Sickness</a>
    <a href="water-system.html">Water System</a>
    <a href="emergency-dispatch.html">Emergency Dispatch</a>
    <a href="disaster-simulation.html">Disaster Simulation</a>

    <h3>Infrastructure</h3>
    <a href="electricity-grid.html">Electricity Grid</a>
    <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
    <a href="road-network.html">Road &amp; Network Building</a>
    <a href="zoning.html">Zoning</a>
    <a href="building-construction.html">Building Construction</a>
    <a href="pathfinding.html" class="active">Pathfinding</a>
    <a href="traffic-flow.html">Traffic Flow</a>

    <h3>Economy &amp; Population</h3>
    <a href="citizens-households.html">Citizens &amp; Households</a>
    <a href="economy-budget.html">Economy &amp; Budget</a>
    <a href="demand-systems.html">Demand Systems</a>
    <a href="resource-production.html">Resource Production</a>
    <a href="company-simulation.html">Company Simulation</a>
    <a href="workplace-labor.html">Workplace &amp; Labor</a>
    <a href="land-value-property.html">Land Value &amp; Property</a>
    <a href="trade-connections.html">Trade &amp; Connections</a>
    <a href="tourism-economy.html">Tourism Economy</a>
    <a href="cargo-transport.html">Cargo Transport</a>

    <h3>City Services</h3>
    <a href="garbage-collection.html">Garbage Collection</a>
    <a href="education.html">Education</a>
    <a href="public-transit.html">Public Transit</a>
    <a href="healthcare.html">Healthcare</a>
    <a href="deathcare.html">Deathcare</a>
    <a href="parks-recreation.html">Parks &amp; Recreation</a>
    <a href="police-dispatch.html">Police Dispatch</a>

    <h3>Governance</h3>
    <a href="districts-policies.html">Districts &amp; Policies</a>
    <a href="map-tile-purchase.html">Map Tile Purchase</a>

    <h3>Environment</h3>
    <a href="weather-climate.html">Weather &amp; Climate</a>
    <a href="pollution.html">Pollution</a>
    <a href="terrain-resources.html">Terrain &amp; Resources</a>

    <h3>Vehicles &amp; Transport</h3>
    <a href="vehicle-spawning.html">Vehicle Spawning</a>
    <a href="parking-system.html">Parking System</a>

    <h3>Tools &amp; Input</h3>
    <a href="tool-activation.html">Tool Activation</a>
    <a href="tool-raycast.html">Tool Raycast</a>
    <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
    <a href="mod-hotkey-input.html">Mod Hotkey Input</a>
    <a href="object-tool-system.html">Object Placement Tool</a>

    <h3>UI &amp; Settings</h3>
    <a href="mod-ui-buttons.html">Mod UI Buttons</a>
    <a href="mod-options-ui.html">Mod Options UI</a>
    <a href="info-views-overlays.html">Info Views &amp; Overlays</a>
    <a href="chirper-notifications.html">Chirper Notifications</a>

    <h3>Modding Framework</h3>
    <a href="save-load-persistence.html">Save/Load Persistence</a>
    <a href="prefab-system.html">Prefab System</a>
    <a href="localization.html">Localization</a>
    <a href="harmony-transpilers.html">Harmony Transpilers</a>
    <a href="mod-loading-dependencies.html">Mod Loading</a>
  </aside>

  <main class="content">

  <h1>Pathfinding System</h1>

  <div class="scope">
    <h2>Scope</h2>
    <p>
      <strong>Question:</strong> How does CS2's pathfinding work -- from request submission through graph
      traversal to path element output? How can mods interact with pathfinding requests, modify costs,
      or react to completed paths?
    </p>
    <p>
      <strong>Verdict:</strong> CS2 uses a <strong>multi-threaded A* pathfinder</strong> operating on a
      lane-level graph. Pathfind requests flow through a three-stage pipeline:
      <code>PathfindSetupSystem</code> resolves abstract targets into concrete lane positions,
      <code>PathfindQueueSystem</code> dispatches work to parallel worker threads, and
      <code>PathfindResultSystem</code> writes results back to entity components. The system uses a
      4-dimensional cost model (time, behaviour, money, comfort) with per-agent weights.
    </p>
  </div>

  <!-- ============================================================ -->
  <h2>How It Works</h2>

  <p>
    Every moving agent in CS2 -- citizens walking to work, garbage trucks collecting waste, ambulances
    responding to emergencies -- uses the same pathfinding pipeline. The process begins when a game
    system detects that an entity needs a path, and ends when the <code>PathElement</code> buffer on
    that entity is populated with a sequence of lane segments to follow.
  </p>

  <h3>The Three-Stage Pipeline</h3>

  <ol>
    <li>
      <strong>Setup</strong> (<code>PathfindSetupSystem</code>): Game systems enqueue abstract pathfind
      requests with origin/destination types (e.g., "from current location to nearest hospital").
      Domain-specific helpers resolve these into concrete lane-level <code>PathTarget</code> lists.
    </li>
    <li>
      <strong>Execution</strong> (<code>PathfindQueueSystem</code>): Resolved requests are dispatched to
      a pool of worker threads that execute A* search on the pathfind graph. Workers use half the available
      CPU cores and operate on a double-buffered graph structure.
    </li>
    <li>
      <strong>Results</strong> (<code>PathfindResultSystem</code>): Completed results are written back to
      entities: <code>PathOwner</code> state is updated, <code>PathElement</code> buffer is filled with
      the path segments, and <code>PathInformation</code> receives distance/duration/cost summaries.
    </li>
  </ol>

  <div class="diagram"><pre>
[Game Systems]                     [Pathfind Pipeline]                   [Entity Data]

  Citizens,                    +---------------------------+
  Vehicles,         enqueue    |  PathfindSetupSystem      |
  Services    ===============&gt; |  - GetQueue() API         |
                SetupQueueItem |  - Domain-specific helpers |
                               |  - Target resolution      |
                               +---------------------------+
                                            |
                                    PathfindAction
                                   (start + end targets)
                                            |
                                            v
                               +---------------------------+
                               |  PathfindQueueSystem      |
                               |  - Multi-threaded A*      |
                               |  - Double-buffered graph  |
                               |  - Priority scheduling    |
                               +---------------------------+
                                            |
                                   completed actions
                                            |
                                            v
                               +---------------------------+
                               |  PathfindResultSystem     |     PathOwner
                               |  - Write PathElement buf  | ==&gt; PathElement buffer
                               |  - Update PathInformation |     PathInformation
                               |  - Fire PathUpdated event |
                               +---------------------------+
  </pre></div>

  <!-- ============================================================ -->
  <h2>Relevant Assemblies</h2>

  <table>
    <thead><tr><th>Assembly</th><th>Namespace</th><th>What's There</th></tr></thead>
    <tbody>
      <tr><td>Game.dll</td><td>Game.Pathfind</td><td>Core pathfind components, graph data, queue/result systems, PathUtils</td></tr>
      <tr><td>Game.dll</td><td>Game.Simulation</td><td>PathfindSetupSystem, domain-specific setup structs (CitizenPathfindSetup, etc.)</td></tr>
      <tr><td>Game.dll</td><td>Game.Prefabs</td><td>PathfindPrefab, PathfindCarData, PathfindPedestrianData, PathfindTrackData</td></tr>
      <tr><td>Game.dll</td><td>Game.Common</td><td>PathfindUpdated tag component</td></tr>
      <tr><td>Game.dll</td><td>Game.Debug</td><td>PathfindDebugSystem</td></tr>
    </tbody>
  </table>

  <!-- ============================================================ -->
  <h2>Key Components</h2>

  <h3>PathOwner</h3>
  <p>
    Every entity that needs a path carries this component. It tracks the entity's progress along
    its computed path and the lifecycle state of the path request.
  </p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_ElementIndex</code></td><td>int</td><td>Current index into the PathElement buffer -- how far along the path the agent is</td></tr>
      <tr><td><code>m_State</code></td><td>PathFlags</td><td>Bitfield: Pending, Failed, Obsolete, Scheduled, Updated, Stuck, etc.</td></tr>
    </tbody>
  </table>

  <h3>PathElement (Buffer)</h3>
  <p>
    Dynamic buffer attached to path-owning entities. Each element is one segment of the computed path,
    referencing a specific lane entity and the portion of that lane to traverse.
  </p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Target</code></td><td>Entity</td><td>The lane entity this path segment traverses</td></tr>
      <tr><td><code>m_TargetDelta</code></td><td>float2</td><td>Start/end position along the lane curve (0.0 to 1.0)</td></tr>
      <tr><td><code>m_Flags</code></td><td>PathElementFlags</td><td>Secondary, PathStart, Action, Return, Reverse, WaitPosition, Leader, Hangaround</td></tr>
    </tbody>
  </table>

  <h3>PathInformation</h3>
  <p>Summary data about a completed path. Provides distance, duration, cost, and which transport methods are used.</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Origin</code></td><td>Entity</td><td>Origin lane entity</td></tr>
      <tr><td><code>m_Destination</code></td><td>Entity</td><td>Destination lane entity</td></tr>
      <tr><td><code>m_Distance</code></td><td>float</td><td>Total path distance in game units</td></tr>
      <tr><td><code>m_Duration</code></td><td>float</td><td>Estimated travel time</td></tr>
      <tr><td><code>m_TotalCost</code></td><td>float</td><td>Weighted pathfind cost</td></tr>
      <tr><td><code>m_Methods</code></td><td>PathMethod</td><td>Transport methods used (bitfield)</td></tr>
      <tr><td><code>m_State</code></td><td>PathFlags</td><td>Result state flags</td></tr>
    </tbody>
  </table>

  <h3>PathNode</h3>
  <p>
    Compact graph node representation that packs an entity index, lane index, segment index, and curve
    position into a single <code>ulong</code>. This encoding enables efficient hash-based lookups during
    A* traversal.
  </p>
  <pre><code>// Bit layout of PathNode.m_SearchKey (ulong):
// [63:32] Owner entity index
// [31]    Secondary node flag
// [30:16] Curve position (float encoded as int * 32767)
// [15:8]  Segment index
// [7:0]   Lane index</code></pre>
  <p>Key methods:</p>
  <ul>
    <li><code>GetOwnerIndex()</code> -- extracts entity index</li>
    <li><code>GetLaneIndex()</code> -- extracts lane index (ushort)</li>
    <li><code>GetCurvePos()</code> -- extracts normalized curve position (float, encoded as int * 3.05e-5)</li>
    <li><code>IsSecondary()</code> -- bit 31 flag</li>
  </ul>

  <h3>Edge</h3>
  <p>
    A connection in the pathfind graph between two nodes. Each edge links a source and destination
    <code>PathNode</code> through a lane entity and carries the traversal specification (costs,
    methods, rules) plus location data for A* heuristics.
  </p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Owner</code></td><td>Entity</td><td>The lane entity this edge belongs to</td></tr>
      <tr><td><code>m_StartID</code></td><td>NodeID</td><td>Start node identifier</td></tr>
      <tr><td><code>m_MiddleID</code></td><td>NodeID</td><td>Middle node identifier (for curved segments)</td></tr>
      <tr><td><code>m_EndID</code></td><td>NodeID</td><td>End node identifier</td></tr>
      <tr><td><code>m_StartCurvePos</code></td><td>float</td><td>Start position on the lane curve</td></tr>
      <tr><td><code>m_EndCurvePos</code></td><td>float</td><td>End position on the lane curve</td></tr>
      <tr><td><code>m_Specification</code></td><td>PathSpecification</td><td>Cost/method/flag data for this edge</td></tr>
      <tr><td><code>m_Location</code></td><td>LocationSpecification</td><td>Position data for heuristic calculations</td></tr>
    </tbody>
  </table>

  <h3>PathSpecification</h3>
  <p>
    Describes the traversal properties of a pathfind graph edge. Contains base costs,
    transport method flags, speed limits, density data, and policy rule flags.
  </p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Costs</code></td><td>PathfindCosts</td><td>Base costs (time, behaviour, money, comfort)</td></tr>
      <tr><td><code>m_Flags</code></td><td>EdgeFlags</td><td>Direction flags, connection type</td></tr>
      <tr><td><code>m_Methods</code></td><td>PathMethod</td><td>Which transport methods can use this edge</td></tr>
      <tr><td><code>m_AccessRequirement</code></td><td>int</td><td>Access authorization requirement</td></tr>
      <tr><td><code>m_Length</code></td><td>float</td><td>Physical length of the edge</td></tr>
      <tr><td><code>m_MaxSpeed</code></td><td>float</td><td>Speed limit</td></tr>
      <tr><td><code>m_Density</code></td><td>float</td><td>Current traffic density (0.01 minimum)</td></tr>
      <tr><td><code>m_Rules</code></td><td>RuleFlags</td><td>Lane policy rules (combustion ban, transit ban, etc.)</td></tr>
      <tr><td><code>m_BlockageStart</code></td><td>byte</td><td>Blockage position start</td></tr>
      <tr><td><code>m_BlockageEnd</code></td><td>byte</td><td>Blockage position end</td></tr>
      <tr><td><code>m_FlowOffset</code></td><td>byte</td><td>Traffic flow offset</td></tr>
    </tbody>
  </table>

  <h3>PathTarget</h3>
  <p>
    Represents a candidate start or end point for a pathfind query. The pathfind setup system
    resolves abstract targets into lists of <code>PathTarget</code> structs, each pointing to a
    specific lane position.
  </p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Target</code></td><td>Entity</td><td>Target node entity</td></tr>
      <tr><td><code>m_Entity</code></td><td>Entity</td><td>Lane entity</td></tr>
      <tr><td><code>m_Delta</code></td><td>float</td><td>Position along the lane</td></tr>
      <tr><td><code>m_Cost</code></td><td>float</td><td>Cost to reach this target from the entity's position</td></tr>
      <tr><td><code>m_Flags</code></td><td>EdgeFlags</td><td>Edge direction flags</td></tr>
    </tbody>
  </table>

  <h3>PathfindUpdated (Tag Component)</h3>
  <p>
    A zero-size tag component (<code>Game.Common</code>) that signals pathfind-relevant data on an entity
    has changed. When added to a lane entity, <code>LanesModifiedSystem</code> picks it up via
    <code>m_UpdatedLanesQuery</code> and enqueues graph edge recalculation for that lane.
  </p>
  <p>
    <strong>Flow:</strong> Add <code>PathfindUpdated</code> to lane entity &rarr;
    <code>LanesModifiedSystem</code> detects it &rarr; rebuilds <code>PathSpecification</code>
    from current lane data &rarr; enqueues <code>UpdateAction</code> into
    <code>PathfindQueueSystem</code> &rarr; graph edge recalculated on next cycle.
  </p>
  <p>
    <strong>Difference from <code>Updated</code>:</strong> The generic <code>Updated</code> tag
    (<code>Game.Common</code>) triggers broad system processing across many systems (rendering,
    simulation, etc.). <code>PathfindUpdated</code> is a narrower signal that only triggers pathfind
    graph recalculation. Use <code>PathfindUpdated</code> when only pathfind-relevant data changed
    (e.g., lane costs, speed limits, rule flags) to avoid unnecessary processing by unrelated systems.
  </p>
  <pre><code class="language-csharp">// Signal that a lane's pathfind data needs recalculation
// (e.g., after modifying CarLane.m_SpeedLimit or RuleFlags)
EntityManager.AddComponent&lt;PathfindUpdated&gt;(laneEntity);</code></pre>

  <!-- ============================================================ -->
  <h2>Cost Model</h2>

  <p>
    CS2's pathfinding uses a <strong>4-dimensional cost model</strong> rather than a simple distance metric.
    Every edge in the pathfind graph has a <code>PathfindCosts</code> vector (a <code>float4</code>), and
    every agent has a <code>PathfindWeights</code> vector. The total cost is their dot product.
  </p>

  <h3>PathfindCosts float4 Channel Mapping</h3>

  <table>
    <thead><tr><th>Channel</th><th>Component</th><th>What It Represents</th></tr></thead>
    <tbody>
      <tr><td>.x</td><td>Time</td><td>Travel time (based on edge length / speed)</td></tr>
      <tr><td>.y</td><td>Behaviour</td><td>Behavioral preferences (avoid certain route types)</td></tr>
      <tr><td>.z</td><td>Money</td><td>Monetary cost (tolls, fares, parking)</td></tr>
      <tr><td>.w</td><td>Comfort</td><td>Comfort/quality (road condition, crowding)</td></tr>
    </tbody>
  </table>

  <pre><code>// Cost calculation (from PathUtils.CalculateCost):
float4 costs = pathSpecification.m_Costs.m_Value;
costs.x += edgeLength / speed;  // add time cost
float totalCost = math.dot(costs, parameters.m_Weights.m_Value);

// Unless Stable flag is set, add randomness to distribute agents:
if ((flags &amp; PathfindFlags.Stable) == 0)
    totalCost *= random.NextFloat(0.5f, 1.0f);</code></pre>

  <h3>TryAddCosts Utility</h3>
  <p>
    The <code>PathfindCosts</code> struct provides <code>TryAddCosts</code>, a utility method used
    throughout edge evaluation to incrementally accumulate costs with early termination:
  </p>

  <pre><code>// PathfindCosts.TryAddCosts -- conditionally adds costs to the total.
// Returns false if adding these costs would exceed m_MaxCost,
// allowing early termination of edge evaluation.
public bool TryAddCosts(ref float totalCost, PathfindWeights weights, float maxCost)
{
    totalCost += math.dot(m_Value, weights.m_Value);
    return totalCost &lt; maxCost;
}</code></pre>
  <p>
    <code>TryAddCosts</code> returns <code>false</code> when the running total exceeds
    <code>m_MaxCost</code>, enabling the pathfinder to skip expensive edges early without computing
    all cost components.
  </p>

  <h3>Prefab Cost Data</h3>
  <p>
    Base costs for different transport modes are defined in prefab components. For example,
    <code>PathfindCarData</code> defines costs for driving, turning, U-turns, lane crossing,
    parking, spawning, and forbidden routes. Each cost is a <code>PathfindCosts</code> (float4).
  </p>

  <!-- ============================================================ -->
  <h2>Key Enums</h2>

  <h3>PathFlags</h3>
  <pre><code>Pending = 1        // Request queued, not yet processed
Failed = 2         // No route found
Obsolete = 4       // Path is stale, needs recalculation
Scheduled = 8      // Submitted to worker threads
Append = 0x10      // Append to existing path
Updated = 0x20     // Recently updated
Stuck = 0x40       // Agent is stuck
WantsEvent = 0x80  // Fire PathUpdated event on completion
AddDestination = 0x100
Debug = 0x200      // Debug visualization
Divert = 0x400     // Mid-path rerouting
DivertObsolete = 0x800
CachedObsolete = 0x1000</code></pre>
  <p>
    <strong>Important:</strong> On deserialization (loading a save), <code>Pending</code> is automatically
    converted to <code>Obsolete</code>. Paths that were in-progress when the game was saved are
    invalidated and will be recalculated.
  </p>

  <h3>PathMethod</h3>
  <pre><code>Pedestrian = 1       Road = 2              Parking = 4
PublicTransportDay = 8   Track = 0x10      Taxi = 0x20
CargoTransport = 0x40    CargoLoading = 0x80   Flying = 0x100
PublicTransportNight = 0x200   Boarding = 0x400
Offroad = 0x800      SpecialParking = 0x1000
MediumRoad = 0x2000  Bicycle = 0x4000
BicycleParking = 0x8000</code></pre>

  <h3>RuleFlags</h3>
  <p>Lane policy rules applied via district or building policies that affect edge traversal costs.</p>
  <pre><code>HasBlockage = 1               ForbidCombustionEngines = 2
ForbidTransitTraffic = 4      ForbidHeavyTraffic = 8
ForbidPrivateTraffic = 0x10   ForbidSlowTraffic = 0x20
AvoidBicycles = 0x40</code></pre>

  <h3>PathElementFlags</h3>
  <p>Flags on individual path segments in the <code>PathElement</code> buffer.</p>
  <pre><code>Secondary = 1      PathStart = 2     Action = 4
Return = 8         Reverse = 0x10    WaitPosition = 0x20
Leader = 0x40      Hangaround = 0x80</code></pre>

  <h3>PathfindFlags</h3>
  <p>Controls pathfind algorithm behavior -- set via <code>PathfindParameters.m_PathfindFlags</code>.</p>
  <pre><code>Stable = 1              // No random cost variation
IgnoreFlow = 2          // Ignore traffic density
ForceForward = 4        ForceBackward = 8
NoHeuristics = 0x10     // Disable A* heuristics (Dijkstra)
ParkingReset = 0x20
Simplified = 0x40       // Simplified path search
MultipleOrigins = 0x80  MultipleDestinations = 0x100
IgnoreExtraStartAccessRequirements = 0x200
IgnoreExtraEndAccessRequirements = 0x400
IgnorePath = 0x800
SkipPathfind = 0x1000   // Skip graph traversal, use cheapest target directly</code></pre>

  <h3>SetupTargetType</h3>
  <p>
    All possible target types for pathfind setup (47 values). These are used in
    <code>SetupQueueTarget.m_Type</code> to specify what kind of destination the pathfinder should resolve.
    Key categories:
  </p>
  <ul>
    <li><code>CurrentLocation</code> (0) -- current entity position</li>
    <li><strong>Economic:</strong> <code>ResourceSeller</code>, <code>StorageTransfer</code>, <code>ResourceExport</code></li>
    <li><strong>Transit/Taxi:</strong> <code>TransportVehicle</code>, <code>RouteWaypoints</code>, <code>Taxi</code></li>
    <li><strong>Service vehicles:</strong> <code>GarbageCollector</code>, <code>FireEngine</code>, <code>Ambulance</code>, <code>PolicePatrol</code>, <code>PostVan</code>, <code>Hearse</code></li>
    <li><strong>Traffic:</strong> <code>RandomTraffic</code>, <code>OutsideConnection</code></li>
    <li><strong>Citizen activities:</strong> <code>Leisure</code>, <code>Attraction</code>, <code>SchoolSeekerTo</code>, <code>JobSeekerTo</code></li>
    <li><strong>Housing:</strong> <code>FindHome</code>, <code>HomelessShelter</code></li>
    <li><strong>Dispatch:</strong> Various <code>*Request</code> types for service dispatch</li>
  </ul>

  <!-- ============================================================ -->
  <h2>Systems</h2>

  <h3>PathfindSetupSystem</h3>
  <p>
    The public entry point for all pathfind requests. Other game systems call
    <code>GetQueue()</code> to obtain a native queue, enqueue <code>SetupQueueItem</code> structs,
    and then call <code>AddQueueWriter()</code> to register their job dependency.
  </p>
  <p>
    Internally, <code>PathfindSetupSystem</code> uses 12 domain-specific setup helpers to resolve
    abstract target types (e.g., "nearest hospital") into concrete lane-level
    <code>PathTarget</code> lists:
  </p>
  <ul>
    <li><strong>CommonPathfindSetup</strong> -- current location, accident location, safety</li>
    <li><strong>CitizenPathfindSetup</strong> -- tourist targets, leisure, school, job, attraction, homeless shelter, find home</li>
    <li><strong>TransportPathfindSetup</strong> -- transport vehicles, taxis, route waypoints</li>
    <li><strong>FirePathfindSetup</strong> -- fire engines, emergency shelters, evacuation transport</li>
    <li><strong>HealthcarePathfindSetup</strong> -- ambulances, hospitals, hearses</li>
    <li><strong>PolicePathfindSetup</strong> -- police patrols, crime producers, prisoner transport</li>
    <li><strong>GarbagePathfindSetup</strong> -- garbage collectors, garbage transfer</li>
    <li><strong>PostServicePathfindSetup</strong> -- post vans, mail transfer, mailboxes</li>
    <li><strong>RoadPathfindSetup</strong> -- maintenance vehicles, random traffic, outside connections</li>
    <li><strong>ResourcePathfindSetup</strong> -- resource sellers, resource exports, storage transfers</li>
    <li><strong>GoodsDeliveryPathfindSetup</strong> -- goods delivery vehicles</li>
    <li><strong>AreaPathfindSetup</strong> -- area locations, wood resources</li>
  </ul>

  <h3>PathfindQueueSystem</h3>
  <p>
    Manages the multi-threaded pathfind worker pool. Uses <code>JobsUtility.JobWorkerCount / 2</code>
    threads, each with a 1 MB linear allocator. Workers pull actions from a shared atomic counter
    and execute A* search on a <strong>double-buffered</strong> pathfind graph.
  </p>
  <p>
    The system processes 9 action types: graph modifications (Create, Update, Delete edges),
    pathfind queries (Pathfind, Coverage, Availability), and traffic data updates (Density, Time, Flow).
    Graph modifications run sequentially across both buffers; pathfind queries run in parallel on the
    current read buffer.
  </p>

  <h3>PathfindResultSystem</h3>
  <p>
    Processes completed pathfind results. Checks <code>PathfindActionState.Completed</code> on
    each scheduled action, then writes results to entity components via parallel jobs. Tracks
    query statistics (success rate, graph traversal percentage, efficiency) accessible via
    the <code>queryStats</code> dictionary. Creates <code>PathUpdated</code> event entities
    when the <code>WantsEvent</code> flag was set on the request.
  </p>

  <h3>Graph Maintenance Systems</h3>
  <ul>
    <li><strong>LaneDataSystem</strong> -- converts lane network data into pathfind graph edges when lanes are created or modified</li>
    <li><strong>LanesModifiedSystem</strong> -- updates pathfind edges when existing lanes change (see details below)</li>
    <li><strong>LanePoliciesSystem</strong> -- updates edge <code>RuleFlags</code> when district or building policies change</li>
    <li><strong>RoutesModifiedSystem</strong> -- updates pathfind edges when transit routes change</li>
    <li><strong>PathOwnerTargetMovedSystem</strong> -- marks paths as obsolete when path targets move</li>
  </ul>

  <h3>LanesModifiedSystem Details</h3>
  <p>
    Handles pathfind edge updates when existing lanes are modified (e.g., road policy changes, speed
    limit changes, lane flag updates). Its key query (<code>m_UpdatedLanesQuery</code>) matches lane
    entities tagged with <code>Updated</code> or <code>PathfindUpdated</code>, excluding
    <code>Deleted</code> and <code>Temp</code> entities.
  </p>
  <p>
    When a lane is detected as modified, the system rebuilds the edge specification using
    <code>PathUtils</code> helpers and enqueues an <code>UpdateAction</code> into
    <code>PathfindQueueSystem</code>.
  </p>

  <h4>UpdateAction &amp; UpdateActionData</h4>
  <table>
    <thead><tr><th>Struct</th><th>Fields</th><th>Description</th></tr></thead>
    <tbody>
      <tr>
        <td><code>UpdateAction</code></td>
        <td><code>m_EdgeIndex</code> (int), <code>m_Specification</code> (PathSpecification), <code>m_Location</code> (LocationSpecification)</td>
        <td>Describes a single edge update to apply to the pathfind graph</td>
      </tr>
      <tr>
        <td><code>UpdateActionData</code></td>
        <td><code>m_Actions</code> (NativeList&lt;UpdateAction&gt;), <code>m_Dependencies</code> (JobHandle)</td>
        <td>Batch container for multiple update actions submitted together</td>
      </tr>
    </tbody>
  </table>

  <h4>PathUtils Specification Helpers</h4>
  <table>
    <thead><tr><th>Method</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>PathUtils.GetSpecification(...)</code></td><td>Builds a <code>PathSpecification</code> from lane component data (CarLane, PedestrianLane, TrackLane, etc.) -- the primary edge specification</td></tr>
      <tr><td><code>PathUtils.GetSecondarySpecification(...)</code></td><td>Builds a secondary <code>PathSpecification</code> for bidirectional or reverse-direction edges</td></tr>
      <tr><td><code>PathUtils.GetLocationSpecification(...)</code></td><td>Builds a <code>LocationSpecification</code> from lane curve data for A* heuristic position calculations</td></tr>
    </tbody>
  </table>
  <p>
    These helpers are the same ones used by <code>LaneDataSystem</code> during initial graph
    construction. <code>LanesModifiedSystem</code> calls them to ensure updated edges are consistent
    with newly-created edges.
  </p>

  <!-- ============================================================ -->
  <h2>NativePathfindData Runtime Graph Manipulation</h2>

  <p>
    <code>NativePathfindData</code> is the runtime container for the pathfind graph. It holds all edges,
    node mappings, and cost data used by the pathfind worker threads. Access it via
    <code>PathfindQueueSystem.GetDataContainer()</code>.
  </p>

  <h3>Key Methods</h3>
  <table>
    <thead><tr><th>Method</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>GetEdge(int index)</code></td><td>Returns the <code>Edge</code> struct at the given index (primary edge)</td></tr>
      <tr><td><code>GetSecondaryEdge(int index)</code></td><td>Returns a secondary edge (e.g., reverse direction or alternate path)</td></tr>
      <tr><td><code>SetCosts(int edgeIndex, PathfindCosts costs)</code></td><td>Overwrites the base costs on an edge</td></tr>
      <tr><td><code>SetDensity(int edgeIndex, float density)</code></td><td>Updates the traffic density value on an edge</td></tr>
    </tbody>
  </table>

  <h3>Delta-Apply Pattern</h3>
  <p>
    When modifying graph costs at runtime, use a <code>NativeParallelHashMap&lt;int, PathfindCosts&gt;</code>
    to track modifications as deltas (offsets from original values). This prevents <strong>cost stacking</strong>
    -- the problem where applying the same modification multiple frames in a row causes costs to grow
    unboundedly.
  </p>

  <pre><code class="language-csharp">// Delta-apply pattern to prevent cost stacking
private NativeParallelHashMap&lt;int, PathfindCosts&gt; _originalCosts;

public void ApplyCostModification(
    NativePathfindData graphData, int edgeIndex, PathfindCosts modifier)
{
    // Store original cost on first modification
    if (!_originalCosts.ContainsKey(edgeIndex))
    {
        Edge edge = graphData.GetEdge(edgeIndex);
        _originalCosts.Add(edgeIndex, edge.m_Specification.m_Costs);
    }

    // Always apply delta from the original, not from current value
    PathfindCosts original = _originalCosts[edgeIndex];
    PathfindCosts modified = new PathfindCosts(
        original.m_Value + modifier.m_Value);
    graphData.SetCosts(edgeIndex, modified);
}

public void RevertCostModification(
    NativePathfindData graphData, int edgeIndex)
{
    if (_originalCosts.TryGetValue(edgeIndex, out PathfindCosts original))
    {
        graphData.SetCosts(edgeIndex, original);
        _originalCosts.Remove(edgeIndex);
    }
}</code></pre>

  <div class="warning">
    <strong>Important:</strong> Graph modifications via <code>NativePathfindData</code> take effect on the
    next pathfind cycle (double-buffered). Modifications must be synchronized with the pathfind queue
    system's update to avoid race conditions with worker threads.
  </div>

  <!-- ============================================================ -->
  <h2>Examples</h2>

  <h3>Example 1: Reading an Entity's Current Path</h3>
  <p>Query entities with PathOwner and PathElement to inspect their computed paths.</p>
  <pre><code>public partial class ReadPathSystem : GameSystemBase
{
    private EntityQuery m_PathQuery;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_PathQuery = GetEntityQuery(
            ComponentType.ReadOnly&lt;PathOwner&gt;(),
            ComponentType.ReadOnly&lt;PathElement&gt;()
        );
    }

    protected override void OnUpdate()
    {
        var pathOwners = m_PathQuery.ToComponentDataArray&lt;PathOwner&gt;(Allocator.Temp);
        var entities = m_PathQuery.ToEntityArray(Allocator.Temp);

        for (int i = 0; i &lt; entities.Length; i++)
        {
            PathOwner owner = pathOwners[i];
            DynamicBuffer&lt;PathElement&gt; elements =
                EntityManager.GetBuffer&lt;PathElement&gt;(entities[i]);

            if ((owner.m_State &amp; PathFlags.Failed) != 0)
                continue; // No route found

            if ((owner.m_State &amp; PathFlags.Obsolete) != 0)
                continue; // Needs recalculation

            // Read remaining path elements from current position
            for (int j = owner.m_ElementIndex; j &lt; elements.Length; j++)
            {
                PathElement element = elements[j];
                Entity laneEntity = element.m_Target;
                float2 delta = element.m_TargetDelta;
                // Process path segment...
            }
        }

        pathOwners.Dispose();
        entities.Dispose();
    }
}</code></pre>

  <h3>Example 2: Requesting a Pathfind</h3>
  <p>Submit a pathfind request using the PathfindSetupSystem queue API.</p>
  <pre><code>public partial class CustomPathfindRequestSystem : GameSystemBase
{
    private PathfindSetupSystem m_PathfindSetupSystem;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_PathfindSetupSystem =
            World.GetOrCreateSystemManaged&lt;PathfindSetupSystem&gt;();
    }

    protected override void OnUpdate()
    {
        // Get a queue (maxDelayFrames=16, spreadFrames=4)
        NativeQueue&lt;SetupQueueItem&gt; queue =
            m_PathfindSetupSystem.GetQueue(this, 16, 4);

        PathfindParameters parameters = new PathfindParameters
        {
            m_MaxCost = 50000f,
            m_Methods = PathMethod.Road | PathMethod.Pedestrian,
            m_Weights = new PathfindWeights(1f, 0.5f, 0f, 0.5f),
            m_MaxSpeed = new float2(40f, 40f),
            m_WalkSpeed = new float2(1.4f, 1.4f),
            m_PathfindFlags = PathfindFlags.Stable
        };

        SetupQueueTarget origin = new SetupQueueTarget
        {
            m_Type = SetupTargetType.CurrentLocation,
            m_Methods = PathMethod.Road | PathMethod.Pedestrian
        };

        SetupQueueTarget destination = new SetupQueueTarget
        {
            m_Type = SetupTargetType.CurrentLocation,
            m_Methods = PathMethod.Road | PathMethod.Pedestrian
        };

        Entity entity = default; // your path-owning entity
        queue.Enqueue(new SetupQueueItem(
            entity, parameters, origin, destination));
        m_PathfindSetupSystem.AddQueueWriter(Dependency);
    }
}</code></pre>

  <h3>Example 3: Reacting to Completed Pathfinds</h3>
  <p>Listen for PathUpdated event entities to react when a pathfind completes.</p>
  <pre><code>public partial class PathCompletionSystem : GameSystemBase
{
    private EntityQuery m_UpdatedPathQuery;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_UpdatedPathQuery = GetEntityQuery(
            ComponentType.ReadOnly&lt;Event&gt;(),
            ComponentType.ReadOnly&lt;PathUpdated&gt;()
        );
    }

    protected override void OnUpdate()
    {
        var events = m_UpdatedPathQuery
            .ToComponentDataArray&lt;PathUpdated&gt;(Allocator.Temp);

        for (int i = 0; i &lt; events.Length; i++)
        {
            Entity pathOwnerEntity = events[i].m_Owner;
            if (!EntityManager.Exists(pathOwnerEntity)) continue;

            if (EntityManager.HasComponent&lt;PathInformation&gt;(pathOwnerEntity))
            {
                PathInformation info = EntityManager
                    .GetComponentData&lt;PathInformation&gt;(pathOwnerEntity);

                float distance = info.m_Distance;
                float duration = info.m_Duration;
                PathMethod methods = info.m_Methods;

                if ((methods &amp; PathMethod.PublicTransportDay) != 0)
                {
                    // Path includes public transit
                }
            }
        }
        events.Dispose();
    }
}</code></pre>

  <h3>Example 4: Forcing Path Recalculation</h3>
  <p>Mark an entity's path as obsolete to trigger automatic re-pathing.</p>
  <pre><code>// Set the Obsolete flag on PathOwner to force recalculation
if (EntityManager.HasComponent&lt;PathOwner&gt;(targetEntity))
{
    PathOwner owner = EntityManager.GetComponentData&lt;PathOwner&gt;(targetEntity);
    owner.m_State |= PathFlags.Obsolete;
    owner.m_ElementIndex = 0; // reset progress
    EntityManager.SetComponentData(targetEntity, owner);
}</code></pre>

  <h3>Example 5: Modifying Pathfind Costs (Harmony Patch)</h3>
  <p>
    Patch <code>PathUtils.CalculateCost</code> to adjust route costs. This example penalizes
    congested roads to encourage route distribution.
  </p>
  <pre><code>[HarmonyPatch(typeof(PathUtils), nameof(PathUtils.CalculateCost),
    new[] { typeof(Unity.Mathematics.Random),
            typeof(PathSpecification),
            typeof(PathfindParameters) },
    new[] { ArgumentType.Ref, ArgumentType.Ref, ArgumentType.Ref })]
public static class PathCostPatch
{
    public static void Postfix(
        ref float __result,
        in PathSpecification pathSpecification)
    {
        if (pathSpecification.m_Density &gt; 0.5f)
        {
            float penalty = 1f + (pathSpecification.m_Density - 0.5f) * 2f;
            __result *= penalty;
        }
    }
}</code></pre>
  <div class="warning">
    <strong>Warning:</strong> <code>PathUtils.CalculateCost</code> is called extremely frequently
    during pathfinding. Patches must be as lightweight as possible. Heavy computation here will
    significantly impact simulation performance.
  </div>

  <!-- ============================================================ -->
  <h2>Configuration</h2>

  <h3>PathfindParameters</h3>
  <p>Submitted with every pathfind request. Key fields:</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Methods</code></td><td>PathMethod</td><td>Which transport methods are allowed</td></tr>
      <tr><td><code>m_Weights</code></td><td>PathfindWeights</td><td>Per-agent cost dimension weights (time, behaviour, money, comfort)</td></tr>
      <tr><td><code>m_MaxCost</code></td><td>float</td><td>Maximum total cost before search terminates</td></tr>
      <tr><td><code>m_MaxSpeed</code></td><td>float2</td><td>Maximum vehicle speed (m/s)</td></tr>
      <tr><td><code>m_WalkSpeed</code></td><td>float2</td><td>Walking speed (m/s)</td></tr>
      <tr><td><code>m_MaxResultCount</code></td><td>int</td><td>Maximum number of path results</td></tr>
      <tr><td><code>m_PathfindFlags</code></td><td>PathfindFlags</td><td>Algorithm behavior flags</td></tr>
      <tr><td><code>m_IgnoredRules</code></td><td>RuleFlags</td><td>Lane policy rules to ignore</td></tr>
      <tr><td><code>m_ParkingTarget</code></td><td>Entity</td><td>Specific parking target lane entity (if any)</td></tr>
      <tr><td><code>m_ParkingDelta</code></td><td>float</td><td>Position along the parking lane curve (0.0-1.0)</td></tr>
      <tr><td><code>m_ParkingSize</code></td><td>float</td><td>Size of the parking space required by the vehicle</td></tr>
      <tr><td><code>m_Authorization1</code></td><td>Entity</td><td>First access authorization entity (e.g., gated area pass)</td></tr>
      <tr><td><code>m_Authorization2</code></td><td>Entity</td><td>Second access authorization entity</td></tr>
      <tr><td><code>m_TaxiIgnoredRules</code></td><td>RuleFlags</td><td>Lane policy rules that taxis may ignore (e.g., transit-only restrictions)</td></tr>
    </tbody>
  </table>
  <p>
    <strong>Parking fields:</strong> <code>m_ParkingTarget</code>, <code>m_ParkingDelta</code>, and
    <code>m_ParkingSize</code> are set when the pathfind request needs a route ending at a specific
    parking spot. The target is the lane entity, the delta is the normalized curve position, and
    the size constrains which spaces the vehicle can fit in.
  </p>
  <p>
    <strong>Authorization fields:</strong> <code>m_Authorization1</code> and <code>m_Authorization2</code>
    are checked against <code>PathSpecification.m_AccessRequirement</code> on graph edges. If an edge
    requires authorization, the agent must carry a matching authorization entity to traverse it.
  </p>
  <p>
    <strong>Taxi rules:</strong> <code>m_TaxiIgnoredRules</code> is a <code>RuleFlags</code> bitfield
    specifying which lane policy rules taxis are allowed to ignore during pathfinding. For example, a
    taxi may ignore <code>ForbidPrivateTraffic</code> to use bus lanes for pickups. This field is
    checked alongside <code>m_IgnoredRules</code> when evaluating edge traversability for taxi-method
    paths.
  </p>

  <h3>CitizenUtils.GetPathfindWeights</h3>
  <p>
    The <code>CitizenUtils.GetPathfindWeights</code> utility method computes per-citizen
    <code>PathfindWeights</code> based on the citizen's age, wealth, and other attributes. This is
    used when building <code>PathfindParameters</code> for citizen pathfind requests.
  </p>
  <pre><code class="language-csharp">// CitizenUtils.GetPathfindWeights -- returns weighted cost preferences
// Wealth affects money sensitivity, age affects comfort preference, etc.
PathfindWeights weights = CitizenUtils.GetPathfindWeights(citizen, citizenData);</code></pre>
  <p>
    Mods can intercept or replace the weights returned by this method to change how citizens prioritize
    route cost dimensions (time vs. money vs. comfort).
  </p>

  <h3>Prefab Cost Data</h3>
  <p>Base traversal costs defined per transport mode in prefab components:</p>
  <ul>
    <li><strong>PathfindCarData</strong>: DrivingCost, TurningCost, UnsafeTurningCost, UTurnCost, UnsafeUTurnCost, CurveAngleCost, LaneCrossCost, ParkingCost, SpawnCost, ForbiddenCost</li>
    <li><strong>PathfindPedestrianData</strong>: WalkingCost, CrosswalkCost, UnsafeCrosswalkCost, SpawnCost</li>
    <li><strong>PathfindTrackData</strong>: Rail-specific costs</li>
    <li><strong>PathfindTransportData</strong>: Public transit boarding/transfer costs</li>
    <li><strong>PathfindConnectionData</strong>: Outside connection costs</li>
  </ul>

  <h3>PathfindPedestrianData Full Structure</h3>
  <p>
    The <code>PathfindPedestrianData</code> prefab component defines base costs for pedestrian
    pathfinding. All cost fields are <code>PathfindCosts</code> (<code>float4</code>) with channels:
    time, behaviour, money, comfort.
  </p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_WalkingCost</code></td><td>PathfindCosts (float4)</td><td>Base cost per unit distance of walking on a pedestrian lane</td></tr>
      <tr><td><code>m_CrosswalkCost</code></td><td>PathfindCosts (float4)</td><td>Additional cost for using a signalized crosswalk</td></tr>
      <tr><td><code>m_UnsafeCrosswalkCost</code></td><td>PathfindCosts (float4)</td><td>Additional cost for jaywalking / unsignalized crossing</td></tr>
      <tr><td><code>m_SpawnCost</code></td><td>PathfindCosts (float4)</td><td>One-time cost for spawning a pedestrian (entering the network)</td></tr>
    </tbody>
  </table>
  <p>
    <strong>Runtime modification pattern:</strong> These values are on the pathfind prefab entity and
    can be modified at runtime to globally change pedestrian routing behavior. For example, increasing
    <code>m_UnsafeCrosswalkCost.y</code> (behaviour channel) discourages jaywalking without completely
    preventing it.
  </p>
  <pre><code class="language-csharp">// Modify pedestrian crosswalk costs at runtime
Entity pathfindPrefab = GetPathfindPrefabEntity();
PathfindPedestrianData pedData =
    EntityManager.GetComponentData&lt;PathfindPedestrianData&gt;(pathfindPrefab);

// Double the jaywalking penalty (behaviour channel)
pedData.m_UnsafeCrosswalkCost = new PathfindCosts(
    pedData.m_UnsafeCrosswalkCost.m_Value * new float4(1f, 2f, 1f, 1f));

EntityManager.SetComponentData(pathfindPrefab, pedData);</code></pre>

  <h3>Pedestrian Speed &amp; Age Data</h3>

  <h4>HumanData.m_WalkSpeed</h4>
  <p>
    The <code>Game.Prefabs.HumanData</code> component on human prefab entities contains
    <code>m_WalkSpeed</code>, which defines the base walking speed for pedestrians. This value is
    used when building <code>PathfindParameters.m_WalkSpeed</code> for citizen pathfind requests.
  </p>

  <h4>ResidentData.m_Age</h4>
  <p>
    The <code>Game.Prefabs.ResidentData</code> component stores age-related data for residents. The
    <code>m_Age</code> field determines the citizen's age category, which affects walking speed
    multipliers and pathfind weight calculations.
  </p>

  <h4>AgeMask Flags Enum</h4>
  <p>
    Categorizes citizens into age groups for pedestrian speed calculations and citizen pathfind setup:
  </p>
  <pre><code>Child   = 1    // Children -- slowest walk speed
Teen    = 2    // Teenagers -- moderate walk speed
Adult   = 4    // Adults -- standard walk speed
Elderly = 8    // Elderly -- reduced walk speed</code></pre>
  <p>
    For pedestrian speed modding, modify <code>HumanData.m_WalkSpeed</code> on the prefab entity or
    intercept the <code>PathfindParameters.m_WalkSpeed</code> value at queue submission time. The age
    mask can be combined (e.g., <code>Child | Elderly = 9</code>) for queries targeting multiple age
    groups.
  </p>

  <h3>PathSpecification Edge Manipulation</h3>
  <p>
    <code>PathSpecification.m_Density</code> and <code>PathSpecification.m_MaxSpeed</code> can be
    manipulated at runtime as a softer alternative to hard-disabling edges via
    <code>ConnectionLaneFlags.Disabled</code>.
  </p>
  <ul>
    <li>
      <strong>m_Density:</strong> Setting density to a very high value (e.g., 100.0) makes the edge
      extremely expensive to traverse without completely removing it from the graph. Agents will
      strongly avoid the edge but can still use it if no alternative exists. The minimum density is
      0.01 (clamped internally).
    </li>
    <li>
      <strong>m_MaxSpeed:</strong> Setting <code>m_MaxSpeed</code> to a very low value (e.g., 0.01)
      dramatically increases the time cost for traversing the edge, since time cost = length / speed.
      This effectively makes the edge undesirable without disabling it.
    </li>
  </ul>
  <p>
    This approach is preferable to <code>ConnectionLaneFlags.Disabled</code> when you want agents to
    use the edge as a last resort rather than treating it as non-existent. It avoids pathfind failures
    in networks where the disabled edge might be the only route.
  </p>
  <pre><code class="language-csharp">// Soft-disable an edge by inflating density and reducing speed
// Agents will strongly avoid this edge but can still use it if necessary
PathSpecification spec =
    nativePathfindData.GetEdge(edgeIndex).m_Specification;
spec.m_Density = 100f;   // extremely congested
spec.m_MaxSpeed = 0.5f;  // very slow</code></pre>

  <!-- ============================================================ -->
  <h2>Warnings &amp; Pitfalls</h2>

  <ul>
    <li>
      <strong>Burst-compiled jobs are not patchable.</strong> The domain-specific setup helpers
      (e.g., <code>CitizenPathfindSetup.SetupTouristTargetJob</code>) and the core pathfind
      executor (<code>PathfindJobs.PathfindExecutor</code>) are Burst-compiled. They cannot be
      patched with Harmony. Intercept at the queue or result level instead.
    </li>
    <li>
      <strong>Performance sensitivity.</strong> The pathfind pipeline processes thousands of requests
      per frame. Any Harmony patch on <code>PathUtils.CalculateCost</code> or similar hot paths
      must be extremely lightweight.
    </li>
    <li>
      <strong>Pending-to-Obsolete on load.</strong> When deserializing, <code>PathOwner</code> and
      <code>PathInformation</code> automatically convert the <code>Pending</code> flag to
      <code>Obsolete</code>. Do not rely on <code>Pending</code> surviving a save/load cycle.
    </li>
    <li>
      <strong>Double-buffered graph.</strong> The pathfind graph is double-buffered. Graph
      modifications (Create/Update/Delete edges) are applied to both buffers sequentially. Pathfind
      queries run on the current read buffer. Do not assume immediate graph updates.
    </li>
    <li>
      <strong>Native container lifetimes.</strong> Queues from <code>GetQueue()</code> are managed
      by <code>PathfindSetupSystem</code>. Do not dispose them manually.
    </li>
  </ul>

  <!-- ============================================================ -->
  <h2>Additional Harmony Patch Points</h2>

  <p>
    Beyond the core <code>PathUtils.CalculateCost</code> patch shown in Example 5, several other
    static methods are viable Harmony targets:
  </p>

  <h3>Candidate 6: PathUtils.GetCarDriveSpecification</h3>
  <p>
    <strong>Signature (overload 1):</strong>
    <code>PathSpecification GetCarDriveSpecification(in CarLane, in CarLaneData, in PathfindCarData, float length, float density)</code>
  </p>
  <p>
    <strong>Signature (overload 2):</strong>
    <code>PathSpecification GetCarDriveSpecification(in CarLane, in CarLaneData, in PathfindCarData, float length, float density, RuleFlags rules)</code>
  </p>
  <ul>
    <li><strong>Patch type:</strong> Postfix (modify the returned <code>PathSpecification</code>)</li>
    <li><strong>What it enables:</strong> Modify the pathfind edge specification for car driving lanes before it is written to the graph. Adjust costs, density, speed, or rules per-lane.</li>
    <li><strong>Risk level:</strong> Low (pure function, returns a value struct)</li>
    <li><strong>Side effects:</strong> Called during graph edge creation/update -- affects all subsequent pathfinds on modified lanes</li>
  </ul>

  <h3>Candidate 7: PathUtils.GetTaxiDriveSpecification</h3>
  <p>
    <strong>Signature:</strong>
    <code>PathSpecification GetTaxiDriveSpecification(in CarLane, in CarLaneData, in PathfindCarData, float length, float density)</code>
  </p>
  <ul>
    <li><strong>Patch type:</strong> Postfix</li>
    <li><strong>What it enables:</strong> Modify pathfind edge specifications specifically for taxi pathfinding. Useful for taxi-specific lane cost adjustments (e.g., reduced cost on bus lanes for taxis).</li>
    <li><strong>Risk level:</strong> Low (pure function)</li>
    <li><strong>Side effects:</strong> Same as GetCarDriveSpecification but only affects taxi pathfind method edges</li>
  </ul>

  <h3>Candidate 8: PathUtils.TryAddCosts</h3>
  <p>
    <strong>Signature:</strong>
    <code>bool TryAddCosts(ref float totalCost, PathfindCosts costs, PathfindWeights weights, float maxCost)</code>
  </p>
  <ul>
    <li><strong>Patch type:</strong> Prefix (to override cost accumulation) or Postfix (to adjust running total)</li>
    <li><strong>What it enables:</strong> Intercept the incremental cost accumulation during edge evaluation. Can clamp, multiply, or conditionally zero out costs for specific edges.</li>
    <li><strong>Risk level:</strong> Medium -- called extremely frequently during pathfinding (inner loop of A*)</li>
    <li><strong>Side effects:</strong> Modifying the running total affects whether the pathfinder prunes the edge early via <code>maxCost</code> comparison. Must be very lightweight.</li>
  </ul>

  <!-- ============================================================ -->
  <h2>PathMethod &amp; PathNode for Lane Connection Modding</h2>

  <p>
    When creating custom lane connections (e.g., the Traffic mod's <code>GeneratedConnection</code>),
    two key types control how the pathfinder traverses between lanes:
  </p>

  <h3>PathMethod for Connections</h3>
  <p>
    The <code>PathMethod</code> flags enum controls which pathfinding methods can use a connection.
    Connections store <code>PathMethod</code> to filter which vehicle types can traverse them:
  </p>
  <table>
    <thead><tr><th>Flag</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>Road</code></td><td>Usable by road vehicles</td></tr>
      <tr><td><code>Track</code></td><td>Usable by track vehicles (tram, train)</td></tr>
      <tr><td><code>Pedestrian</code></td><td>Usable by pedestrians</td></tr>
      <tr><td><code>Flying</code></td><td>Usable by aircraft</td></tr>
      <tr><td><code>Watercraft</code></td><td>Usable by watercraft</td></tr>
    </tbody>
  </table>

  <h3>PathNode for Connections</h3>
  <p>
    <code>Connection</code> buffer elements store source/target <code>PathNode</code> and
    <code>PathMethod</code> to define how the pathfinder traverses between lanes. Lane connection
    mods create custom connections with appropriate <code>PathNode</code> endpoints and
    <code>PathMethod</code> flags.
  </p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_StartNode</code></td><td>ushort</td><td>Lane graph start node index</td></tr>
      <tr><td><code>m_MiddleNode</code></td><td>ushort</td><td>Lane graph middle node index</td></tr>
      <tr><td><code>m_EndNode</code></td><td>ushort</td><td>Lane graph end node index</td></tr>
    </tbody>
  </table>

  <!-- ============================================================ -->
  <h2>Mod Blueprint</h2>

  <h3>Systems to Create</h3>
  <ul>
    <li>Custom <code>GameSystemBase</code> that requests pathfinds via <code>PathfindSetupSystem.GetQueue()</code></li>
    <li>Post-processing system that reacts to <code>PathUpdated</code> events</li>
    <li>Optional system that modifies <code>PathfindParameters</code> before submission (e.g., custom cost weights)</li>
  </ul>

  <h3>Components to Add</h3>
  <ul>
    <li>Custom component on entities that need modified pathfinding behavior</li>
    <li>Tag component to identify entities with custom path preferences</li>
  </ul>

  <h3>Patches Needed</h3>
  <ul>
    <li>Postfix on <code>PathUtils.CalculateCost</code> for route cost modification</li>
    <li>Or: custom ECS system that modifies <code>PathElement</code> buffers post-pathfind</li>
  </ul>

  <h3>Settings</h3>
  <p>User-configurable cost multipliers for different transport methods.</p>

  <h3>UI Changes</h3>
  <p>Optional debug overlay showing pathfind statistics via <code>PathfindResultSystem.queryStats</code>.</p>

  <!-- ============================================================ -->
  <h2>Open Questions</h2>

  <ul>
    <li>How exactly does the A* heuristic use <code>PathfindHeuristicData</code>? The per-method minimum costs appear to be used for admissible heuristic estimation, but the formula in the Burst-compiled executor is hard to trace.</li>
    <li>What is the internal structure of <code>NativePathfindData</code>? The double-buffering scheme suggests read/write separation, but the graph data layout is opaque.</li>
    <li>How does <code>PathfindTargetSeekerData</code> resolve generic target types into lane-level positions? The spatial query mechanism is spread across domain helpers.</li>
    <li>When is <code>PathfindFlags.SkipPathfind</code> used? It appears to bypass graph traversal and pick the cheapest target directly -- possibly for simplified service dispatch.</li>
    <li>How does the <code>Divert</code> mechanism work for mid-path rerouting?</li>
  </ul>

  <!-- ============================================================ -->
  <h2>Sources</h2>

  <ul>
    <li>Decompiled from Game.dll (Cities: Skylines II)</li>
    <li>Namespaces: Game.Pathfind, Game.Simulation, Game.Prefabs, Game.Common</li>
    <li>Key types: PathOwner, PathElement, PathInformation, PathNode, Edge, PathSpecification, PathTarget, PathfindParameters, PathfindWeights, PathfindCosts, SetupQueueItem, SetupQueueTarget, PathfindSetupSystem, PathfindQueueSystem, PathfindResultSystem, PathUtils, all related enums</li>
  </ul>

  </main>

</div>

<footer>
  <p>Research decompiled from Cities: Skylines II game assemblies using ilspycmd. For educational and modding purposes.</p>
  <div class="attribution-footer">
    <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
  </div>
</footer>

</body>
</html>
