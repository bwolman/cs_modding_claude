<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Object Placement Tool - CS2 Modding Research</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="top-bar">
  <a href="index.html" class="site-title">CS2 Modding Research</a>
  <span class="attribution">Generated with Claude | Supervised by repository owner</span>
</div>

<div class="page-layout">

    <aside class="sidebar">
    <h3>Events &amp; Simulation</h3>
    <a href="event-entity-archetype.html">Event Entity Archetype</a>
    <a href="fire-ignition.html">Fire Ignition</a>
    <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
    <a href="crime-trigger.html">Crime Trigger</a>
    <a href="citizen-sickness.html">Citizen Sickness</a>
    <a href="water-system.html">Water System</a>
    <a href="emergency-dispatch.html">Emergency Dispatch</a>
    <a href="disaster-simulation.html">Disaster Simulation</a>

    <h3>Infrastructure</h3>
    <a href="electricity-grid.html">Electricity Grid</a>
    <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
    <a href="road-network.html">Road &amp; Network Building</a>
    <a href="zoning.html">Zoning</a>
    <a href="building-construction.html">Building Construction</a>
    <a href="pathfinding.html">Pathfinding</a>
    <a href="traffic-flow.html">Traffic Flow</a>

    <h3>Economy &amp; Population</h3>
    <a href="citizens-households.html">Citizens &amp; Households</a>
    <a href="economy-budget.html">Economy &amp; Budget</a>
    <a href="demand-systems.html">Demand Systems</a>
    <a href="resource-production.html">Resource Production</a>
    <a href="company-simulation.html">Company Simulation</a>
    <a href="workplace-labor.html">Workplace &amp; Labor</a>
    <a href="land-value-property.html">Land Value &amp; Property</a>
    <a href="trade-connections.html">Trade &amp; Connections</a>
    <a href="tourism-economy.html">Tourism Economy</a>
    <a href="cargo-transport.html">Cargo Transport</a>

    <h3>City Services</h3>
    <a href="garbage-collection.html">Garbage Collection</a>
    <a href="education.html">Education</a>
    <a href="public-transit.html">Public Transit</a>
    <a href="healthcare.html">Healthcare</a>
    <a href="deathcare.html">Deathcare</a>
    <a href="parks-recreation.html">Parks &amp; Recreation</a>
    <a href="police-dispatch.html">Police Dispatch</a>

    <h3>Governance</h3>
    <a href="districts-policies.html">Districts &amp; Policies</a>
    <a href="map-tile-purchase.html">Map Tile Purchase</a>

    <h3>Environment</h3>
    <a href="weather-climate.html">Weather &amp; Climate</a>
    <a href="pollution.html">Pollution</a>
    <a href="terrain-resources.html">Terrain &amp; Resources</a>

    <h3>Vehicles &amp; Transport</h3>
    <a href="vehicle-spawning.html">Vehicle Spawning</a>
    <a href="parking-system.html">Parking System</a>

    <h3>Tools &amp; Input</h3>
    <a href="tool-activation.html">Tool Activation</a>
    <a href="tool-raycast.html">Tool Raycast</a>
    <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
    <a href="mod-hotkey-input.html">Mod Hotkey Input</a>
    <a href="object-tool-system.html" class="active">Object Placement Tool</a>

    <h3>UI &amp; Settings</h3>
    <a href="mod-ui-buttons.html">Mod UI Buttons</a>
    <a href="mod-options-ui.html">Mod Options UI</a>
    <a href="info-views-overlays.html">Info Views &amp; Overlays</a>
    <a href="chirper-notifications.html">Chirper Notifications</a>

    <h3>Modding Framework</h3>
    <a href="save-load-persistence.html">Save/Load Persistence</a>
    <a href="prefab-system.html">Prefab System</a>
    <a href="localization.html">Localization</a>
    <a href="harmony-transpilers.html">Harmony Transpilers</a>
    <a href="mod-loading-dependencies.html">Mod Loading</a>
  </aside>

  <main class="content">

  <h1>Object Placement Tool (ObjectToolSystem)</h1>

  <div class="scope">
    <h2>Scope</h2>
    <p>
      <strong>Question:</strong> How does CS2 place standalone objects (buildings, props, trees,
      decorations) in the game world? What is the definition entity pipeline from preview to
      permanent placement?
    </p>
    <p>
      <strong>Verdict:</strong> Object placement uses a <strong>definition entity pipeline</strong>.
      <code>ObjectToolSystem</code> creates temporary definition entities (<code>CreationDefinition</code>
      + <code>ObjectDefinition</code>) that preview the placement. When the user confirms, the
      <code>Permanent</code> flag is set and the entities become real game objects. The tool supports
      7 modes: Create, Upgrade, Move, Brush, Stamp, Line, and Curve.
    </p>
  </div>

  <!-- ============================================================ -->
  <h2>How It Works</h2>

  <p>
    The <code>ObjectToolSystem</code> is the primary tool for placing anything that is not a road
    or network segment. It handles single object placement, brush-based scattering, stamp groups,
    and line/curve placement of repeating objects like trees along a path.
  </p>

  <h3>The Definition Entity Pipeline</h3>

  <p>
    Object placement follows a two-phase approach: <strong>preview</strong> then <strong>commit</strong>.
    During preview, the tool creates temporary "definition" entities that the game renders as
    transparent ghost objects. When the user clicks to confirm, the definitions are flagged as
    permanent and processed into real game entities.
  </p>

  <div class="diagram"><pre>
[User selects prefab]
        |
        v
[ObjectToolSystem.prefab = selected]
  - Configures allowed modes (Create/Brush/Stamp/Line/Curve)
  - Based on ObjectGeometryData flags (Brushable, Stampable)
        |
        v
[Each frame: CreateDefinitionsJob]
  - Raycast -> ControlPoint (snapped position)
  - Creates definition entity:
    Entity + CreationDefinition + ObjectDefinition + Updated
  - Preview rendered with Temp component
        |
  [User clicks Apply]
        |
        v
[CreationFlags.Permanent added]
  - ToolOutputBarrier processes definitions
  - Real game entities created
  - Temp entities destroyed
  - Sub-objects spawned (building props, lot decorations)
  </pre></div>

  <!-- ============================================================ -->
  <h2>Tool Modes</h2>

  <table>
    <thead><tr><th>Mode</th><th>Value</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td>Create</td><td>0</td><td>Place a single object at the cursor position</td></tr>
      <tr><td>Upgrade</td><td>1</td><td>Upgrade an existing object (e.g., add features to a building)</td></tr>
      <tr><td>Move</td><td>2</td><td>Relocate an existing object to a new position</td></tr>
      <tr><td>Brush</td><td>3</td><td>Paint objects across an area using a brush (trees, props)</td></tr>
      <tr><td>Stamp</td><td>4</td><td>Place a predefined group/pattern of objects at once</td></tr>
      <tr><td>Line</td><td>5</td><td>Place objects evenly along a straight line between two control points</td></tr>
      <tr><td>Curve</td><td>6</td><td>Place objects evenly along a curved path defined by three control points</td></tr>
    </tbody>
  </table>

  <p>
    Not all modes are available for all prefabs. The <code>actualMode</code> property resolves the
    current mode based on what the selected prefab supports:
  </p>
  <ul>
    <li><strong>Brushable</strong> objects (from <code>ObjectGeometryData.m_Flags</code>) enable Brush, Line, and Curve modes</li>
    <li><strong>Stampable</strong> objects enable Stamp mode</li>
    <li>Trees also enable the <strong>age mask</strong> selector (Sapling, Young, Mature, Elderly)</li>
  </ul>

  <h3>Line and Curve Mode Details</h3>

  <p>
    <strong>Line mode (5)</strong> lets the user place two control points defining a straight line.
    The tool reuses <code>NetCourse</code> entities (the same system used by <code>NetToolSystem</code>
    for roads) to define the path. <code>CreateDefinitionsJob</code> distributes objects evenly along
    the line based on the object's size from <code>ObjectGeometryData</code>. Spacing equals the
    object's size along the placement axis, ensuring edge-to-edge placement without overlap.
  </p>

  <p>
    <strong>Curve mode (6)</strong> works similarly but with three control points defining a Bezier
    curve (start, midpoint, end). Objects are distributed evenly along the curve's arc length and
    rotated to follow the curve tangent at each placement point. Both modes register the
    "Place Net Edge" and "Undo Net Control Point" input actions and require the <code>Brushable</code>
    flag on the prefab's <code>ObjectGeometryData</code>.
  </p>

  <!-- ============================================================ -->
  <h2>Key Components</h2>

  <h3>CreationDefinition</h3>
  <p>Defines <em>what</em> to create. Created as a temporary entity during the tool's definition phase.</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Prefab</code></td><td>Entity</td><td>Prefab entity to instantiate</td></tr>
      <tr><td><code>m_SubPrefab</code></td><td>Entity</td><td>Sub-prefab for variations</td></tr>
      <tr><td><code>m_Original</code></td><td>Entity</td><td>Original entity (for Move/Upgrade operations)</td></tr>
      <tr><td><code>m_Owner</code></td><td>Entity</td><td>Parent/owner entity</td></tr>
      <tr><td><code>m_Attached</code></td><td>Entity</td><td>Entity to attach to</td></tr>
      <tr><td><code>m_Flags</code></td><td>CreationFlags</td><td>Permanent, Select, Delete, Attach, Upgrade, Relocate, etc.</td></tr>
      <tr><td><code>m_RandomSeed</code></td><td>int</td><td>Random seed for variation selection</td></tr>
    </tbody>
  </table>

  <h3>ObjectDefinition</h3>
  <p>Specifies <em>where</em> and <em>how</em> to place the object.</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Position</code></td><td>float3</td><td>World position</td></tr>
      <tr><td><code>m_LocalPosition</code></td><td>float3</td><td>Position relative to parent</td></tr>
      <tr><td><code>m_Scale</code></td><td>float3</td><td>Scale factor</td></tr>
      <tr><td><code>m_Rotation</code></td><td>quaternion</td><td>World rotation</td></tr>
      <tr><td><code>m_LocalRotation</code></td><td>quaternion</td><td>Rotation relative to parent</td></tr>
      <tr><td><code>m_Elevation</code></td><td>float</td><td>Elevation offset</td></tr>
      <tr><td><code>m_Age</code></td><td>float</td><td>Tree age (for vegetation)</td></tr>
      <tr><td><code>m_ParentMesh</code></td><td>int</td><td>Parent mesh index (-1 if none)</td></tr>
      <tr><td><code>m_Probability</code></td><td>int</td><td>Spawn probability (0-100)</td></tr>
      <tr><td><code>m_PrefabSubIndex</code></td><td>int</td><td>Sub-object index (-1 if none)</td></tr>
    </tbody>
  </table>

  <h3>Temp</h3>
  <p>
    Tag component on preview entities. While <code>Temp</code> is present, the entity is visible
    but not committed to the game world. Removing <code>Temp</code> (or adding <code>Permanent</code>
    flag) commits the object.
  </p>

  <h3>ControlPoint</h3>
  <p>Represents a raycast hit point used by tools for positioning.</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Position</code></td><td>float3</td><td>Snapped world position</td></tr>
      <tr><td><code>m_HitPosition</code></td><td>float3</td><td>Raw raycast hit position</td></tr>
      <tr><td><code>m_Direction</code></td><td>float2</td><td>Placement direction</td></tr>
      <tr><td><code>m_HitDirection</code></td><td>float3</td><td>Surface normal at hit point</td></tr>
      <tr><td><code>m_Rotation</code></td><td>quaternion</td><td>Snap-influenced rotation</td></tr>
      <tr><td><code>m_OriginalEntity</code></td><td>Entity</td><td>Entity that was hit by the raycast</td></tr>
      <tr><td><code>m_SnapPriority</code></td><td>float2</td><td>Snap priority values</td></tr>
      <tr><td><code>m_ElementIndex</code></td><td>int2</td><td>Element/cell index for grid snapping</td></tr>
      <tr><td><code>m_CurvePosition</code></td><td>float</td><td>Curve position for edge snapping</td></tr>
      <tr><td><code>m_Elevation</code></td><td>float</td><td>Elevation at hit point</td></tr>
    </tbody>
  </table>

  <h3>PlaceableObjectData</h3>
  <p>Prefab component controlling placement behavior.</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_PlacementOffset</code></td><td>float3</td><td>Offset from placement point</td></tr>
      <tr><td><code>m_ConstructionCost</code></td><td>uint</td><td>Cost to place the object</td></tr>
      <tr><td><code>m_XPReward</code></td><td>int</td><td>XP earned on placement</td></tr>
      <tr><td><code>m_DefaultProbability</code></td><td>byte</td><td>Default spawn probability</td></tr>
      <tr><td><code>m_RotationSymmetry</code></td><td>RotationSymmetry</td><td>Any (free rotation disabled), None (full rotation), etc.</td></tr>
      <tr><td><code>m_Flags</code></td><td>PlacementFlags</td><td>Placement behavior flags</td></tr>
    </tbody>
  </table>

  <!-- ============================================================ -->
  <h2>Snapping System</h2>

  <p>
    The <code>SnapJob</code> adjusts placement positions based on the active snap modes. Key snap
    behaviors include:
  </p>
  <ul>
    <li><strong>ZoneGrid</strong> -- snap to zone cell grid</li>
    <li><strong>ObjectSurface</strong> -- snap to surfaces of existing objects</li>
    <li><strong>NetSide / NetMiddle</strong> -- snap to road sides or median</li>
    <li><strong>ExistingGeometry</strong> -- snap to existing object positions</li>
    <li><strong>Upright</strong> -- force upright orientation regardless of surface normal</li>
    <li><strong>LotGrid</strong> -- snap to building lot grid</li>
    <li><strong>GuideLines</strong> -- show and snap to alignment guide lines</li>
  </ul>

  <!-- ============================================================ -->
  <h2>CreationFlags Reference</h2>

  <pre><code>Permanent = 1        // Commit to game world
Select = 2           // Select after creation
Delete = 4           // Delete the original entity
Attach = 8           // Attach to another entity
Upgrade = 0x10       // Upgrade operation
Relocate = 0x20      // Move existing object
Invert = 0x40        // Invert direction
Align = 0x80         // Align to surface
Hidden = 0x100       // Hidden creation
Parent = 0x200       // Set parent relationship
Dragging = 0x400     // Created while dragging
Recreate = 0x800     // Recreate existing
Optional = 0x1000    // Optional sub-object
Lowered = 0x2000     // Below grade
Construction = 0x8000 // Under construction
Duplicate = 0x20000  // Duplicate existing
Stamping = 0x80000   // Part of stamp</code></pre>

  <!-- ============================================================ -->
  <h2>TempFlags Reference</h2>

  <pre><code>Create = 1       Delete = 2      IsLast = 4
Essential = 8    Dragging = 0x10 Select = 0x20
Modify = 0x40    Regenerate = 0x80
Replace = 0x100  Upgrade = 0x200
Hidden = 0x400   Parent = 0x800
Combine = 0x1000 RemoveCost = 0x2000
Optional = 0x4000 Cancel = 0x8000
SubDetail = 0x10000 Duplicate = 0x20000</code></pre>

  <!-- ============================================================ -->
  <h2>Snap Modes Reference</h2>

  <pre><code>ExistingGeometry = 1   CellLength = 2
StraightDirection = 4  NetSide = 8
NetArea = 0x10         OwnerSide = 0x20
ObjectSide = 0x40      NetMiddle = 0x80
Shoreline = 0x100      NearbyGeometry = 0x200
GuideLines = 0x400     ZoneGrid = 0x800
NetNode = 0x1000       ObjectSurface = 0x2000
Upright = 0x4000       LotGrid = 0x8000
AutoParent = 0x10000   PrefabType = 0x20000
ContourLines = 0x40000 Distance = 0x80000</code></pre>

  <!-- ============================================================ -->
  <h2>Harmony Patch Points</h2>

  <h3>ObjectToolSystem.prefab setter -- Prefix/Postfix</h3>
  <p>Intercept or override prefab selection, modify allowed modes. Low risk, but UI may need to be kept in sync.</p>

  <h3>ObjectToolBaseSystem.CreateDefinitionsJob -- Not Patchable</h3>
  <p><strong>Burst-compiled</strong>. Cannot be patched with Harmony. <strong>Alternative</strong>: Create a custom system that modifies definition entities after creation.</p>

  <h3>Post-definition entity modification (Custom ECS System)</h3>
  <p>Modify <code>CreationDefinition</code> / <code>ObjectDefinition</code> after the tool creates them, before they become permanent. Low risk, clean ECS approach.</p>

  <!-- ============================================================ -->
  <h2>Examples</h2>

  <h3>Example 1: Placing an Object Programmatically</h3>
  <p>
    Create definition entities directly to place objects without using the tool UI. This is the
    key pattern for mods that need to spawn buildings, props, or trees programmatically.
  </p>
  <pre><code>public partial class PlaceObjectSystem : GameSystemBase
{
    private PrefabSystem m_PrefabSystem;
    private EndFrameBarrier m_Barrier;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_PrefabSystem = World.GetOrCreateSystemManaged&lt;PrefabSystem&gt;();
        m_Barrier = World.GetOrCreateSystemManaged&lt;EndFrameBarrier&gt;();
    }

    public void PlaceObject(PrefabBase prefab, float3 position, quaternion rotation)
    {
        Entity prefabEntity = m_PrefabSystem.GetEntity(prefab);
        EntityCommandBuffer ecb = m_Barrier.CreateCommandBuffer();

        Entity defEntity = ecb.CreateEntity();

        // What to create
        ecb.AddComponent(defEntity, new CreationDefinition
        {
            m_Prefab = prefabEntity,
            m_Flags = CreationFlags.Permanent
        });

        // Where and how
        ecb.AddComponent(defEntity, new ObjectDefinition
        {
            m_Position = position,
            m_Rotation = rotation,
            m_Probability = 100,
            m_PrefabSubIndex = -1,
            m_ParentMesh = -1
        });

        // Trigger processing
        ecb.AddComponent(defEntity, default(Updated));
    }

    protected override void OnUpdate() { }
}</code></pre>

  <h3>Example 2: Monitoring Object Placement</h3>
  <p>React to objects being placed by querying definition entities with the Permanent flag.</p>
  <pre><code>public partial class PlacementMonitorSystem : GameSystemBase
{
    private EntityQuery m_DefinitionQuery;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_DefinitionQuery = GetEntityQuery(
            ComponentType.ReadOnly&lt;CreationDefinition&gt;(),
            ComponentType.ReadOnly&lt;ObjectDefinition&gt;(),
            ComponentType.ReadOnly&lt;Updated&gt;()
        );
    }

    protected override void OnUpdate()
    {
        var defs = m_DefinitionQuery
            .ToComponentDataArray&lt;CreationDefinition&gt;(Allocator.Temp);
        var objs = m_DefinitionQuery
            .ToComponentDataArray&lt;ObjectDefinition&gt;(Allocator.Temp);

        for (int i = 0; i &lt; defs.Length; i++)
        {
            if ((defs[i].m_Flags &amp; CreationFlags.Permanent) != 0
                &amp;&amp; (defs[i].m_Flags &amp; CreationFlags.Delete) == 0)
            {
                // New object placed at objs[i].m_Position
                Entity prefab = defs[i].m_Prefab;
            }
        }

        defs.Dispose();
        objs.Dispose();
    }
}</code></pre>

  <h3>Example 3: Activating the Tool with a Prefab</h3>
  <p>Programmatically activate the object tool and set a specific prefab.</p>
  <pre><code>public void ActivateObjectTool(
    PrefabSystem prefabSystem,
    ToolSystem toolSystem,
    ObjectToolSystem objectToolSystem,
    string prefabName)
{
    if (prefabSystem.TryGetPrefab(
        new PrefabID(nameof(StaticObjectPrefab), prefabName),
        out PrefabBase prefab))
    {
        objectToolSystem.prefab = prefab as ObjectPrefab;
        objectToolSystem.mode = ObjectToolSystem.Mode.Create;
        toolSystem.activeTool = objectToolSystem;
    }
}</code></pre>

  <h3>Example 4: Modifying Object Position Before Placement (Snap to Grid)</h3>
  <p>Create a system that adjusts object positions in definition entities before they become permanent.</p>
  <pre><code class="language-csharp">public partial class SnapToGridSystem : GameSystemBase
{
    private EntityQuery m_TempDefinitionQuery;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_TempDefinitionQuery = GetEntityQuery(
            ComponentType.ReadWrite&lt;ObjectDefinition&gt;(),
            ComponentType.ReadOnly&lt;CreationDefinition&gt;(),
            ComponentType.ReadOnly&lt;Temp&gt;() // only temp (preview) entities
        );
    }

    protected override void OnUpdate()
    {
        var entities = m_TempDefinitionQuery.ToEntityArray(Allocator.Temp);

        for (int i = 0; i &lt; entities.Length; i++)
        {
            ObjectDefinition obj = EntityManager
                .GetComponentData&lt;ObjectDefinition&gt;(entities[i]);

            // Snap to a custom 8m grid
            float gridSize = 8f;
            obj.m_Position.x = math.round(obj.m_Position.x / gridSize) * gridSize;
            obj.m_Position.z = math.round(obj.m_Position.z / gridSize) * gridSize;

            EntityManager.SetComponentData(entities[i], obj);
        }

        entities.Dispose();
    }
}</code></pre>

  <h3>Example 5: Reading Tool State</h3>
  <pre><code class="language-csharp">if (toolSystem.activeTool is ObjectToolSystem objectTool)
{
    ObjectToolSystem.Mode currentMode = objectTool.actualMode;
    ObjectPrefab selectedPrefab = objectTool.prefab;
    bool isUpgrading = objectTool.isUpgradeMode;

    if (selectedPrefab != null)
    {
        string name = selectedPrefab.name;
        // Object tool active with this prefab
    }
}</code></pre>

  <!-- ============================================================ -->
  <h2>Subclassing ObjectToolBaseSystem</h2>

  <p>Mods can subclass <code>ObjectToolBaseSystem</code> directly to create fully custom placement tools
  that bypass <code>ObjectToolSystem</code> entirely. This is appropriate when the mod needs complete
  control over prefab management, entity creation, and placement logic.</p>

  <h3>toolID Override</h3>
  <p>The <code>toolID</code> string uniquely identifies the tool to the game's UI system. To reuse the
  vanilla object tool's UI (toolbar highlight, options panel), return <code>ObjectToolSystem</code>'s
  <code>toolID</code> instead:</p>
  <pre><code class="language-csharp">public partial class CustomPlacementTool : ObjectToolBaseSystem
{
    // Unique ID -- game shows no vanilla tool UI
    public override string toolID =&gt; "My Custom Placer";

    // OR: spoof the object tool's ID to reuse its UI panels
    // public override string toolID =&gt; "Object Tool";
}</code></pre>

  <h3>GetPrefab() / TrySetPrefab() Overrides</h3>
  <p>These abstract methods manage which prefab the tool places. <code>GetPrefab()</code> is called each
  frame by <code>ToolSystem</code> to determine the active prefab. <code>TrySetPrefab()</code> is called
  by <code>ToolSystem.ActivatePrefabTool()</code> when iterating tools:</p>
  <pre><code class="language-csharp">public partial class CustomPlacementTool : ObjectToolBaseSystem
{
    private PrefabBase m_Prefab;

    public override PrefabBase GetPrefab() =&gt; m_Prefab;

    public override bool TrySetPrefab(PrefabBase prefab)
    {
        // Accept only prefabs this tool handles
        if (prefab is StaticObjectPrefab staticPrefab
            &amp;&amp; HasCustomRequirements(staticPrefab))
        {
            m_Prefab = prefab;
            return true;
        }
        return false;
    }
}</code></pre>

  <h3>Direct Entity Creation via ObjectData.m_Archetype</h3>
  <p>Instead of going through the <code>CreationDefinition</code> / <code>Temp</code> / permanent
  pipeline, custom tools can create entities directly using the prefab's archetype. This skips the
  preview phase entirely:</p>
  <pre><code class="language-csharp">public void CreateEntityDirectly(Entity prefabEntity, float3 position, quaternion rotation)
{
    var objectData = EntityManager.GetComponentData&lt;ObjectData&gt;(prefabEntity);
    Entity entity = EntityManager.CreateEntity(objectData.m_Archetype);

    EntityManager.SetComponentData(entity, new PrefabRef { m_Prefab = prefabEntity });
    EntityManager.SetComponentData(entity, new Game.Objects.Transform
    {
        m_Position = position,
        m_Rotation = rotation
    });

    // Trigger initialization systems
    EntityManager.AddComponent&lt;Created&gt;(entity);
    EntityManager.AddComponent&lt;Updated&gt;(entity);
}</code></pre>
  <p><strong>Warning</strong>: Direct creation bypasses validation, cost deduction, and undo support.
  Use the <code>CreationDefinition</code> pipeline for user-facing placement. Reserve direct creation
  for programmatic spawning where the mod handles validation.</p>

  <!-- ============================================================ -->
  <h2>Highlighted + Updated Pattern for Preview-to-Permanent</h2>

  <p>An alternative to the standard <code>Temp</code> entity preview pipeline. Instead of creating
  <code>Temp</code> entities (which are destroyed and re-created each frame), mods can create real
  entities with the <code>Highlighted</code> component for preview rendering, then make them permanent
  by removing <code>Highlighted</code>.</p>

  <ol>
    <li><strong>Preview phase</strong>: Create a real entity using <code>ObjectData.m_Archetype</code>.
    Add <code>Highlighted</code> + <code>Updated</code> so it renders with the highlight shader but
    is not yet committed to the game simulation.</li>
    <li><strong>Confirm phase</strong>: Remove <code>Highlighted</code> and add <code>Updated</code>
    -- the entity becomes a normal game entity. No re-creation needed.</li>
    <li><strong>Cancel phase</strong>: Add <code>Deleted</code> to remove the preview entity.</li>
  </ol>

  <pre><code class="language-csharp">private Entity m_PreviewEntity;

private void CreatePreview(Entity prefabEntity, float3 position, quaternion rotation)
{
    var objectData = EntityManager.GetComponentData&lt;ObjectData&gt;(prefabEntity);
    m_PreviewEntity = EntityManager.CreateEntity(objectData.m_Archetype);

    EntityManager.SetComponentData(m_PreviewEntity,
        new PrefabRef { m_Prefab = prefabEntity });
    EntityManager.SetComponentData(m_PreviewEntity,
        new Game.Objects.Transform { m_Position = position, m_Rotation = rotation });

    // Highlighted causes highlight rendering; Updated triggers render refresh
    EntityManager.AddComponent&lt;Highlighted&gt;(m_PreviewEntity);
    EntityManager.AddComponent&lt;Updated&gt;(m_PreviewEntity);
}

private void ConfirmPlacement()
{
    // Remove highlight -- entity becomes permanent
    EntityManager.RemoveComponent&lt;Highlighted&gt;(m_PreviewEntity);
    EntityManager.AddComponent&lt;Updated&gt;(m_PreviewEntity);
    m_PreviewEntity = Entity.Null;
}

private void CancelPlacement()
{
    // Standard CS2 deletion -- triggers cleanup systems
    EntityManager.AddComponent&lt;Deleted&gt;(m_PreviewEntity);
    m_PreviewEntity = Entity.Null;
}</code></pre>

  <p><strong>Advantages</strong>: No per-frame entity destruction/re-creation, simpler code, entity
  retains its identity throughout preview. <strong>Disadvantages</strong>: No built-in undo, no cost
  calculation, no validation feedback from <code>Generate*Systems</code>.</p>

  <h3>Overridden Component (Game.Common)</h3>
  <p>Marker component for entities that failed validation during placement or were overridden by another
  system. Used as a filter in entity queries (<code>.WithNone&lt;Overridden&gt;()</code>) to exclude
  invalid entities from counts, spatial queries, and other processing.</p>

  <pre><code class="language-csharp">// Check if an entity was rejected by validation
if (EntityManager.HasComponent&lt;Overridden&gt;(entity))
{
    Mod.Log.Warn($"Entity {entity.Index} was overridden (failed validation)");
}

// Exclude overridden entities from queries:
EntityQuery validEntities = SystemAPI.QueryBuilder()
    .WithAll&lt;PrefabRef, Game.Objects.Object&gt;()
    .WithNone&lt;Owner, Controller, Overridden, Deleted&gt;()
    .Build();</code></pre>

  <!-- ============================================================ -->
  <h2>Warnings &amp; Pitfalls</h2>

  <ul>
    <li>
      <strong>CreateDefinitionsJob is Burst-compiled.</strong> The core job that creates definition
      entities cannot be patched with Harmony. To modify placement behavior, create a custom ECS system
      that processes definition entities after they are created.
    </li>
    <li>
      <strong>Definition entities are transient.</strong> Definition entities exist only for one or two
      frames. They are created, processed, and destroyed quickly. Systems that read them must run at the
      right update phase.
    </li>
    <li>
      <strong>Permanent flag is the commit signal.</strong> Without <code>CreationFlags.Permanent</code>,
      definition entities produce only preview (Temp) entities. The Permanent flag must be set for real
      game entities to be created.
    </li>
    <li>
      <strong>Sub-object creation is automatic.</strong> When placing a building, the game automatically
      creates sub-objects (props, decorations) based on the prefab hierarchy. Do not manually create
      sub-objects.
    </li>
    <li>
      <strong>Snap conflicts.</strong> When multiple snap modes are active, the system uses priority
      resolution. <code>AutoParent</code> and <code>ContourLines</code> are excluded from the
      "snap all" mask.
    </li>
  </ul>

  <h2>Tree/Vegetation Tool Properties</h2>

  <h3>ObjectToolSystem.allowAge</h3>
  <p>
    Controls whether the tree age slider appears in the tool UI. Set to <code>true</code>
    when the selected prefab has <code>TreeData</code> and the game is in Game mode.
    Has public getter but private setter â€” mods use reflection to force it on:
  </p>
  <pre><code>// Force age slider for street trees (Tree_Controller pattern)
if (placingStreetTrees &amp;&amp; !m_ObjectToolSystem.allowAge)
    m_ObjectToolSystem.SetMemberValue("allowAge", true);</code></pre>

  <h3>ToolBaseSystem.brushStrength</h3>
  <p>
    Public get/set property, defaults to <code>0.5f</code>. Controls placement density in brush mode.
    Tree_Controller patches <code>ToolUISystem.SetBrushStrength</code> to allow values above 100%:
  </p>
  <pre><code>[HarmonyPatch(typeof(ToolUISystem), "SetBrushStrength")]
static void Postfix(ToolSystem ___m_ToolSystem)
{
    if (___m_ToolSystem.activeTool.brushStrength &gt;= 1.0f)
        ___m_ToolSystem.activeTool.brushStrength = 3.0f; // 300%
}</code></pre>

  <!-- ============================================================ -->
  <h2>Open Questions</h2>

  <ul>
    <li>How exactly does <code>ToolOutputBarrier</code> process definition entities into real game entities?</li>
    <li>How are sub-objects (building props, lot decorations) spawned from the prefab hierarchy during placement?</li>
    <li>What is the exact snap priority resolution when multiple snap modes conflict?</li>
    <li>How does brush mode determine object density and distribution?</li>
  </ul>

  <!-- ============================================================ -->
  <h2>Sources</h2>

  <ul>
    <li>Decompiled from Game.dll (Cities: Skylines II)</li>
    <li>Namespaces: Game.Tools, Game.Prefabs, Game.Objects, Game.Common</li>
    <li>Key types: ObjectToolSystem (~4400 lines), ObjectToolBaseSystem, ToolBaseSystem, CreationDefinition, ObjectDefinition, Temp, ControlPoint, PlaceableObjectData, CreationFlags, TempFlags, Snap</li>
  </ul>

  </main>

</div>

<footer>
  <p>Research decompiled from Cities: Skylines II game assemblies using ilspycmd. For educational and modding purposes.</p>
  <div class="attribution-footer">
    <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
  </div>
</footer>

</body>
</html>
