<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Road &amp; Network Building - CS2 Modding Research</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="top-bar">
    <a href="index.html" class="site-title">CS2 Modding Research</a>
    <span class="attribution">Generated with Claude | Supervised by repository owner</span>
  </div>

  <div class="page-layout">

    <aside class="sidebar">
    <h3>Events &amp; Simulation</h3>
    <a href="event-entity-archetype.html">Event Entity Archetype</a>
    <a href="fire-ignition.html">Fire Ignition</a>
    <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
    <a href="crime-trigger.html">Crime Trigger</a>
    <a href="citizen-sickness.html">Citizen Sickness</a>
    <a href="water-system.html">Water System</a>
    <a href="emergency-dispatch.html">Emergency Dispatch</a>
    <a href="disaster-simulation.html">Disaster Simulation</a>

    <h3>Infrastructure</h3>
    <a href="electricity-grid.html">Electricity Grid</a>
    <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
    <a href="road-network.html" class="active">Road &amp; Network Building</a>
    <a href="zoning.html">Zoning</a>
    <a href="building-construction.html">Building Construction</a>
    <a href="pathfinding.html">Pathfinding</a>
    <a href="traffic-flow.html">Traffic Flow</a>

    <h3>Economy &amp; Population</h3>
    <a href="citizens-households.html">Citizens &amp; Households</a>
    <a href="economy-budget.html">Economy &amp; Budget</a>
    <a href="demand-systems.html">Demand Systems</a>
    <a href="resource-production.html">Resource Production</a>
    <a href="company-simulation.html">Company Simulation</a>
    <a href="workplace-labor.html">Workplace &amp; Labor</a>
    <a href="land-value-property.html">Land Value &amp; Property</a>
    <a href="trade-connections.html">Trade &amp; Connections</a>
    <a href="tourism-economy.html">Tourism Economy</a>
    <a href="cargo-transport.html">Cargo Transport</a>

    <h3>City Services</h3>
    <a href="garbage-collection.html">Garbage Collection</a>
    <a href="education.html">Education</a>
    <a href="public-transit.html">Public Transit</a>
    <a href="healthcare.html">Healthcare</a>
    <a href="deathcare.html">Deathcare</a>
    <a href="parks-recreation.html">Parks &amp; Recreation</a>
    <a href="police-dispatch.html">Police Dispatch</a>

    <h3>Governance</h3>
    <a href="districts-policies.html">Districts &amp; Policies</a>
    <a href="map-tile-purchase.html">Map Tile Purchase</a>

    <h3>Environment</h3>
    <a href="weather-climate.html">Weather &amp; Climate</a>
    <a href="pollution.html">Pollution</a>
    <a href="terrain-resources.html">Terrain &amp; Resources</a>

    <h3>Vehicles &amp; Transport</h3>
    <a href="vehicle-spawning.html">Vehicle Spawning</a>
    <a href="parking-system.html">Parking System</a>

    <h3>Tools &amp; Input</h3>
    <a href="tool-activation.html">Tool Activation</a>
    <a href="tool-raycast.html">Tool Raycast</a>
    <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
    <a href="mod-hotkey-input.html">Mod Hotkey Input</a>
    <a href="object-tool-system.html">Object Placement Tool</a>

    <h3>UI &amp; Settings</h3>
    <a href="mod-ui-buttons.html">Mod UI Buttons</a>
    <a href="mod-options-ui.html">Mod Options UI</a>
    <a href="info-views-overlays.html">Info Views &amp; Overlays</a>
    <a href="chirper-notifications.html">Chirper Notifications</a>

    <h3>Modding Framework</h3>
    <a href="save-load-persistence.html">Save/Load Persistence</a>
    <a href="prefab-system.html">Prefab System</a>
    <a href="localization.html">Localization</a>
    <a href="harmony-transpilers.html">Harmony Transpilers</a>
    <a href="mod-loading-dependencies.html">Mod Loading</a>
  </aside>

    <main class="content">
    <h1>Road &amp; Network Building</h1>

    <div class="scope">
      <p><strong>Goal:</strong> Understand how CS2 creates road segments, nodes, and lanes via <code>NetToolSystem</code> -- the full pipeline from player click to persistent ECS entities -- and how mods can create, modify, and query road networks.</p>
      <p><strong>Use cases:</strong> Programmatic road creation, custom road tools, network topology queries, road modification mods, lane editors.</p>
      <p><strong>Not covered:</strong> Pathfinding algorithms, traffic simulation, vehicle movement along lanes. This focuses on the network data structures and the building pipeline.</p>
    </div>

    <!-- ============================================================ -->
    <h2>How It Works</h2>

    <p>CS2's road network uses a <strong>graph-based ECS model</strong>. Roads are a directed graph of <strong>Nodes</strong> (intersections/endpoints) connected by <strong>Edges</strong> (road segments). Each edge carries a <code>Curve</code> (Bezier spline) defining its shape, a <code>Composition</code> linking to prefab data for visual/functional properties, and a dynamic buffer of <strong>SubLanes</strong> representing individual traffic lanes, sidewalks, and utility conduits.</p>

    <p>The player-facing tool (<code>NetToolSystem</code>) does not create final entities directly. Instead, it creates temporary <code>NetCourse</code> entities -- Bezier curves with start/end positions. These pass through a multi-stage pipeline before becoming permanent simulation entities.</p>

    <h3>The Building Pipeline</h3>

    <div class="diagram"><pre>Player clicks in world
        |
        v
NetToolSystem.OnUpdate()
  - Collects ControlPoint from raycast
  - Snaps to existing geometry (nodes, edges, grid)
  - Creates NetCourse temp entities with Bezier curves
        |
        v
GenerateEdgesSystem / GenerateNodesSystem
  - Converts NetCourse into temp Edge + Node entities
  - Maps CoursePos to nodes (reuses existing or creates new)
  - Splits existing edges if new node placed mid-edge
        |
        v
GeometrySystem
  - Computes EdgeGeometry (left/right bezier segments, bounds)
  - Computes NodeGeometry (bounds, flatness, offset)
        |
        v
CompositionSelectSystem
  - Selects composition prefabs based on flags and context
        |
        v
LaneSystem
  - Creates Lane entities from NetCompositionLane prefab data
  - Attaches Curve to each lane
  - Populates SubLane buffer on parent edge
        |
        v
(Preview shown to player as transparent ghost)
        |
        v
Player confirms (Apply action)
        |
        v
ApplyNetSystem
  - Patches temp entity references to permanent entities
  - Updates ConnectedEdge buffers on nodes
  - Removes Temp component -- entities become permanent</pre></div>

    <h3>NetToolSystem Modes</h3>

    <p>The tool supports seven drawing modes, each controlling how many control points the player places:</p>

    <table>
      <tr><th>Mode</th><th>Control Points</th><th>Description</th></tr>
      <tr><td><code>Straight</code></td><td>2</td><td>Straight line between two points</td></tr>
      <tr><td><code>SimpleCurve</code></td><td>3</td><td>Bezier curve with one midpoint</td></tr>
      <tr><td><code>ComplexCurve</code></td><td>4</td><td>Bezier curve with two midpoints</td></tr>
      <tr><td><code>Continuous</code></td><td>3</td><td>Chain of curves, each continuing from the last</td></tr>
      <tr><td><code>Grid</code></td><td>3</td><td>Grid of parallel and perpendicular roads</td></tr>
      <tr><td><code>Replace</code></td><td>1</td><td>Upgrade/replace existing road segments</td></tr>
      <tr><td><code>Point</code></td><td>1</td><td>Place a single node (editor mode only)</td></tr>
    </table>

    <!-- ============================================================ -->
    <h2>Key Components</h2>

    <h3>Edge</h3>
    <p>The fundamental road segment. Connects two <code>Node</code> entities. Every edge also carries <code>Curve</code>, <code>Composition</code>, <code>EdgeGeometry</code>, and <code>DynamicBuffer&lt;SubLane&gt;</code>.</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Start</code></td><td><code>Entity</code></td><td>Start node entity</td></tr>
      <tr><td><code>m_End</code></td><td><code>Entity</code></td><td>End node entity</td></tr>
    </table>

    <h3>Node</h3>
    <p>An intersection or endpoint where edges meet. Has <code>DynamicBuffer&lt;ConnectedEdge&gt;</code> (capacity 4) listing all connected edges.</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Position</code></td><td><code>float3</code></td><td>World-space position</td></tr>
      <tr><td><code>m_Rotation</code></td><td><code>quaternion</code></td><td>Orientation of the node</td></tr>
    </table>

    <h3>Curve</h3>
    <p>Defines the shape of an edge or lane as a cubic Bezier spline. Present on both edges and individual lanes.</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Bezier</code></td><td><code>Bezier4x3</code></td><td>Cubic Bezier curve (4 control points in 3D)</td></tr>
      <tr><td><code>m_Length</code></td><td><code>float</code></td><td>Cached arc length (recomputed on deserialization)</td></tr>
    </table>

    <h3>Composition</h3>
    <p>Links an edge to its composition prefab entities, which define lane layout, visual appearance, and flags.</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Edge</code></td><td><code>Entity</code></td><td>Composition prefab for the edge section</td></tr>
      <tr><td><code>m_StartNode</code></td><td><code>Entity</code></td><td>Composition prefab for the start node</td></tr>
      <tr><td><code>m_EndNode</code></td><td><code>Entity</code></td><td>Composition prefab for the end node</td></tr>
    </table>

    <h3>Lane</h3>
    <p>A single traffic lane, sidewalk, or utility conduit within an edge. Has its own <code>Curve</code> component.</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_StartNode</code></td><td><code>PathNode</code></td><td>Pathfinding start node</td></tr>
      <tr><td><code>m_MiddleNode</code></td><td><code>PathNode</code></td><td>Pathfinding middle node</td></tr>
      <tr><td><code>m_EndNode</code></td><td><code>PathNode</code></td><td>Pathfinding end node</td></tr>
    </table>

    <h3>SubLane</h3>
    <p>Buffer element on edges listing child lane entities.</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_SubLane</code></td><td><code>Entity</code></td><td>The lane entity</td></tr>
      <tr><td><code>m_PathMethods</code></td><td><code>PathMethod</code></td><td>Which pathfinding methods can use this lane</td></tr>
    </table>

    <h3>ConnectedEdge</h3>
    <p>Buffer element on nodes listing connected edges. Internal buffer capacity of 4 (typical intersection).</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Edge</code></td><td><code>Entity</code></td><td>The connected edge entity</td></tr>
    </table>

    <h3>Elevation</h3>
    <p>Tracks the elevation offset of an edge relative to terrain.</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Elevation</code></td><td><code>float2</code></td><td>Elevation at start (x) and end (y) of the edge</td></tr>
    </table>

    <h3>EdgeGeometry / NodeGeometry</h3>
    <p><code>EdgeGeometry</code> contains left/right <code>Segment</code> Bezier curves and a bounding box. <code>NodeGeometry</code> contains bounds, flatness, and offset. Both are computed by <code>GeometrySystem</code>.</p>

    <h3>StartNodeGeometry / EndNodeGeometry</h3>
    <p>Per-edge components that store how each edge contributes to its start and end intersection nodes. While <code>NodeGeometry</code> lives on the node itself and represents the combined result, these per-edge components describe each individual edge's shape at the junction.</p>

    <p><strong>StartNodeGeometry</strong> / <strong>EndNodeGeometry</strong> each contain a single <code>EdgeNodeGeometry</code> struct:</p>

    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Left</code></td><td><code>Segment</code></td><td>Left-side Bezier curve and length at the node junction</td></tr>
      <tr><td><code>m_Right</code></td><td><code>Segment</code></td><td>Right-side Bezier curve and length at the node junction</td></tr>
      <tr><td><code>m_Middle</code></td><td><code>Bezier4x3</code></td><td>Center-line Bezier curve at the node junction</td></tr>
    </table>

    <p><code>GeometrySystem</code> computes these for each edge. They are consumed by <code>LaneSystem</code> to generate accurate lane curves through intersections and by the rendering pipeline to draw smooth node geometry where multiple edges meet.</p>

    <h3>ConnectedNode</h3>
    <p>Buffer element on edges listing intermediate node connections (for split edges).</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Node</code></td><td><code>Entity</code></td><td>The connected node entity</td></tr>
      <tr><td><code>m_CurvePosition</code></td><td><code>float</code></td><td>Position along the edge curve (0-1)</td></tr>
    </table>

    <h3>Upgraded</h3>
    <p>Marks an edge that has been upgraded (added lanes, changed surface). Contains <code>CompositionFlags</code> describing the upgrade.</p>

    <!-- ============================================================ -->
    <h2>Data Flow</h2>

    <h3>Network Graph Structure</h3>

    <div class="diagram"><pre>Node (intersection)
  |-- DynamicBuffer&lt;ConnectedEdge&gt;  [capacity 4]
  |       |-- Edge entity A
  |       |-- Edge entity B
  |       |-- Edge entity C
  |       +-- Edge entity D
  |
  +-- NodeGeometry (bounds, flatness)

Edge (road segment)
  |-- Edge.m_Start  --&gt;  Node entity (start)
  |-- Edge.m_End    --&gt;  Node entity (end)
  |-- Curve              (Bezier4x3 shape)
  |-- Composition         (links to prefab compositions)
  |-- Elevation           (float2: start/end offsets)
  |-- EdgeGeometry        (left/right segments, bounds)
  |-- DynamicBuffer&lt;SubLane&gt;
  |       |-- Lane entity 1 (car lane)
  |       |-- Lane entity 2 (car lane)
  |       |-- Lane entity 3 (sidewalk)
  |       +-- Lane entity N (utility conduit)
  |
  +-- DynamicBuffer&lt;ConnectedNode&gt; (intermediate splits)

Lane (single traffic lane / sidewalk / utility)
  |-- Lane       (PathNode start/middle/end)
  |-- Curve      (Bezier4x3 shape)
  +-- PrefabRef  (lane prefab entity)</pre></div>

    <h3>Layer System</h3>

    <p>Each network type belongs to one or more <code>Layer</code> flags. This controls which networks can connect to each other:</p>

    <table>
      <tr><th>Layer</th><th>Value</th><th>Description</th></tr>
      <tr><td><code>Road</code></td><td>1</td><td>Standard roads</td></tr>
      <tr><td><code>TrainTrack</code></td><td>0x40</td><td>Railway tracks</td></tr>
      <tr><td><code>Pathway</code></td><td>0x80</td><td>Pedestrian paths</td></tr>
      <tr><td><code>TramTrack</code></td><td>0x400</td><td>Tram tracks</td></tr>
      <tr><td><code>SubwayTrack</code></td><td>0x800</td><td>Subway tracks</td></tr>
      <tr><td><code>PowerlineLow</code></td><td>2</td><td>Low-voltage power lines</td></tr>
      <tr><td><code>PowerlineHigh</code></td><td>4</td><td>High-voltage power lines</td></tr>
      <tr><td><code>WaterPipe</code></td><td>8</td><td>Water pipes</td></tr>
      <tr><td><code>SewagePipe</code></td><td>0x10</td><td>Sewage pipes</td></tr>
      <tr><td><code>Waterway</code></td><td>0x100</td><td>Ship waterways</td></tr>
      <tr><td><code>Fence</code></td><td>0x1000</td><td>Fences</td></tr>
    </table>

    <!-- ============================================================ -->
    <h2>Examples</h2>

    <h3>Read All Road Edges</h3>
    <p>Query all permanent edge entities and log their start/end positions and lengths.</p>

<pre><code class="language-csharp">public partial class NetworkReaderSystem : GameSystemBase
{
    private EntityQuery _edgeQuery;

    protected override void OnCreate()
    {
        base.OnCreate();
        _edgeQuery = GetEntityQuery(
            ComponentType.ReadOnly&lt;Edge&gt;(),
            ComponentType.ReadOnly&lt;Curve&gt;(),
            ComponentType.Exclude&lt;Deleted&gt;(),
            ComponentType.Exclude&lt;Temp&gt;()
        );
    }

    protected override void OnUpdate()
    {
        var edges = _edgeQuery.ToComponentDataArray&lt;Edge&gt;(Allocator.Temp);
        var curves = _edgeQuery.ToComponentDataArray&lt;Curve&gt;(Allocator.Temp);
        var entities = _edgeQuery.ToEntityArray(Allocator.Temp);

        try
        {
            for (int i = 0; i &lt; edges.Length; i++)
            {
                Edge edge = edges[i];
                Curve curve = curves[i];
                Node startNode = EntityManager.GetComponentData&lt;Node&gt;(edge.m_Start);
                Node endNode = EntityManager.GetComponentData&lt;Node&gt;(edge.m_End);

                Log.Info($"Edge {entities[i]}: " +
                    $"{startNode.m_Position} -&gt; {endNode.m_Position}, " +
                    $"length={curve.m_Length:F1}");
            }
        }
        finally
        {
            edges.Dispose();
            curves.Dispose();
            entities.Dispose();
        }
    }
}</code></pre>

    <h3>Find All Edges Connected to a Node</h3>
    <p>Walk the <code>ConnectedEdge</code> buffer on a node to enumerate its connections.</p>

<pre><code class="language-csharp">public void LogConnectedEdges(Entity nodeEntity)
{
    if (!EntityManager.TryGetBuffer&lt;ConnectedEdge&gt;(nodeEntity, true, out var edges))
        return;

    Node node = EntityManager.GetComponentData&lt;Node&gt;(nodeEntity);
    Log.Info($"Node at {node.m_Position} has {edges.Length} connected edges:");

    for (int i = 0; i &lt; edges.Length; i++)
    {
        Entity edgeEntity = edges[i].m_Edge;
        Curve curve = EntityManager.GetComponentData&lt;Curve&gt;(edgeEntity);
        Log.Info($"  Edge {edgeEntity}: length={curve.m_Length:F1}");
    }
}</code></pre>

    <h3>Query Lanes on a Road Segment</h3>
    <p>Walk the <code>SubLane</code> buffer on an edge to enumerate its lanes.</p>

<pre><code class="language-csharp">public void LogLanes(Entity edgeEntity)
{
    if (!EntityManager.TryGetBuffer&lt;SubLane&gt;(edgeEntity, true, out var subLanes))
        return;

    for (int i = 0; i &lt; subLanes.Length; i++)
    {
        Entity laneEntity = subLanes[i].m_SubLane;
        Curve curve = EntityManager.GetComponentData&lt;Curve&gt;(laneEntity);
        PrefabRef prefabRef = EntityManager.GetComponentData&lt;PrefabRef&gt;(laneEntity);
        Log.Info($"  Lane {i}: prefab={prefabRef.m_Prefab}, " +
            $"length={curve.m_Length:F1}");
    }
}</code></pre>

    <h3>Modify Road Elevation</h3>
    <p>Change the elevation of an existing road segment. Mark as <code>Updated</code> so geometry and lanes are recalculated.</p>

<pre><code class="language-csharp">public void SetEdgeElevation(Entity edgeEntity, float startElev, float endElev)
{
    var newElevation = new Elevation(new float2(startElev, endElev));

    if (EntityManager.HasComponent&lt;Elevation&gt;(edgeEntity))
        EntityManager.SetComponentData(edgeEntity, newElevation);
    else
        EntityManager.AddComponentData(edgeEntity, newElevation);

    // Mark as updated so GeometrySystem and LaneSystem recalculate
    if (!EntityManager.HasComponent&lt;Updated&gt;(edgeEntity))
        EntityManager.AddComponent&lt;Updated&gt;(edgeEntity);
}</code></pre>

    <h3>Check Road Composition Flags</h3>
    <p>Read composition data to determine if a road is elevated, has traffic lights, etc.</p>

<pre><code class="language-csharp">public bool IsElevated(Entity edgeEntity)
{
    Composition comp = EntityManager.GetComponentData&lt;Composition&gt;(edgeEntity);
    NetCompositionData compData =
        EntityManager.GetComponentData&lt;NetCompositionData&gt;(comp.m_Edge);
    return (compData.m_Flags.m_General &amp;
        CompositionFlags.General.Elevated) != 0;
}

public bool HasTrafficLights(Entity nodeEntity)
{
    if (!EntityManager.TryGetBuffer&lt;ConnectedEdge&gt;(
            nodeEntity, true, out var edges))
        return false;

    for (int i = 0; i &lt; edges.Length; i++)
    {
        Composition comp =
            EntityManager.GetComponentData&lt;Composition&gt;(edges[i].m_Edge);
        Edge edge =
            EntityManager.GetComponentData&lt;Edge&gt;(edges[i].m_Edge);

        Entity nodeComp = (edge.m_Start == nodeEntity)
            ? comp.m_StartNode : comp.m_EndNode;
        NetCompositionData compData =
            EntityManager.GetComponentData&lt;NetCompositionData&gt;(nodeComp);

        if ((compData.m_Flags.m_General &amp;
                CompositionFlags.General.TrafficLights) != 0)
            return true;
    }
    return false;
}</code></pre>

    <!-- ============================================================ -->
    <h2>Configuration</h2>

    <h3>CompositionFlags</h3>

    <p>Roads use <code>CompositionFlags</code> to describe their properties. This struct contains two flag enums:</p>

    <p><strong>General flags</strong> (apply to whole edge or node):</p>
    <table>
      <tr><th>Flag</th><th>Value</th><th>Meaning</th></tr>
      <tr><td><code>Elevated</code></td><td>0x10000</td><td>Road is elevated (bridge)</td></tr>
      <tr><td><code>Tunnel</code></td><td>0x20000</td><td>Road is in a tunnel</td></tr>
      <tr><td><code>Roundabout</code></td><td>0x40</td><td>Node is part of a roundabout</td></tr>
      <tr><td><code>TrafficLights</code></td><td>0x400</td><td>Node has traffic lights</td></tr>
      <tr><td><code>LevelCrossing</code></td><td>0x80</td><td>Railroad level crossing</td></tr>
      <tr><td><code>Crosswalk</code></td><td>0x100</td><td>Has crosswalk at node</td></tr>
      <tr><td><code>DeadEnd</code></td><td>0x10</td><td>Dead-end node</td></tr>
      <tr><td><code>Intersection</code></td><td>0x20</td><td>Multi-edge intersection</td></tr>
      <tr><td><code>Lighting</code></td><td>0x10000000</td><td>Has street lighting</td></tr>
      <tr><td><code>Pavement</code></td><td>0x2000000</td><td>Paved surface</td></tr>
      <tr><td><code>Gravel</code></td><td>0x4000000</td><td>Gravel surface</td></tr>
      <tr><td><code>Tiles</code></td><td>0x8000000</td><td>Tiled surface</td></tr>
    </table>

    <p><strong>Side flags</strong> (apply to left or right side of edge):</p>
    <table>
      <tr><th>Flag</th><th>Value</th><th>Meaning</th></tr>
      <tr><td><code>Sidewalk</code></td><td>0x10000</td><td>Has sidewalk</td></tr>
      <tr><td><code>WideSidewalk</code></td><td>0x20000</td><td>Wide sidewalk variant</td></tr>
      <tr><td><code>ParkingSpaces</code></td><td>0x40000</td><td>Has parking spaces</td></tr>
      <tr><td><code>SoundBarrier</code></td><td>0x80000</td><td>Sound barrier installed</td></tr>
      <tr><td><code>Raised</code></td><td>1</td><td>Raised edge (curb)</td></tr>
      <tr><td><code>Lowered</code></td><td>2</td><td>Lowered edge</td></tr>
      <tr><td><code>ForbidLeftTurn</code></td><td>0x1000000</td><td>Left turn forbidden</td></tr>
      <tr><td><code>ForbidRightTurn</code></td><td>0x2000000</td><td>Right turn forbidden</td></tr>
      <tr><td><code>ForbidStraight</code></td><td>0x10000000</td><td>Straight movement forbidden</td></tr>
    </table>

    <h3>NetToolSystem Properties</h3>

    <p>The tool exposes these configurable properties (useful for UI bindings or programmatic control):</p>

    <table>
      <tr><th>Property</th><th>Type</th><th>Default</th><th>Description</th></tr>
      <tr><td><code>mode</code></td><td><code>Mode</code></td><td>Straight</td><td>Drawing mode (Straight, SimpleCurve, etc.)</td></tr>
      <tr><td><code>elevation</code></td><td><code>float</code></td><td>0</td><td>Height offset from terrain</td></tr>
      <tr><td><code>elevationStep</code></td><td><code>float</code></td><td>10</td><td>Increment for elevation changes</td></tr>
      <tr><td><code>parallelCount</code></td><td><code>int</code></td><td>0</td><td>Number of parallel roads</td></tr>
      <tr><td><code>parallelOffset</code></td><td><code>float</code></td><td>8</td><td>Distance between parallel roads</td></tr>
      <tr><td><code>underground</code></td><td><code>bool</code></td><td>false</td><td>Whether building underground</td></tr>
    </table>

    <h3>CarLane (Prefab)</h3>
    <p>Prefab component on lane prefab entities defining car-specific lane behavior.</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_RoadTypes</code></td><td><code>RoadTypes</code></td><td>Which road types this lane supports (Car, Maintenance, etc.)</td></tr>
      <tr><td><code>m_SpeedLimit</code></td><td><code>float</code></td><td>Default speed limit in game units</td></tr>
      <tr><td><code>m_MaxSpeed</code></td><td><code>float</code></td><td>Maximum allowable speed on this lane</td></tr>
      <tr><td><code>m_SafeSpeed</code></td><td><code>float</code></td><td>Safe cruising speed for traffic safety calculations</td></tr>
      <tr><td><code>m_GasUsage</code></td><td><code>float</code></td><td>Fuel consumption rate multiplier for vehicles</td></tr>
    </table>

    <h3>TrackLane (Prefab)</h3>
    <p>Prefab component on lane prefab entities defining track-specific lane behavior (trains, trams, subways).</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_SpeedLimit</code></td><td><code>float</code></td><td>Default speed limit for track vehicles</td></tr>
      <tr><td><code>m_TrackTypes</code></td><td><code>TrackTypes</code></td><td>Which track types this lane supports (Train, Tram, Subway)</td></tr>
    </table>

    <h3>RoadData (Game.Prefabs)</h3>
    <p>Prefab component that defines road-specific properties. Present on road prefab entities (not tracks or pathways).</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_SpeedLimit</code></td><td><code>float</code></td><td>Speed limit in meters per second (convert: km/h = m/s * 3.6)</td></tr>
      <tr><td><code>m_Flags</code></td><td><code>RoadFlags</code></td><td>Road behavior flags</td></tr>
    </table>

    <h4>RoadFlags Enum</h4>
    <table>
      <tr><th>Flag</th><th>Description</th></tr>
      <tr><td><code>UseHighwayRules</code></td><td>Enables highway-specific behavior (no traffic lights, restricted turns, highway lane merging)</td></tr>
    </table>

    <p><strong>Road hierarchy classification pattern:</strong></p>
    <ul>
      <li><strong>Highway:</strong> <code>RoadFlags.UseHighwayRules</code> set, high speed limit</li>
      <li><strong>Arterial:</strong> High speed limit, multiple lanes, no highway flag</li>
      <li><strong>Collector:</strong> Medium speed limit, fewer lanes</li>
      <li><strong>Local:</strong> Low speed limit, typically 2 lanes</li>
    </ul>

    <p><strong>Lookup chain</strong> (edge entity to road speed limit):</p>
    <pre><code class="language-csharp">// From an edge entity, get the road's speed limit
Composition comp = EntityManager.GetComponentData&lt;Composition&gt;(edgeEntity);
PrefabRef compPrefabRef = EntityManager.GetComponentData&lt;PrefabRef&gt;(comp.m_Edge);
if (EntityManager.HasComponent&lt;RoadData&gt;(compPrefabRef.m_Prefab))
{
    RoadData roadData =
        EntityManager.GetComponentData&lt;RoadData&gt;(compPrefabRef.m_Prefab);
    float speedLimitKmh = roadData.m_SpeedLimit * 3.6f;
    bool isHighway = (roadData.m_Flags &amp; RoadFlags.UseHighwayRules) != 0;
}</code></pre>

    <h3>Managed Prefab Hierarchy</h3>

    <p>
      <code>NetGeometryPrefab</code> is the managed (MonoBehaviour-side) base class for all network
      geometry prefabs. It defines section composition and aggregate type. Subclasses specialize for
      each network category.
    </p>

    <h4>NetGeometryPrefab (abstract base)</h4>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Sections</code></td><td><code>NetSection[]</code></td><td>Array of section definitions composing this network</td></tr>
      <tr><td><code>m_AggregateType</code></td><td><code>AggregateNetPrefab</code></td><td>The aggregate prefab this network belongs to (e.g., Highway, Street)</td></tr>
      <tr><td><code>m_NodeSections</code></td><td><code>NetSection[]</code></td><td>Section definitions for node intersections</td></tr>
      <tr><td><code>m_EdgeStates</code></td><td><code>NetEdgeStateInfo[]</code></td><td>State-based edge section overrides</td></tr>
      <tr><td><code>m_NodeStates</code></td><td><code>NetNodeStateInfo[]</code></td><td>State-based node section overrides</td></tr>
      <tr><td><code>m_InvertMode</code></td><td><code>CompositionInvertMode</code></td><td>How lanes adapt to left/right-hand traffic</td></tr>
    </table>

    <h4>RoadPrefab (extends NetGeometryPrefab)</h4>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_SpeedLimit</code></td><td><code>float</code></td><td>Road speed limit in m/s</td></tr>
      <tr><td><code>m_RoadType</code></td><td><code>RoadType</code></td><td>Classification: Normal, Highway, PublicTransport</td></tr>
      <tr><td><code>m_TrafficLights</code></td><td><code>bool</code></td><td>Whether this road supports traffic lights</td></tr>
      <tr><td><code>m_HighwayRules</code></td><td><code>bool</code></td><td>Whether to apply highway-specific rules</td></tr>
      <tr><td><code>m_ZoneBlock</code></td><td><code>ZoneBlockPrefab</code></td><td>Zone block generation settings (null for non-zoned roads)</td></tr>
    </table>

    <h4>TrackPrefab (extends NetGeometryPrefab)</h4>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_SpeedLimit</code></td><td><code>float</code></td><td>Track speed limit in m/s</td></tr>
      <tr><td><code>m_TrackType</code></td><td><code>TrackType</code></td><td>Classification: Train, Tram, Subway</td></tr>
    </table>

    <h4>PathwayPrefab / FencePrefab (extends NetGeometryPrefab)</h4>
    <p>
      <code>PathwayPrefab</code> adds only <code>m_SpeedLimit</code> (float). <code>FencePrefab</code>
      has no additional fields beyond the base class.
    </p>

    <p>
      The managed prefab hierarchy is initialized at game load. <code>PrefabSystem</code> converts
      these into ECS components (<code>NetData</code>, <code>NetGeometryData</code>,
      <code>RoadData</code>, etc.) on the prefab entities. Mods typically interact with ECS components
      at runtime, but the managed prefabs are useful for understanding default values.
    </p>

    <h3>NetSectionPrefab / NetPieceInfo / NetPieceLanes</h3>

    <p>Network lane composition is defined through a multi-level hierarchy: sections contain pieces, and pieces contain lanes.</p>

    <h4>NetSectionPrefab</h4>
    <p>Defines a cross-section of a network (e.g., "4-lane road with median"):</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Pieces</code></td><td><code>NetPieceInfo[]</code></td><td>Array of piece definitions composing this section</td></tr>
      <tr><td><code>m_SubSections</code></td><td><code>NetSectionInfo[]</code></td><td>Sub-section overrides based on requirements</td></tr>
    </table>

    <h4>NetPieceInfo</h4>
    <p>A single piece within a section:</p>
    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Piece</code></td><td><code>NetPiecePrefab</code></td><td>The piece prefab reference</td></tr>
      <tr><td><code>m_RequireAll</code></td><td><code>NetPieceRequirements</code></td><td>All must be met</td></tr>
      <tr><td><code>m_RequireAny</code></td><td><code>NetPieceRequirements</code></td><td>At least one must be met</td></tr>
      <tr><td><code>m_RequireNone</code></td><td><code>NetPieceRequirements</code></td><td>None may be met</td></tr>
      <tr><td><code>m_Offset</code></td><td><code>float3</code></td><td>Position offset for this piece</td></tr>
    </table>

    <h4>NetPieceLanes</h4>
    <p>
      <code>NetPieceLanes</code> (ComponentBase on <code>NetPiecePrefab</code>) defines lanes within a
      piece. Contains an array of <code>NetPieceLane</code> entries specifying lane prefab, position
      offset, and flags. These are flattened into <code>NetCompositionLane</code> entries during prefab
      initialization.
    </p>

    <h4>NetPieceRequirements (Flags Enum)</h4>
    <table>
      <tr><th>Flag</th><th>Description</th></tr>
      <tr><td><code>Intersection</code></td><td>Piece applies at intersections</td></tr>
      <tr><td><code>DeadEnd</code></td><td>Piece applies at dead ends</td></tr>
      <tr><td><code>Roundabout</code></td><td>Piece applies in roundabouts</td></tr>
      <tr><td><code>Elevated</code></td><td>Piece applies on elevated segments</td></tr>
      <tr><td><code>Tunnel</code></td><td>Piece applies in tunnels</td></tr>
      <tr><td><code>Sidewalk</code></td><td>Piece applies when sidewalk is present</td></tr>
      <tr><td><code>Lighting</code></td><td>Piece applies when street lights are enabled</td></tr>
      <tr><td><code>LevelCrossing</code></td><td>Piece applies at level crossings</td></tr>
    </table>

    <p><strong>Composition pipeline:</strong> <code>NetGeometryPrefab.m_Sections</code> &rarr; <code>NetSectionPrefab.m_Pieces</code> &rarr; <code>NetPiecePrefab</code> + <code>NetPieceLanes</code> &rarr; flattened to <code>DynamicBuffer&lt;NetCompositionLane&gt;</code> on the composition prefab entity.</p>

    <h3>AggregateNetPrefab (Game.Prefabs)</h3>

    <p>
      Defines the aggregate type for a group of related network segments. Aggregates group contiguous
      edges that share the same network type for naming, statistics, and UI purposes.
    </p>

    <table>
      <tr><th>Aggregate Name</th><th>Network Types</th></tr>
      <tr><td>Highway</td><td>Highway roads</td></tr>
      <tr><td>Street</td><td>Standard city roads</td></tr>
      <tr><td>Alley</td><td>Narrow/alley roads</td></tr>
      <tr><td>Train Track</td><td>Railway lines</td></tr>
      <tr><td>Tram Track</td><td>Tram lines</td></tr>
      <tr><td>Subway Track</td><td>Underground rail</td></tr>
      <tr><td>Pathway</td><td>Pedestrian paths</td></tr>
      <tr><td>Public Transport Lane</td><td>Dedicated PT lanes</td></tr>
    </table>

    <p>
      <code>AggregateSystem</code> reads <code>m_AggregateType</code> from each edge's prefab and
      creates/merges <code>Aggregate</code> entities accordingly. Each <code>Aggregate</code> carries
      <code>DynamicBuffer&lt;AggregateElement&gt;</code> listing member edges, and each member edge
      has an <code>Aggregated</code> component pointing back to the aggregate.
    </p>

    <h3>CompositionInvertMode (Game.Prefabs)</h3>

    <p>
      Controls how lane ordering and direction are adjusted for left-hand vs. right-hand traffic.
      Applied to <code>NetCompositionLane</code> entries and <code>NetPieceLanes</code>.
    </p>

    <table>
      <tr><th>Value</th><th>Description</th></tr>
      <tr><td><code>InvertLefthandTraffic</code></td><td>Invert lane direction when <code>CityConfigurationSystem.leftHandTraffic</code> is true</td></tr>
      <tr><td><code>FlipLefthandTraffic</code></td><td>Flip (mirror) lane lateral position when left-hand traffic is active</td></tr>
      <tr><td><code>InvertRighthandTraffic</code></td><td>Invert lane direction when right-hand traffic is active</td></tr>
      <tr><td><code>FlipRighthandTraffic</code></td><td>Flip (mirror) lane lateral position when right-hand traffic is active</td></tr>
    </table>

    <p>
      <strong>Invert</strong> reverses the lane's travel direction (swaps start/end).
      <strong>Flip</strong> mirrors the lane's lateral position across the road centerline (negates
      the x offset).
    </p>

    <pre><code class="language-csharp">// Check if a lane needs direction inversion for current traffic setting
var cityConfig = World.GetOrCreateSystemManaged&lt;CityConfigurationSystem&gt;();
bool leftHand = cityConfig.leftHandTraffic;

bool shouldInvert = leftHand
    ? (invertMode &amp; CompositionInvertMode.InvertLefthandTraffic) != 0
    : (invertMode &amp; CompositionInvertMode.InvertRighthandTraffic) != 0;</code></pre>

    <h3>NetCompositionLane (Game.Prefabs)</h3>

    <p>Buffer on composition prefabs defining lane positions.</p>

    <table>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
      <tr><td><code>m_Lane</code></td><td><code>Entity</code></td><td>Lane prefab entity</td></tr>
      <tr><td><code>m_Position</code></td><td><code>float3</code></td><td>Offset position (x = lateral, y = vertical, z = longitudinal)</td></tr>
      <tr><td><code>m_Flags</code></td><td><code>LaneFlags</code></td><td>Lane behavior flags (Master, Slave, etc.)</td></tr>
      <tr><td><code>m_Carriageway</code></td><td><code>byte</code></td><td>Which carriageway (0 = left, 1 = right for RHT; reversed for LHT)</td></tr>
      <tr><td><code>m_Group</code></td><td><code>byte</code></td><td>Lane group index within the carriageway</td></tr>
      <tr><td><code>m_Index</code></td><td><code>byte</code></td><td>Lane index within group</td></tr>
      <tr><td><code>m_InvertMode</code></td><td><code>CompositionInvertMode</code></td><td>How this lane adapts to left/right-hand traffic</td></tr>
    </table>

    <h4>Stable Lane Identity via m_Carriageway + m_Group</h4>

    <p>
      The <code>m_Carriageway</code> and <code>m_Group</code> fields together form a stable lane
      identity key. Unlike entity references or buffer indices, which change when a road is upgraded,
      split, or modified, the carriageway+group pair remains consistent for the same logical lane across
      road modifications.
    </p>

    <p>
      This is critical for mods that need to persist lane-specific data (e.g., custom speed limits,
      lane restrictions) across road upgrades. When a road is upgraded, the edge entity may be replaced
      and lane entities are regenerated, but the <code>m_Carriageway</code>/<code>m_Group</code> values
      for unchanged lanes remain the same in the new composition.
    </p>

    <pre><code class="language-csharp">/// Serializable lane identity that survives road modifications.
/// Store this instead of Entity references for persistent lane data.
public struct LaneIdentity : IEquatable&lt;LaneIdentity&gt;
{
    public Entity EdgeEntity;       // Parent edge (may change on upgrade)
    public byte Carriageway;        // Stable: which side of the road
    public byte Group;              // Stable: lane group within carriageway
    public byte Index;              // Stable: lane index within group

    /// Find the runtime lane entity matching this identity on a given edge.
    public Entity Resolve(EntityManager em, Entity edgeEntity)
    {
        if (!em.TryGetBuffer&lt;SubLane&gt;(edgeEntity, true, out var subLanes))
            return Entity.Null;

        Composition comp = em.GetComponentData&lt;Composition&gt;(edgeEntity);
        if (!em.TryGetBuffer&lt;NetCompositionLane&gt;(
                comp.m_Edge, true, out var compLanes))
            return Entity.Null;

        for (int i = 0; i &lt; subLanes.Length &amp;&amp; i &lt; compLanes.Length; i++)
        {
            if (compLanes[i].m_Carriageway == Carriageway
                &amp;&amp; compLanes[i].m_Group == Group
                &amp;&amp; compLanes[i].m_Index == Index)
            {
                return subLanes[i].m_SubLane;
            }
        }
        return Entity.Null;
    }

    public bool Equals(LaneIdentity other) =&gt;
        Carriageway == other.Carriageway
        &amp;&amp; Group == other.Group &amp;&amp; Index == other.Index;
}</code></pre>

    <!-- ============================================================ -->
    <h2>Utility Methods</h2>

    <h3>NetUtils.FitCurve (Game.Net)</h3>

    <p>
      Static utility methods for generating <code>Bezier4x3</code> curves for network segments. Used
      by <code>GeometrySystem</code>, <code>LaneSystem</code>, and tool systems.
    </p>

    <p><strong>Overload 1 -- From Line3.Segment array:</strong></p>
    <pre><code class="language-csharp">public static Bezier4x3 FitCurve(Line3.Segment[] segments)</code></pre>
    <p>Fits a cubic Bezier through a sequence of line segments (e.g., terrain-following roads).</p>

    <p><strong>Overload 2 -- From start/end positions and tangents:</strong></p>
    <pre><code class="language-csharp">public static Bezier4x3 FitCurve(
    float3 startPos, float3 startTangent,
    float3 endPos, float3 endTangent)</code></pre>
    <p>
      Creates a cubic Bezier from explicit positions and tangent directions. Primary overload for
      generating edge curves from control points. Longer tangent vectors create wider curves.
    </p>

    <pre><code class="language-csharp">// Create a curve between two points with specified directions
float3 start = new float3(100, 0, 100);
float3 startDir = new float3(1, 0, 0);  // heading east
float3 end = new float3(200, 0, 200);
float3 endDir = new float3(1, 0, 0);    // also heading east
Bezier4x3 curve = NetUtils.FitCurve(start, startDir, end, endDir);</code></pre>

    <h3>MathUtils Bezier Operations (Colossal.Mathematics)</h3>

    <p>
      Static utility methods for working with <code>Bezier4x3</code> curves. Essential for any mod
      that reads or manipulates network geometry.
    </p>

    <ul>
      <li><code>MathUtils.Position(Bezier4x3, float t)</code> -- evaluates the curve at parameter t (0-1), returning the world-space <code>float3</code> position</li>
      <li><code>MathUtils.Tangent(Bezier4x3, float t)</code> -- returns the tangent direction vector at parameter t (useful for orienting objects along a road)</li>
      <li><code>MathUtils.Length(Bezier4x3)</code> -- computes the approximate arc length of the curve</li>
    </ul>

    <pre><code class="language-csharp">// Sample positions along a road curve
Curve curve = EntityManager.GetComponentData&lt;Curve&gt;(edgeEntity);
for (float t = 0f; t &lt;= 1f; t += 0.1f)
{
    float3 position = MathUtils.Position(curve.m_Bezier, t);
    float3 tangent = MathUtils.Tangent(curve.m_Bezier, t);
    float3 forward = math.normalize(tangent);
    Log.Info($"t={t:F1}: pos={position}, forward={forward}");
}
float totalLength = MathUtils.Length(curve.m_Bezier);</code></pre>

    <!-- ============================================================ -->
    <h2>Patch Points</h2>

    <h3>Recommended: ECS Queries (No Patches Needed)</h3>
    <p>For reading and modifying network data, standard ECS queries are sufficient. All network components (<code>Edge</code>, <code>Node</code>, <code>Curve</code>, <code>Lane</code>, etc.) are regular <code>IComponentData</code> and <code>IBufferElementData</code>. After modifying geometry, add <code>Updated</code> to trigger recalculation by <code>GeometrySystem</code> and <code>LaneSystem</code>.</p>

    <h3>Harmony: NetToolSystem.OnUpdate()</h3>
    <p>Intercept tool actions during road placement:</p>
    <ul>
      <li><strong>Prefix</strong> -- block or redirect road placement actions</li>
      <li><strong>Postfix</strong> -- add custom behavior after tool updates (e.g., custom snap logic)</li>
    </ul>
    <p>Risk: Central to <em>all</em> network building. Breaking this disables road, rail, pipe, and power line tools entirely.</p>

    <h3>Harmony: ApplyNetSystem.OnUpdate()</h3>
    <p>Intercept road creation at the moment of confirmation:</p>
    <ul>
      <li><strong>Prefix</strong> -- prevent certain placements from being applied</li>
      <li><strong>Postfix</strong> -- add components or modify newly created entities</li>
    </ul>
    <p>This runs only when the user confirms, making it ideal for post-creation modifications.</p>

    <h3>Harmony: LaneSystem.OnUpdate()</h3>
    <p>Modify lane generation:</p>
    <ul>
      <li><strong>Prefix/Postfix</strong> -- change lane layout, add custom lanes, modify properties</li>
    </ul>
    <p>Risk: Affects pathfinding and traffic for all roads.</p>

    <h3>Direct Component Manipulation</h3>
    <p>You can modify network entities directly via <code>EntityManager</code>. After changes, mark the entity as <code>Updated</code> so dependent systems recalculate:</p>

<pre><code class="language-csharp">EntityManager.SetComponentData(edgeEntity, new Curve { m_Bezier = newBezier });
EntityManager.AddComponent&lt;Updated&gt;(edgeEntity);</code></pre>

    <!-- ============================================================ -->
    <h2>Lane Hierarchy Components</h2>

    <table>
      <thead><tr><th>Component</th><th>Key Fields</th><th>Purpose</th></tr></thead>
      <tbody>
        <tr><td><code>MasterLane</code></td><td><code>m_Group</code> (int)</td><td>Defines lane group leader</td></tr>
        <tr><td><code>SlaveLane</code></td><td><code>m_Group</code>, <code>m_MinIndex</code>, <code>m_MaxIndex</code></td><td>Parallel lanes in the group</td></tr>
        <tr><td><code>EdgeLane</code></td><td><code>m_Edge</code> (Entity), <code>m_EdgeDelta</code> (float2)</td><td>Links lane to parent edge</td></tr>
      </tbody>
    </table>

    <h2>NetSubObjects &amp; PlaceableNet</h2>

    <p>
      <code>NetSubObjects</code> (ComponentBase) attaches objects to network prefabs.
      <code>NetSubObjectInfo</code> fields: <code>m_Object</code>, <code>m_Position</code>,
      <code>m_Rotation</code>, <code>m_Placement</code> (NetObjectPlacement), <code>m_RequireElevated</code>,
      <code>m_RequireOutsideConnection</code>.
    </p>

    <p>
      <code>PlaceableNet</code> (ComponentBase) controls placement tool behavior:
      <code>m_AllowParallelMode</code> (bool), <code>m_XPReward</code> (int),
      <code>m_ElevationRange</code> (Bounds1 with min/max in meters).
    </p>

    <h2>CityConfigurationSystem</h2>

    <pre><code class="language-csharp">var cityConfig = World.GetOrCreateSystemManaged&lt;CityConfigurationSystem&gt;();
bool leftHandTraffic = cityConfig.leftHandTraffic; // UK/Japan style
// Theme detection for lane divider colors:
prefabSystem.TryGetSpecificPrefab&lt;ThemePrefab&gt;(cityConfig.defaultTheme, out var theme);
bool yellowDivider = theme.assetPrefix is not "EU";</code></pre>

    <h2>Temp Entity Lifecycle</h2>

    <ol>
      <li><strong>ToolUpdate</strong>: Tool creates <code>CreationDefinition</code> / <code>ConnectionDefinition</code></li>
      <li><strong>Modification</strong>: <code>GenerateEdgesSystem</code> creates <code>Temp</code> entities</li>
      <li><strong>ApplyTool</strong>: <code>ApplyNetSystem</code> promotes Temp to permanent (or discards on cancel)</li>
      <li><strong>ClearTool</strong>: Cleanup of remaining Temp state</li>
    </ol>

    <p><code>TempFlags</code>: Delete, Replace, Combine, Cancel. Custom apply systems register before <code>ApplyNetSystem</code>.</p>

    <!-- ============================================================ -->
    <h2>Open Questions</h2>

    <ul>
      <li>How does <code>NetToolSystem</code> handle Grid mode internally? The grid generation from 3 control points was not fully traced.</li>
      <li><strong>[Answered]</strong> Temp entity lifecycle documented above: ToolUpdate &rarr; Modification &rarr; ApplyTool &rarr; ClearTool.</li>
      <li>How does edge splitting work when a new node is placed on an existing edge mid-segment? The split logic in <code>GenerateEdgesSystem</code> is complex.</li>
      <li><strong>Resolved:</strong> <code>Aggregate</code> entities group contiguous edges sharing the same network prefab. <code>AggregateSystem</code> merges edges into aggregates when they share a node and have the same prefab, and splits them when edges are deleted or change type. Each edge has an <code>Aggregated</code> component referencing its parent aggregate. Aggregates carry a <code>DynamicBuffer&lt;AggregateElement&gt;</code> listing member edges. Used by the naming system (road name labels span the aggregate), by the Traffic mod for road-level statistics, and by the UI for aggregate-level info such as total road length.</li>
      <li>How do parallel roads (from <code>parallelCount</code>) interact with the generation pipeline?</li>
    </ul>

    <footer>
      <p>Source: Decompiled from Game.dll (Cities: Skylines II) using ilspycmd v9.1. Game version as of 2026-02-15.</p>
      <div class="attribution-footer">
        <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
      </div>
    </footer>
    </main>

  </div>
</body>
</html>
