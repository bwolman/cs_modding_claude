<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mod Loading &amp; Dependencies</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="top-bar">
  <a href="index.html" class="site-title">CS2 Modding Research</a>
  <span class="attribution">Generated with Claude | Supervised by repository owner</span>
</div>

<div class="page-layout">

    <aside class="sidebar">
    <h3>Events &amp; Simulation</h3>
    <a href="event-entity-archetype.html">Event Entity Archetype</a>
    <a href="fire-ignition.html">Fire Ignition</a>
    <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
    <a href="crime-trigger.html">Crime Trigger</a>
    <a href="citizen-sickness.html">Citizen Sickness</a>
    <a href="water-system.html">Water System</a>
    <a href="emergency-dispatch.html">Emergency Dispatch</a>
    <a href="disaster-simulation.html">Disaster Simulation</a>

    <h3>Infrastructure</h3>
    <a href="electricity-grid.html">Electricity Grid</a>
    <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
    <a href="road-network.html">Road &amp; Network Building</a>
    <a href="zoning.html">Zoning</a>
    <a href="pathfinding.html">Pathfinding</a>
    <a href="traffic-flow.html">Traffic Flow</a>

    <h3>Economy &amp; Population</h3>
    <a href="citizens-households.html">Citizens &amp; Households</a>
    <a href="economy-budget.html">Economy &amp; Budget</a>
    <a href="demand-systems.html">Demand Systems</a>
    <a href="resource-production.html">Resource Production</a>
    <a href="company-simulation.html">Company Simulation</a>
    <a href="workplace-labor.html">Workplace &amp; Labor</a>
    <a href="land-value-property.html">Land Value &amp; Property</a>
    <a href="trade-connections.html">Trade &amp; Connections</a>
    <a href="tourism-economy.html">Tourism Economy</a>
    <a href="cargo-transport.html">Cargo Transport</a>

    <h3>City Services</h3>
    <a href="garbage-collection.html">Garbage Collection</a>
    <a href="education.html">Education</a>
    <a href="public-transit.html">Public Transit</a>
    <a href="healthcare.html">Healthcare</a>
    <a href="deathcare.html">Deathcare</a>
    <a href="parks-recreation.html">Parks &amp; Recreation</a>
    <a href="police-dispatch.html">Police Dispatch</a>

    <h3>Governance</h3>
    <a href="districts-policies.html">Districts &amp; Policies</a>
    <a href="map-tile-purchase.html">Map Tile Purchase</a>

    <h3>Environment</h3>
    <a href="weather-climate.html">Weather &amp; Climate</a>
    <a href="pollution.html">Pollution</a>
    <a href="terrain-resources.html">Terrain &amp; Resources</a>

    <h3>Vehicles &amp; Transport</h3>
    <a href="vehicle-spawning.html">Vehicle Spawning</a>

    <h3>Tools &amp; Input</h3>
    <a href="tool-activation.html">Tool Activation</a>
    <a href="tool-raycast.html">Tool Raycast</a>
    <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
    <a href="mod-hotkey-input.html">Mod Hotkey Input</a>
    <a href="object-tool-system.html">Object Placement Tool</a>

    <h3>UI &amp; Settings</h3>
    <a href="mod-ui-buttons.html">Mod UI Buttons</a>
    <a href="mod-options-ui.html">Mod Options UI</a>
    <a href="info-views-overlays.html">Info Views &amp; Overlays</a>
    <a href="chirper-notifications.html">Chirper Notifications</a>

    <h3>Modding Framework</h3>
    <a href="save-load-persistence.html">Save/Load Persistence</a>
    <a href="prefab-system.html">Prefab System</a>
    <a href="localization.html">Localization</a>
    <a href="harmony-transpilers.html">Harmony Transpilers</a>
    <a href="mod-loading-dependencies.html" class="active">Mod Loading</a>
  </aside>

  <main class="content">

  <h1>Mod Loading &amp; Dependencies</h1>

  <div class="scope">
    <h2>Scope</h2>
    <p>
      <strong>Question:</strong> How does CS2 discover, load, and initialize mods? What is the
      IMod lifecycle, how are dependencies resolved, and how do mods register their systems?
    </p>
    <p>
      <strong>Verdict:</strong> CS2 uses a <strong>ModManager</strong> class that scans the
      AssetDatabase for <code>ExecutableAsset</code> entries (mod DLLs). Each DLL is checked for
      <code>IMod</code> implementations. Dependencies are resolved via standard .NET assembly
      references -- if a reference cannot be found, the mod fails with
      <code>MissedDependenciesError</code>. On successful load, the mod's <code>OnLoad</code>
      method receives an <code>UpdateSystem</code> for registering custom ECS systems into
      specific update phases.
    </p>
    <p>
      <strong>Out of scope:</strong> Mod settings UI (see Mod Options UI), Harmony patching
      mechanics (see Harmony Transpilers).
    </p>
  </div>

  <!-- ============================================================ -->
  <h2>How It Works</h2>

  <h3>The IMod Interface</h3>

  <p>Every CS2 code mod must implement this interface:</p>

  <pre><code class="language-csharp">public interface IMod
{
    void OnLoad(UpdateSystem updateSystem);
    void OnDispose();
}</code></pre>

  <ul>
    <li><strong>OnLoad</strong> -- called once during game initialization. Use it to register
    systems, apply Harmony patches, and set up settings.</li>
    <li><strong>OnDispose</strong> -- called on game exit or mod disable. Clean up Harmony
    patches, unregister settings, release resources.</li>
  </ul>

  <h3>Loading Pipeline</h3>

  <p>The <code>ModManager</code> runs four phases during <code>Initialize()</code>:</p>

  <ol>
    <li><strong>RegisterMods</strong> -- scans <code>AssetDatabase.global</code> for
    <code>ExecutableAsset</code> entries. Each mod DLL gets a <code>ModInfo</code> object.</li>
    <li><strong>ResolveModAssets</strong> -- resolves assembly dependencies between mods using
    Cecil. Checks each reference against known assemblies. Mods with unresolvable references
    are marked <code>canBeLoaded = false</code>.</li>
    <li><strong>InitializeMods</strong> -- for each valid mod:
      <ul>
        <li>Loads the assembly via <code>ExecutableAsset.LoadAssembly()</code></li>
        <li>Calls <code>TypeManager.InitializeAdditionalTypes(assembly)</code> to register
        ECS types</li>
        <li>Finds all <code>IMod</code> implementations via reflection</li>
        <li>Creates instances and calls <code>OnLoad(updateSystem)</code></li>
      </ul>
    </li>
    <li><strong>InitializeUIModules</strong> -- registers UI module assets (HTML/JS mods
    that extend the game UI).</li>
  </ol>

  <h3>Mod States</h3>

  <table>
    <thead>
      <tr><th>State</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>Unknown</td><td>Initial state, not yet processed</td></tr>
      <tr><td>Loaded</td><td>Successfully loaded and OnLoad called</td></tr>
      <tr><td>Disposed</td><td>OnDispose called, cleaned up</td></tr>
      <tr><td>IsNotModWarning</td><td>DLL has no IMod implementation</td></tr>
      <tr><td>IsNotUniqueWarning</td><td>Duplicate mod detected</td></tr>
      <tr><td>MissedDependenciesError</td><td>Required assembly references missing</td></tr>
      <tr><td>LoadAssemblyError</td><td>Failed to load the mod DLL</td></tr>
      <tr><td>LoadAssemblyReferenceError</td><td>Failed to load a referenced DLL</td></tr>
      <tr><td>GeneralError</td><td>Other error during loading</td></tr>
    </tbody>
  </table>

  <h3>System Registration via UpdateSystem</h3>

  <p>
    The <code>UpdateSystem</code> passed to <code>OnLoad</code> provides methods to register
    custom systems into the game's update loop:
  </p>

  <table>
    <thead>
      <tr><th>Method</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td><code>UpdateAt&lt;T&gt;(phase)</code></td><td>Register system at a specific update phase</td></tr>
      <tr><td><code>UpdateBefore&lt;T&gt;(phase)</code></td><td>Register to update before others in the phase</td></tr>
      <tr><td><code>UpdateAfter&lt;T&gt;(phase)</code></td><td>Register to update after others in the phase</td></tr>
      <tr><td><code>UpdateBefore&lt;T, Other&gt;(phase)</code></td><td>Register before a specific other system</td></tr>
      <tr><td><code>UpdateAfter&lt;T, Other&gt;(phase)</code></td><td>Register after a specific other system</td></tr>
    </tbody>
  </table>

  <h3>Key Update Phases</h3>

  <table>
    <thead>
      <tr><th>Phase</th><th>When it Runs</th><th>Use For</th></tr>
    </thead>
    <tbody>
      <tr><td>Modification1-5</td><td>Sequential modification passes</td><td>Entity modification systems</td></tr>
      <tr><td>Modification4B</td><td>Extended fourth pass</td><td>Post-Modification4 processing</td></tr>
      <tr><td>ModificationEnd</td><td>Final modification cleanup</td><td>End-of-modification cleanup</td></tr>
      <tr><td>PreSimulation</td><td>Before simulation tick</td><td>Pre-processing, data preparation</td></tr>
      <tr><td>GameSimulation</td><td>Main simulation tick</td><td>Core mod logic, ECS systems</td></tr>
      <tr><td>PostSimulation</td><td>After simulation tick</td><td>Post-processing, cleanup</td></tr>
      <tr><td>Rendering</td><td>Render frame</td><td>Custom rendering overlays</td></tr>
      <tr><td>Raycast</td><td>Raycast processing</td><td>Custom raycast systems</td></tr>
      <tr><td>PreTool / ToolUpdate / PostTool</td><td>Tool lifecycle phases</td><td>Custom tools</td></tr>
      <tr><td>ApplyTool / ClearTool</td><td>Tool result phases</td><td>Tool result application, state cleanup</td></tr>
      <tr><td>UIUpdate / UITooltip</td><td>UI data refresh</td><td>UI bindings, panel data, tooltips</td></tr>
      <tr><td>PrefabUpdate</td><td>Prefab system update</td><td>Prefab modifications</td></tr>
      <tr><td>Serialize / Deserialize</td><td>Save/load phases</td><td>Custom serialization, cleanup systems</td></tr>
      <tr><td>DebugGizmos</td><td>Debug visualization</td><td>Debug rendering overlays</td></tr>
    </tbody>
  </table>

  <h3>Type-Constrained System Ordering</h3>

  <p>
    The two-type-parameter variants <code>UpdateBefore&lt;T, TOther&gt;</code> and
    <code>UpdateAfter&lt;T, TOther&gt;</code> order your system relative to a specific vanilla
    system. Both must be in the same phase:
  </p>

  <pre><code class="language-csharp">// CustomLaneSystem runs before LaneSystem within Modification4
updateSystem.UpdateBefore&lt;CustomLaneSystem, Game.Net.LaneSystem&gt;(
    SystemUpdatePhase.Modification4);

// CustomOverlaySystem runs after OverlayRenderSystem within Rendering
updateSystem.UpdateAfter&lt;CustomOverlaySystem, Game.Rendering.OverlayRenderSystem&gt;(
    SystemUpdatePhase.Rendering);</code></pre>

  <!-- ============================================================ -->
  <h2>Data Flow</h2>

  <div class="diagram">
<pre>
GAME STARTUP
  GameManager creates ModManager(disabled: false)
        |
        v
  ModManager.Initialize(updateSystem)
        |
        v
  PHASE 1: RegisterMods()
    AssetDatabase scans for ExecutableAsset entries
    Each mod DLL -&gt; ModInfo { asset, state: Unknown }
        |
        v
  PHASE 2: ExecutableAsset.ResolveModAssets(typeof(IMod), assets)
    For each mod:
      Read assembly references via Cecil
      Resolve against game assemblies + other mods
      Set canBeLoaded = false if missing deps
        |
        v
  PHASE 3: InitializeMods(updateSystem)
    For each ModInfo where state == Unknown &amp;&amp; isRequired:
      Check: isMod? isUnique? canBeLoaded?
      LoadAssembly() -&gt; TypeManager.InitializeAdditionalTypes()
      reflection: assembly.GetTypesDerivedFrom&lt;IMod&gt;()
      For each IMod type:
        Create instance (FormatterServices)
        Call instance.OnLoad(updateSystem)
      State -&gt; Loaded
        |
        v
  PHASE 4: InitializeUIModules()
    Scan UIModuleAsset entries
    Register UI host locations
        |
        v
  MOD IS ACTIVE (systems run in registered phases)
        |
        v
  GAME SHUTDOWN: ModManager.Dispose()
    For each ModInfo: call OnDispose(), State -&gt; Disposed
</pre>
  </div>

  <!-- ============================================================ -->
  <h2>Examples</h2>

  <h3>Basic Mod Entry Point</h3>

  <p>Minimal IMod that registers one custom system.</p>

  <pre><code class="language-csharp">using Game;
using Game.Modding;
using Colossal.Logging;

public class MyMod : IMod
{
    internal static ILog Log = LogManager.GetLogger(nameof(MyMod))
        .SetShowsErrorsInUI(true);

    public void OnLoad(UpdateSystem updateSystem)
    {
        Log.Info("MyMod loaded");
        updateSystem.UpdateAt&lt;MyCustomSystem&gt;(
            SystemUpdatePhase.GameSimulation);
    }

    public void OnDispose()
    {
        Log.Info("MyMod disposed");
    }
}</code></pre>

  <h3>Mod with Harmony Patches</h3>

  <p>Apply and clean up Harmony patches properly.</p>

  <pre><code class="language-csharp">using Game;
using Game.Modding;
using HarmonyLib;

public class MyHarmonyMod : IMod
{
    private Harmony _harmony;

    public void OnLoad(UpdateSystem updateSystem)
    {
        _harmony = new Harmony("com.myname.mymod");
        _harmony.PatchAll(typeof(MyHarmonyMod).Assembly);

        updateSystem.UpdateAt&lt;MySystem&gt;(
            SystemUpdatePhase.GameSimulation);
    }

    public void OnDispose()
    {
        _harmony?.UnpatchAll("com.myname.mymod");
    }
}</code></pre>

  <h3>System Registration with Explicit Ordering</h3>

  <p>Register multiple systems with dependencies on game systems.</p>

  <pre><code class="language-csharp">public class MyMod : IMod
{
    public void OnLoad(UpdateSystem updateSystem)
    {
        // Run before simulation
        updateSystem.UpdateAt&lt;PreProcessSystem&gt;(
            SystemUpdatePhase.PreSimulation);

        // Run during simulation, after a specific game system
        updateSystem.UpdateAfter&lt;MySimSystem,
            Game.Simulation.StorageCompanySystem&gt;(
            SystemUpdatePhase.GameSimulation);

        // Run during UI update
        updateSystem.UpdateAt&lt;MyUISystem&gt;(
            SystemUpdatePhase.UIUpdate);
    }

    public void OnDispose() { }
}</code></pre>

  <h3>Mod with Settings</h3>

  <p>Register settings visible in the game's options menu.</p>

  <pre><code class="language-csharp">public class MyMod : IMod
{
    private MyModSettings _settings;

    public void OnLoad(UpdateSystem updateSystem)
    {
        _settings = new MyModSettings(this);
        _settings.RegisterInOptionsUI();

        GameManager.instance.localizationManager.AddSource(
            "en-US", new MyModLocale());
    }

    public void OnDispose()
    {
        _settings?.UnregisterInOptionsUI();
    }
}

public class MyModSettings : ModSetting
{
    [SettingsUISection("General")]
    public bool EnableFeature { get; set; } = true;

    [SettingsUISection("General")]
    [SettingsUISlider(min = 0.1f, max = 5.0f, step = 0.1f)]
    public float Multiplier { get; set; } = 1.0f;

    public MyModSettings(IMod mod) : base(mod) { }
}</code></pre>

  <h3>Access Mod Asset Information</h3>

  <p>Find the mod's installation path and metadata at runtime.</p>

  <pre><code class="language-csharp">public class MyMod : IMod
{
    public void OnLoad(UpdateSystem updateSystem)
    {
        var modManager = GameManager.instance.modManager;
        if (modManager.TryGetExecutableAsset(this, out var asset))
        {
            Log.Info($"Mod name: {asset.fullName}");
            Log.Info($"Mod path: {asset.path}");
            Log.Info($"Is local: {asset.isLocal}");

            string modDir = Path.GetDirectoryName(asset.path);
            string configPath = Path.Combine(modDir, "config.json");
        }
    }

    public void OnDispose() { }
}</code></pre>

  <h3>Find Mod Assembly Path via SearchFilter (Alternative)</h3>

  <p>
    An alternative to <code>TryGetExecutableAsset</code> for finding the mod's assembly path. Uses
    <code>SearchFilter&lt;ExecutableAsset&gt;</code> to query the asset database directly. This is
    useful when you don't have a reference to the <code>ModManager</code> or need to search for
    other mods' assets.
  </p>

  <pre><code class="language-csharp">using Colossal.IO.AssetDatabase;
using Game;
using Game.Modding;

public class MyMod : IMod
{
    public void OnLoad(UpdateSystem updateSystem)
    {
        // SearchFilter&lt;ExecutableAsset&gt; queries the AssetDatabase for
        // mod DLLs. Each result is an ExecutableAsset with path, name,
        // and metadata.
        foreach (var asset in AssetDatabase.global.GetAsset&lt;ExecutableAsset&gt;(
            SearchFilter&lt;ExecutableAsset&gt;.ByCondition(
                a =&gt; a.isLoaded &amp;&amp; a.isMod)))
        {
            if (asset.assembly == typeof(MyMod).Assembly)
            {
                string modPath = asset.path;
                string modDir = System.IO.Path.GetDirectoryName(modPath);
                Log.Info($"Mod directory: {modDir}");
                break;
            }
        }
    }

    public void OnDispose() { }
}</code></pre>

  <p><strong>When to use which approach:</strong></p>

  <ul>
    <li><strong><code>TryGetExecutableAsset</code></strong> -- simplest way to find your own mod's
    asset. Requires access to <code>GameManager.instance.modManager</code> and passes <code>this</code>
    (the IMod instance).</li>
    <li><strong><code>SearchFilter&lt;ExecutableAsset&gt;</code></strong> -- more flexible. Can search
    for any mod's assets by arbitrary conditions. Useful for inter-mod discovery or enumerating all
    loaded mods.</li>
  </ul>

  <!-- ============================================================ -->
  <h2>System Replacement Pattern</h2>

  <p>
    A common community modding pattern is to replace vanilla ECS systems entirely with custom
    implementations. This is more reliable than Harmony-patching complex systems with Burst-compiled
    jobs, since the jobs themselves cannot be patched.
  </p>

  <h3>Disabling Vanilla Systems</h3>

  <p>
    Any <code>GameSystemBase</code> can be disabled by setting <code>.Enabled = false</code>. The
    update loop skips disabled systems. Do this in <code>IMod.OnLoad()</code>:
  </p>

  <pre><code class="language-csharp">public void OnLoad(UpdateSystem updateSystem)
{
    // Disable the vanilla system
    var vanillaSystem = World.DefaultGameObjectInjectionWorld
        .GetOrCreateSystemManaged&lt;Game.Simulation.ResidentialDemandSystem&gt;();
    vanillaSystem.Enabled = false;

    // Register your replacement in the same phase
    updateSystem.UpdateAt&lt;CustomResidentialDemandSystem&gt;(
        SystemUpdatePhase.GameSimulation);
}</code></pre>

  <p>
    The replacement system should implement the same public interface (properties, methods)
    that other systems depend on. For example, replacing <code>ResidentialDemandSystem</code>
    means your replacement must expose <code>householdDemand</code>, <code>buildingDemand</code>,
    and <code>GetLowDensityDemandFactors()</code> because <code>ZoneSpawnSystem</code> and
    UI systems read these.
  </p>

  <h3>Inter-Mod Detection</h3>

  <p>
    When multiple mods might replace the same system, detect each other to avoid conflicts:
  </p>

  <pre><code class="language-csharp">// Check if system is already disabled by another mod
var vanillaSystem = World.DefaultGameObjectInjectionWorld
    .GetOrCreateSystemManaged&lt;Game.Simulation.SomeSystem&gt;();
if (vanillaSystem.Enabled)
{
    vanillaSystem.Enabled = false;
    // Register replacement
}
else
{
    Log.Warn("SomeSystem already disabled by another mod");
}

// Or check for another mod's assembly
bool otherModLoaded = AppDomain.CurrentDomain.GetAssemblies()
    .Any(a =&gt; a.GetName().Name == "OtherModAssembly");</code></pre>

  <h3>Caveats</h3>

  <ul>
    <li>The disabled system's <code>OnCreate</code> still ran (it was created before your mod loaded). Only <code>OnUpdate</code> is skipped.</li>
    <li>If the vanilla system implements <code>IDefaultSerializable</code>/<code>ISerializable</code>, disabling it does NOT disable serialization. The serialization libraries call those methods directly, bypassing <code>Enabled</code>.</li>
    <li>Burst-compiled jobs inside the vanilla system are not affected -- they simply never get scheduled because <code>OnUpdate</code> is skipped.</li>
  </ul>

  <h3>No-Harmony Architecture</h3>

  <p>
    Some of the most complex CS2 mods use <strong>zero Harmony patches</strong>, achieving all
    functionality through pure ECS patterns. The Traffic mod (krzychu124) demonstrates this at scale
    with a complete lane system replacement, custom tools, custom rendering, and custom serializable
    components.
  </p>

  <table>
    <thead>
      <tr><th>Aspect</th><th>Pure ECS</th><th>Harmony Patching</th></tr>
    </thead>
    <tbody>
      <tr><td>Mod conflicts</td><td>Minimal (each mod owns its systems)</td><td>High (multiple mods patch same method)</td></tr>
      <tr><td>Game update resilience</td><td>Medium (system interfaces may change)</td><td>Low (method signatures change frequently)</td></tr>
      <tr><td>Burst compatibility</td><td>Full (can use Burst-compiled jobs)</td><td>None (Harmony cannot patch Burst jobs)</td></tr>
      <tr><td>Code complexity</td><td>Higher (must reimplement full systems)</td><td>Lower (small targeted patches)</td></tr>
      <tr><td>Debugging</td><td>Standard C# debugging</td><td>Complex (injected IL hard to trace)</td></tr>
    </tbody>
  </table>

  <p>
    <strong>When to use pure ECS</strong>: Complex mods modifying core simulation logic (traffic,
    pathfinding, demand), mods needing Burst performance, or mods where entire system behavior
    changes. <strong>When to use Harmony</strong>: Small targeted tweaks, UI modifications, or
    intercepting specific calls without reimplementing the full system.
  </p>

  <!-- ============================================================ -->
  <h2>Configuration</h2>

  <h3>Dependency Declaration</h3>

  <p>
    Dependencies are declared through standard .NET assembly references in your
    <code>.csproj</code> file. At load time, <code>ExecutableAsset.ResolveModAssets()</code>
    uses Cecil to read your assembly's references and attempts to resolve them against:
  </p>

  <ol>
    <li>Game assemblies (Game.dll, Unity assemblies, etc.)</li>
    <li>Other mod assemblies registered in AssetDatabase</li>
    <li>Assemblies in the current AppDomain search directories</li>
  </ol>

  <p>If any reference cannot be resolved, the mod is marked with
  <code>MissedDependenciesError</code> and will not load.</p>

  <h3>Mod Settings Storage</h3>

  <p>
    <code>ModSetting</code> instances are stored in
    <code>{EnvPath.kUserDataPath}/ModsSettings/</code>. The setting ID is generated as
    <code>{AssemblyName}.{Namespace}.{ClassName}</code>.
  </p>

  <!-- ============================================================ -->
  <h2>Cross-Mod Detection Patterns</h2>

  <h3>ModManager Iteration</h3>

  <p>Simple mod presence detection by iterating <code>GameManager.instance.modManager</code>:</p>

  <pre><code class="language-csharp">foreach (ModManager.ModInfo modInfo in GameManager.instance.modManager)
{
    if (modInfo.asset.name.Equals("RWH"))
    {
        Log.Info("Found Realistic Workplaces and Households mod");
    }
}</code></pre>

  <h3>ListModsEnabled</h3>

  <p>
    Returns assembly-qualified names of enabled mods. Use <code>StartsWith</code> for matching
    and cache results with nullable backing fields:
  </p>

  <pre><code class="language-csharp">private static bool? isRoadBuilderEnabled;
public static bool IsRoadBuilderEnabled =&gt; isRoadBuilderEnabled ??=
    GameManager.instance.modManager.ListModsEnabled()
        .Any(x =&gt; x.StartsWith("RoadBuilder, "));</code></pre>

  <h3>Enabled=false Safety Pattern</h3>

  <p>
    Systems that perform destructive one-shot operations should start disabled
    (<code>Enabled = false</code> in <code>OnCreate</code>) and re-disable after each execution.
    This differs from <code>RequireForUpdate</code> which auto-enables based on entity query emptiness.
  </p>

  <pre><code class="language-csharp">protected override void OnCreate()
{
    base.OnCreate();
    Enabled = false; // Only enable explicitly from UI/trigger
}

protected override void OnUpdate()
{
    PerformDangerousOperation();
    Enabled = false; // Re-disable after execution
}</code></pre>

  <!-- ============================================================ -->
  <h2>Lifecycle Callbacks</h2>

  <h3>OnGameLoadingComplete</h3>

  <p>
    Override <code>OnGameLoadingComplete(Purpose, GameMode)</code> to enable/disable features based
    on whether the player is in Game mode, Editor mode, or the Main Menu. Fires after the game
    finishes loading a save or entering a mode:
  </p>

  <pre><code class="language-csharp">protected override void OnGameLoadingComplete(Purpose purpose, GameMode mode)
{
    base.OnGameLoadingComplete(purpose, mode);
    bool isGameOrEditor = mode == GameMode.Game || mode == GameMode.Editor;
    m_ToggleAction.shouldBeEnabled = isGameOrEditor;
}</code></pre>

  <p>
    <strong><code>OnGameLoadingComplete</code> vs <code>OnGameLoaded</code></strong>:
    <code>OnGameLoaded</code> fires during serialization context (for restoring system state).
    <code>OnGameLoadingComplete</code> fires after the full load &mdash; use it for enabling
    input actions, UI elements, and mode-dependent features.
  </p>

  <h3>GameManager.RegisterUpdater</h3>

  <p>
    <code>GameManager.instance.RegisterUpdater()</code> defers work to the next update cycle on the
    main thread. Use it when system references aren&rsquo;t available during <code>OnCreate</code>,
    when showing UI dialogs after initialization, or to start async work after the game loop is running:
  </p>

  <pre><code class="language-csharp">protected override void OnCreate()
{
    base.OnCreate();
    // Defer to next frame â€” some systems aren't ready during OnCreate
    GameManager.instance.RegisterUpdater(() =&gt;
    {
        var otherSystem = World.GetExistingSystemManaged&lt;SomeOtherSystem&gt;();
        // Now safe to access otherSystem
        return Task.CompletedTask;
    });
}

// Async work from IMod.OnLoad:
GameManager.instance.RegisterUpdater(async () =&gt;
{
    await Task.Run(() =&gt; LoadExternalResources());
});</code></pre>

  <h3>onSettingsApplied Callback</h3>

  <p>
    <code>ModSetting.onSettingsApplied</code> fires when settings change at runtime (user clicks
    Apply in the options menu). Use it to update cached values, UI bindings, or rendering parameters
    without restarting:
  </p>

  <pre><code class="language-csharp">m_Settings.onSettingsApplied += OnSettingsApplied;

private void OnSettingsApplied(Setting setting)
{
    if (setting is ModSettings modSettings)
    {
        UpdateKeybindingLabels(modSettings);
        UpdateOverlayColors(modSettings);
    }
}</code></pre>

  <!-- ============================================================ -->
  <h2>Deserialization Cleanup Pattern</h2>

  <p>
    When a mod creates transient entities at runtime that should not persist across save/load,
    register a cleanup system in the <code>Deserialize</code> phase. This ensures stale entities
    from a previous session are destroyed when a new game loads:
  </p>

  <pre><code class="language-csharp">public partial class ModDataClearSystem : GameSystemBase
{
    private EntityQuery m_TransientQuery;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_TransientQuery = GetEntityQuery(
            ComponentType.ReadOnly&lt;MyTransientComponent&gt;(),
            ComponentType.Exclude&lt;FakePrefabData&gt;()); // Don't destroy prefabs
    }

    protected override void OnUpdate()
    {
        EntityManager.DestroyEntity(m_TransientQuery);
    }
}

// Register in Deserialize phase:
updateSystem.UpdateAt&lt;ModDataClearSystem&gt;(SystemUpdatePhase.Deserialize);</code></pre>

  <p>
    <strong>Key details</strong>: Exclude <code>FakePrefabData</code> to avoid destroying permanent
    prefab entities. The <code>Deserialize</code> phase runs when loading a save or starting a new
    game. This is for runtime-only transient entities &mdash; serialized components survive by design.
  </p>

  <!-- ============================================================ -->
  <h2>Build Configuration Patterns</h2>

  <h3>Conditional Attribute for Debug Logging</h3>

  <p>
    The <code>[Conditional]</code> attribute strips method calls from Release builds at compile time,
    providing zero-cost debug logging:
  </p>

  <pre><code class="language-csharp">[System.Diagnostics.Conditional("DEBUG_TOOL")]
public static void DebugTool(string message)
{
    Log.Info($"[Tool] {message}");
}

// Calls are omitted by the compiler when DEBUG_TOOL is not defined:
ModLogger.DebugTool($"Processing node {entity}"); // zero-cost in Release</code></pre>

  <p>Define symbols in your <code>.csproj</code> per configuration:</p>

  <pre><code class="language-xml">&lt;PropertyGroup Condition="'$(Configuration)' == 'Debug'"&gt;
  &lt;DefineConstants&gt;DEBUG;DEBUG_TOOL;DEBUG_CONNECTIONS&lt;/DefineConstants&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup Condition="'$(Configuration)' == 'Release'"&gt;
  &lt;DefineConstants&gt;&lt;/DefineConstants&gt;
&lt;/PropertyGroup&gt;</code></pre>

  <h3>WITH_BURST Conditional Compilation</h3>

  <p>
    Use conditional Burst compilation: develop with standard C# debugging, release with Burst
    performance. Define <code>WITH_BURST</code> only in Release:
  </p>

  <pre><code class="language-csharp">#if WITH_BURST
[Unity.Burst.BurstCompile]
#endif
public partial struct MyExpensiveJob : IJobChunk
{
    public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex,
        bool useEnabledMask, in v128 chunkEnabledMask)
    {
        // Burst-compiled in Release, debuggable in Debug
    }
}</code></pre>

  <pre><code class="language-xml">&lt;PropertyGroup Condition="'$(Configuration)' == 'Release'"&gt;
  &lt;DefineConstants&gt;WITH_BURST&lt;/DefineConstants&gt;
  &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
&lt;/PropertyGroup&gt;</code></pre>

  <!-- ============================================================ -->
  <h2>GetUpdateInterval: Controlling System Tick Frequency</h2>

  <p>
    Custom systems do not need to run every frame. <code>GameSystemBase</code> provides a virtual
    method <code>GetUpdateInterval(SystemUpdatePhase)</code> that controls how many frames elapse
    between each <code>OnUpdate</code> call:
  </p>

  <pre><code class="language-csharp">// Decompiled from Game.GameSystemBase
public virtual int GetUpdateInterval(SystemUpdatePhase phase)
{
    return 1; // Default: run every frame
}</code></pre>

  <p>
    Override this to reduce how often your system ticks. For example, the vanilla
    <code>TreeGrowthSystem</code> and community mods like Tree_Controller use an interval of 512:
  </p>

  <pre><code class="language-csharp">public override int GetUpdateInterval(SystemUpdatePhase phase)
{
    return 512; // Run every 512 frames (= 32 updates per day)
}</code></pre>

  <h3>SimulationUtils.GetUpdateFrame: Work Distribution</h3>

  <p>
    When a system runs at a reduced interval, it typically processes only a subset of entities per
    tick using the <code>UpdateFrame</code> shared component filter. The
    <code>SimulationUtils.GetUpdateFrame</code> method determines which group to process:
  </p>

  <pre><code class="language-csharp">// Decompiled from Game.Simulation.SimulationUtils
public static uint GetUpdateFrame(uint frame, int updatesPerDay, int groupCount)
{
    return (uint)((frame / (262144 / (updatesPerDay * groupCount)))
                  &amp; (groupCount - 1));
}</code></pre>

  <ul>
    <li><code>frame</code> -- the current <code>SimulationSystem.frameIndex</code></li>
    <li><code>updatesPerDay</code> -- how many times per day each entity should be processed (e.g., 32)</li>
    <li><code>groupCount</code> -- how many groups entities are divided into (e.g., 16)</li>
  </ul>

  <p>
    The method divides the day (262144 frames) into <code>updatesPerDay * groupCount</code> buckets
    and returns the current bucket index masked to <code>groupCount - 1</code>.
  </p>

  <h3>Applying the UpdateFrame Filter</h3>

  <p>
    Use <code>SetSharedComponentFilter</code> on your <code>EntityQuery</code> to process only the
    current group:
  </p>

  <pre><code class="language-csharp">private SimulationSystem m_SimulationSystem;
private EntityQuery m_TreeQuery;

protected override void OnUpdate()
{
    // 32 updates/day, 16 groups -&gt; each group processed every 512 frames
    uint updateFrame = SimulationUtils.GetUpdateFrame(
        m_SimulationSystem.frameIndex, 32, 16);
    m_TreeQuery.ResetFilter();
    m_TreeQuery.SetSharedComponentFilter(new UpdateFrame(updateFrame));

    // Now m_TreeQuery only contains entities in the current group
    // Process them...
}</code></pre>

  <h3>Relationship: Interval vs Updates-Per-Day</h3>

  <table>
    <thead>
      <tr><th>Interval</th><th>Updates/Day</th><th>Groups</th><th>Entities per tick</th></tr>
    </thead>
    <tbody>
      <tr><td>512</td><td>32</td><td>16</td><td>1/16 of total</td></tr>
      <tr><td>256</td><td>64</td><td>16</td><td>1/16 of total</td></tr>
      <tr><td>128</td><td>128</td><td>16</td><td>1/16 of total</td></tr>
      <tr><td>16</td><td>1024</td><td>16</td><td>1/16 of total</td></tr>
    </tbody>
  </table>

  <p>
    The interval determines how often your <code>OnUpdate</code> runs. The <code>groupCount</code>
    determines what fraction of entities are processed per tick. Together they control total
    throughput: with interval=512 and groups=16, each entity is processed 32 times per day.
  </p>

  <h3>When to Match Vanilla Intervals</h3>

  <p>
    Custom systems that read data produced by vanilla systems should match or be a multiple of the
    vanilla system&rsquo;s interval. For example, a mod system that reads tree growth data should use
    interval 512 (same as <code>TreeGrowthSystem</code>) to ensure synchronized data. Running at a
    faster interval wastes CPU cycles processing stale data.
  </p>

  <h3>GetUpdateOffset: Staggering System Execution</h3>

  <p>
    <code>GameSystemBase</code> also provides <code>GetUpdateOffset(SystemUpdatePhase)</code>
    (default: -1, meaning auto-assigned) to stagger when systems run within the same interval. The
    game distributes systems across frames to avoid spikes. Override this only if your system must
    run on a specific frame offset.
  </p>

  <!-- ============================================================ -->
  <h2>Open Questions</h2>

  <ul>
    <li>
      <strong>Load order guarantees:</strong> Mods are loaded in the order they appear in
      AssetDatabase scan results. There is no explicit priority or load-order declaration.
      Assembly references indirectly enforce ordering.
    </li>
    <li>
      <strong>Hot-reloading:</strong> <code>ModManager.RequireRestart()</code> exists but
      actual hot-reload (unload + reload without restart) is not supported for code mods.
      UI modules can be added/removed dynamically.
    </li>
    <li>
      <strong>Inter-mod communication:</strong> No official inter-mod API exists. Mods
      expose public static members and reference each other via assembly references.
    </li>
    <li>
      <strong>PDX Mods dependency metadata:</strong> How dependencies are declared in the
      PDX Mods platform (separate from assembly references) needs testing with the launcher.
    </li>
  </ul>

  <!-- ============================================================ -->
  <h2>Sources</h2>

  <ul>
    <li>Decompiled from: Game.dll -- Game.Modding.IMod, Game.Modding.ModManager, Game.Modding.ModSetting, Game.UpdateSystem, Game.SystemUpdatePhase</li>
    <li>Asset system: Colossal.IO.AssetDatabase.dll -- Colossal.IO.AssetDatabase.ExecutableAsset</li>
    <li><a href="https://www.paradoxinteractive.com/games/cities-skylines-ii/modding/dev-diary-3-code-modding">CS2 Code Modding Dev Diary (Paradox)</a></li>
  </ul>

  <footer>
    <p>Source: Decompiled from Game.dll (Cities: Skylines II) -- IMod, ModManager, ModSetting, UpdateSystem.</p>
    <div class="attribution-footer">
      <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
    </div>
  </footer>

  </main>

</div>

</body>
</html>
