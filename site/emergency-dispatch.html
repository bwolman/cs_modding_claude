<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emergency Vehicle Dispatch - CS2 Modding Research</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="top-bar">
    <a href="index.html" class="site-title">CS2 Modding Research</a>
    <span class="attribution">Generated with Claude | Supervised by repository owner</span>
  </div>

  <div class="page-layout">

    <aside class="sidebar">
      <h3>Events &amp; Simulation</h3>
      <a href="event-entity-archetype.html">Event Entity Archetype</a>
      <a href="fire-ignition.html">Fire Ignition</a>
      <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
      <a href="crime-trigger.html">Crime Trigger</a>
      <a href="citizen-sickness.html">Citizen Sickness</a>
      <a href="water-system.html">Water System</a>
      <a href="emergency-dispatch.html" class="active">Emergency Dispatch</a>

      <h3>Infrastructure</h3>
      <a href="electricity-grid.html">Electricity Grid</a>
      <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
      <a href="road-network.html">Road &amp; Network Building</a>
      <a href="zoning.html">Zoning</a>

      <h3>Economy &amp; Population</h3>
      <a href="citizens-households.html">Citizens &amp; Households</a>
      <a href="economy-budget.html">Economy &amp; Budget</a>
      <a href="demand-systems.html">Demand Systems</a>
      <a href="resource-production.html">Resource Production</a>
      <a href="company-simulation.html">Company Simulation</a>
      <a href="workplace-labor.html">Workplace &amp; Labor</a>
      <a href="land-value-property.html">Land Value &amp; Property</a>
      <a href="trade-connections.html">Trade &amp; Connections</a>
      <a href="tourism-economy.html">Tourism Economy</a>

      <h3>City Services</h3>
      <a href="garbage-collection.html">Garbage Collection</a>
      <a href="education.html">Education</a>
      <a href="public-transit.html">Public Transit</a>

      <h3>Environment</h3>
      <a href="weather-climate.html">Weather &amp; Climate</a>
      <a href="pollution.html">Pollution</a>
      <a href="terrain-resources.html">Terrain &amp; Resources</a>

      <h3>Tools &amp; Input</h3>
      <a href="tool-activation.html">Tool Activation</a>
      <a href="tool-raycast.html">Tool Raycast</a>
      <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
      <a href="mod-hotkey-input.html">Mod Hotkey Input</a>

      <h3>UI &amp; Settings</h3>
      <a href="mod-ui-buttons.html">Mod UI Buttons</a>
      <a href="mod-options-ui.html">Mod Options UI</a>
    </aside>

    <main class="content">
    <h1>Emergency Vehicle Dispatch</h1>

  <div class="scope">
    <h2>Scope</h2>
    <p>
      <strong>Question:</strong> How are emergency vehicles (police cars, fire engines, ambulances,
      hearses) dispatched? What triggers dispatch, and can a mod control which services respond
      to which events?
    </p>
    <p>
      <strong>Verdict:</strong> Each service type has a completely independent request/dispatch
      pipeline. Dispatch is triggered by specific ECS components on target entities (AccidentSite
      for police, OnFire/RescueTarget for fire, HealthProblem for healthcare). A mod can create
      request entities directly and ensure the required validation components exist on the target
      to force any service to respond to any event. Note: for healthcare,
      <code>HealthProblem</code> must be added through the event-based
      <code>AddHealthProblem</code> pipeline, not directly -- see the warning in the Examples
      section.
    </p>
    <p>
      <strong>Out of scope:</strong> Vehicle AI after dispatch, patrol route generation,
      building-level service coverage calculations.
    </p>
  </div>

  <!-- ============================================================ -->
  <h2>How It Works</h2>

  <p>
    CS2 uses a <strong>request entity</strong> pattern for emergency dispatch. When a fire starts,
    a crime is detected, or a citizen needs medical help, the game creates a small ECS entity
    containing a service-specific request component. Dedicated dispatch systems then process
    these request entities, pathfind to find available vehicles, and assign them.
  </p>

  <p>
    The key insight: dispatch systems process request <em>entities</em>, not events directly.
    They validate the request by checking that the target still has the expected component
    (OnFire, AccidentSite, HealthProblem). This means a mod can create request entities
    programmatically, as long as the validation component exists on the target.
  </p>

  <h3>Namespace Disambiguation: <code>Game.Common.Event</code> vs <code>Game.Events.Event</code></h3>

  <p>
    CS2 has two different empty marker structs both named <code>Event</code> in different namespaces.
    Several components referenced in this page (e.g., <code>AccidentSite.m_Event</code>,
    <code>OnFire.m_Event</code>, <code>HealthProblem.m_Event</code>) store an <code>Entity</code>
    reference to an event entity. Understanding which <code>Event</code> type that entity carries is
    critical for mods that create or query event entities.
  </p>

  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Namespace</th>
        <th>Purpose</th>
        <th>Lifetime</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Game.Common.Event</code></td>
        <td><code>Game.Common</code></td>
        <td>Tag component on short-lived command/notification entities (Impact, AddAccidentSite, Ignite, AddHealthProblem)</td>
        <td>Created and destroyed within 1-2 frames</td>
      </tr>
      <tr>
        <td><code>Game.Events.Event</code></td>
        <td><code>Game.Events</code></td>
        <td>Tag component on persistent accident/disaster event entities (TrafficAccident, etc.) with duration, flags, and target tracking</td>
        <td>Persists for the full duration of the accident or disaster</td>
      </tr>
    </tbody>
  </table>

  <p>
    The <code>m_Event</code> fields on <code>AccidentSite</code>, <code>OnFire</code>,
    <code>HealthProblem</code>, and <code>InvolvedInAccident</code> point to persistent
    <code>Game.Events.Event</code> entities (the long-lived TrafficAccident event entity), not the
    short-lived <code>Game.Common.Event</code> command entities.
  </p>

  <p>
    <strong>Ambiguity warning:</strong> If your mod imports both <code>using Game.Common;</code> and
    <code>using Game.Events;</code>, the bare name <code>Event</code> becomes ambiguous and will cause
    a compiler error. Always use fully-qualified names when both namespaces are in scope:
  </p>

  <pre><code class="language-csharp">// BAD: ambiguous if both namespaces are imported
using Game.Common;
using Game.Events;

// ...
ComponentType.ReadWrite&lt;Event&gt;()  // Compiler error: 'Event' is ambiguous

// GOOD: use fully-qualified names
ComponentType.ReadWrite&lt;Game.Events.Event&gt;()     // persistent event entity
ComponentType.ReadWrite&lt;Game.Common.Event&gt;()      // short-lived command entity</code></pre>

  <p>
    Using the wrong <code>Event</code> type is a silent failure at runtime -- the entity will be
    created but will not match the queries that downstream systems use, so the entire pipeline
    silently does nothing. For full details on the TrafficAccident event entity archetype and how
    these two <code>Event</code> types are used in the accident pipeline, see the
    <a href="event-entity-archetype.html">Event Entity Archetype</a> topic.
  </p>

  <h3>The Three Dispatch Pipelines</h3>

  <p>There is no central dispatch router. Each emergency service has its own pipeline:</p>

  <table>
    <thead>
      <tr>
        <th>Service</th>
        <th>Trigger Component</th>
        <th>Request Creator</th>
        <th>Request Type</th>
        <th>Dispatch System</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Police</td>
        <td>AccidentSite (with RequirePolice flag)</td>
        <td>AccidentSiteSystem</td>
        <td>PoliceEmergencyRequest</td>
        <td>PoliceEmergencyDispatchSystem</td>
      </tr>
      <tr>
        <td>Fire</td>
        <td>OnFire or RescueTarget</td>
        <td>FireSimulationSystem</td>
        <td>FireRescueRequest</td>
        <td>FireRescueDispatchSystem</td>
      </tr>
      <tr>
        <td>Ambulance</td>
        <td>HealthProblem (with RequireTransport, not Dead)</td>
        <td>HealthProblemSystem</td>
        <td>HealthcareRequest (Ambulance)</td>
        <td>HealthcareDispatchSystem</td>
      </tr>
      <tr>
        <td>Hearse</td>
        <td>HealthProblem (with RequireTransport + Dead)</td>
        <td>HealthProblemSystem</td>
        <td>HealthcareRequest (Hearse)</td>
        <td>HealthcareDispatchSystem</td>
      </tr>
    </tbody>
  </table>

  <h3>The Request Entity Lifecycle</h3>

  <p>Every service request follows the same lifecycle, managed by shared infrastructure:</p>

  <ol>
    <li>
      <strong>Creation:</strong> A simulation system detects the trigger condition and creates
      an entity with three components: <code>ServiceRequest</code> (base), the specific request
      type (e.g., <code>PoliceEmergencyRequest</code>), and <code>RequestGroup</code>.
    </li>
    <li>
      <strong>Frame assignment:</strong> <code>ServiceRequestSystem</code> sees the
      <code>RequestGroup</code>, randomly assigns the request to an <code>UpdateFrame</code>
      group, then removes <code>RequestGroup</code>. This distributes processing across ticks.
    </li>
    <li>
      <strong>Pathfinding:</strong> When the dispatch system processes the request on its
      assigned frame, it validates the target, then enqueues a pathfind from available
      vehicles/stations to the target location.
    </li>
    <li>
      <strong>Dispatch:</strong> On the next processing tick, if a valid path was found, the
      system adds a <code>Dispatched</code> component to the request and a
      <code>ServiceDispatch</code> buffer element to the handler (vehicle or building).
    </li>
    <li>
      <strong>Completion:</strong> The vehicle AI system creates a <code>HandleRequest</code>
      entity with <code>m_Completed = true</code>. <code>ServiceRequestSystem</code> destroys
      the request entity.
    </li>
  </ol>

  <!-- ============================================================ -->
  <h2>Key Components</h2>

  <h3>Request Infrastructure</h3>

  <table>
    <thead>
      <tr>
        <th>Component</th>
        <th>Type</th>
        <th>Purpose</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>ServiceRequest</code></td>
        <td>IComponentData</td>
        <td>Base component on every request. Tracks fail count, cooldown, and flags (Reversed, SkipCooldown).</td>
      </tr>
      <tr>
        <td><code>ServiceDispatch</code></td>
        <td>IBufferElementData</td>
        <td>Buffer on vehicles/buildings. Each element points to a request entity the handler is fulfilling.</td>
      </tr>
      <tr>
        <td><code>Dispatched</code></td>
        <td>IComponentData</td>
        <td>Added to a request once a handler is assigned. Points to the handler entity.</td>
      </tr>
      <tr>
        <td><code>HandleRequest</code></td>
        <td>IComponentData</td>
        <td>Transient signal: marks a request as completed or reassigns its handler.</td>
      </tr>
      <tr>
        <td><code>RequestGroup</code></td>
        <td>IComponentData</td>
        <td>Temporary. Tells ServiceRequestSystem to assign this request to a random UpdateFrame group.</td>
      </tr>
    </tbody>
  </table>

  <h3>Service-Specific Request Types</h3>

  <table>
    <thead>
      <tr>
        <th>Request Component</th>
        <th>Key Fields</th>
        <th>Validation Target</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>PoliceEmergencyRequest</code></td>
        <td>m_Site (AccidentSite entity), m_Target, m_Priority (float), m_Purpose (PolicePurpose flags)</td>
        <td>AccidentSite with RequirePolice set and Secured not set</td>
      </tr>
      <tr>
        <td><code>FireRescueRequest</code></td>
        <td>m_Target, m_Priority (float, fire intensity), m_Type (Fire or Disaster)</td>
        <td>OnFire or RescueTarget on target entity</td>
      </tr>
      <tr>
        <td><code>HealthcareRequest</code></td>
        <td>m_Citizen, m_Type (Ambulance or Hearse)</td>
        <td>HealthProblem with RequireTransport flag on citizen</td>
      </tr>
      <tr>
        <td><code>PolicePatrolRequest</code></td>
        <td>m_Target, m_Priority, m_DispatchIndex</td>
        <td>Patrol target (separate from emergency)</td>
      </tr>
      <tr>
        <td><code>EvacuationRequest</code></td>
        <td>m_Target, m_Priority</td>
        <td>Building/area to evacuate</td>
      </tr>
    </tbody>
  </table>

  <h3>Trigger Components (on target entities)</h3>

  <table>
    <thead>
      <tr>
        <th>Component</th>
        <th>Namespace</th>
        <th>Key Fields</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>AccidentSite</code></td>
        <td>Game.Events</td>
        <td>m_Event, m_PoliceRequest, m_Flags (AccidentSiteFlags), m_CreationFrame, m_SecuredFrame</td>
      </tr>
      <tr>
        <td><code>OnFire</code></td>
        <td>Game.Events</td>
        <td>m_Event, m_RescueRequest, m_Intensity, m_RequestFrame</td>
      </tr>
      <tr>
        <td><code>HealthProblem</code></td>
        <td>Game.Citizens</td>
        <td>m_Event, m_HealthcareRequest, m_Flags (HealthProblemFlags), m_Timer</td>
      </tr>
      <tr>
        <td><code>RescueTarget</code></td>
        <td>Game.Buildings</td>
        <td>m_Request -- alternative validation target for fire rescue</td>
      </tr>
      <tr>
        <td><code>InvolvedInAccident</code></td>
        <td>Game.Events</td>
        <td>m_Event, m_Severity, m_InvolvedFrame -- on vehicles involved in accident</td>
      </tr>
    </tbody>
  </table>

  <h3>Enums</h3>

  <table>
    <thead>
      <tr>
        <th>Enum</th>
        <th>Values</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>AccidentSiteFlags</code></td>
        <td>StageAccident (0x01), Secured (0x02), CrimeScene (0x04), TrafficAccident (0x08), CrimeFinished (0x10), CrimeDetected (0x20), CrimeMonitored (0x40), RequirePolice (0x80), MovingVehicles (0x100)</td>
      </tr>
      <tr>
        <td><code>PolicePurpose</code></td>
        <td>Patrol (1), Emergency (2), Intelligence (4)</td>
      </tr>
      <tr>
        <td><code>FireRescueRequestType</code></td>
        <td>Fire (0), Disaster (1)</td>
      </tr>
      <tr>
        <td><code>HealthcareRequestType</code></td>
        <td>Ambulance (0), Hearse (1)</td>
      </tr>
      <tr>
        <td><code>HealthProblemFlags</code></td>
        <td>Sick (1), Dead (2), Injured (4), RequireTransport (8), InDanger (0x10), Trapped (0x20), NoHealthcare (0x40)</td>
      </tr>
      <tr>
        <td><code>ServiceRequestFlags</code></td>
        <td>Reversed (1), SkipCooldown (2)</td>
      </tr>
    </tbody>
  </table>

  <!-- ============================================================ -->
  <h2>Data Flow</h2>

  <div class="diagram">
<pre>
  [Event Occurs]
       |
       +---> Fire ignites: IgniteSystem adds OnFire to entity
       |         |
       |         v
       |     FireSimulationSystem checks m_RequestFrame
       |         |
       |         v
       |     Creates: ServiceRequest + FireRescueRequest + RequestGroup(4)
       |
       +---> Accident: ImpactSystem -> AddAccidentSiteSystem
       |         |
       |         v
       |     AccidentSiteSystem (every 64 frames):
       |         |  1. Clears RequirePolice unconditionally
       |         |  2. Re-sets RequirePolice if severity > 0 + valid target
       |         |     OR detected unsecured crime + valid target
       |         v
       |     Creates: ServiceRequest + PoliceEmergencyRequest + RequestGroup(4)
       |
       +---> Citizen sick/dead: AddHealthProblem event
                 |
                 v
             HealthProblemSystem checks RequireTransport flag
                 |
                 v
             Creates: ServiceRequest + HealthcareRequest + RequestGroup(16)

  [ServiceRequestSystem]
       |
       v
  UpdateRequestGroupJob: removes RequestGroup, adds UpdateFrame(random)
       |
       v
  [Dispatch System runs every 16 frames]
       |
       +--- ValidateTarget: is the trigger component still present?
       |         |
       |    NO --+--> destroy request
       |         |
       |   YES --+
       |         v
       +--- FindVehicleSource: enqueue pathfind request
       |         |
       |    ~~ pathfinding completes ~~
       |         |
       |         v
       +--- DispatchVehicle:
       |         +---> Add Dispatched to request
       |         +---> Add ServiceDispatch to handler buffer
       |
       v
  [Vehicle AI drives to target, performs service]
       |
       v
  HandleRequest(m_Completed = true)
       |
       v
  ServiceRequestSystem destroys the request entity
</pre>
  </div>

  <!-- ============================================================ -->
  <h2>Police Dispatch: The AccidentSite Gate</h2>

  <p>
    Police emergency dispatch has an extra layer of complexity. The
    <code>AccidentSiteSystem</code> runs every 64 frames and uses a
    <strong>clear-then-evaluate</strong> pattern for the <code>RequirePolice</code> flag.
    On every tick, for every <code>AccidentSite</code> entity, the system:
  </p>

  <ol>
    <li><strong>Unconditionally clears</strong> <code>RequirePolice</code>:
        <code>accidentSite.m_Flags &amp;= ~AccidentSiteFlags.RequirePolice;</code></li>
    <li><strong>Conditionally re-sets</strong> <code>RequirePolice</code> only when:
      <ul>
        <li>At least one involved entity has <code>InvolvedInAccident.m_Severity &gt; 0</code>
            AND a valid non-moving target entity exists, OR</li>
        <li>The site is an unsecured crime scene (<code>CrimeScene</code> set, <code>Secured</code>
            not set) with <code>CrimeDetected</code> flag set AND a valid target exists</li>
      </ul>
    </li>
  </ol>

  <p>
    The decompiled code from <code>AccidentSiteJob</code> shows this pattern explicitly.
    <code>num2</code> is the maximum severity from <code>InvolvedInAccident</code> targets, and
    <code>entity2</code> is the highest-severity non-moving entity:
  </p>

  <pre><code class="language-csharp">// Step 1: UNCONDITIONAL CLEAR
accidentSite.m_Flags &amp;= ~AccidentSiteFlags.RequirePolice;

// Step 2: CONDITIONAL RE-SET based on severity and crime scene status
if (num2 &gt; 0f || (accidentSite.m_Flags &amp; (AccidentSiteFlags.Secured | AccidentSiteFlags.CrimeScene)) == AccidentSiteFlags.CrimeScene)
{
    if (num2 &gt; 0f || (accidentSite.m_Flags &amp; AccidentSiteFlags.CrimeDetected) != 0)
    {
        if (entity2 != Entity.Null)
        {
            accidentSite.m_Flags |= AccidentSiteFlags.RequirePolice;
            RequestPoliceIfNeeded(...);
        }
    }
}</code></pre>

  <p>
    The unconditional clear means any value set by a mod <em>before</em>
    <code>AccidentSiteSystem</code> runs will be wiped. See the modding warning below.
  </p>

  <p>
    The <code>PoliceEmergencyDispatchSystem.ValidateSite()</code> method then checks:
  </p>

  <pre><code class="language-csharp">private bool ValidateSite(Entity entity, Entity site)
{
    if (!m_AccidentSiteData.TryGetComponent(site, out var componentData))
        return false;
    if ((componentData.m_Flags &amp; (AccidentSiteFlags.Secured | AccidentSiteFlags.RequirePolice))
        != AccidentSiteFlags.RequirePolice)
        return false;
    // ... validate m_PoliceRequest matches
    return true;
}</code></pre>

  <p>
    This means: if <code>RequirePolice</code> is not set, or if <code>Secured</code> is already
    set, the request gets destroyed. A mod that wants police at every accident must ensure
    <code>RequirePolice</code> stays set.
  </p>

  <!-- ============================================================ -->
  <h2>Modding Warning: UpdateBefore vs UpdateAfter for RequirePolice</h2>

  <p>
    Because <code>AccidentSiteSystem</code> <strong>unconditionally clears</strong>
    <code>RequirePolice</code> before evaluating whether to re-set it, the system ordering
    of any mod that modifies this flag is critical:
  </p>

  <table>
    <thead>
      <tr>
        <th>Ordering</th>
        <th>Result</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>[UpdateBefore(typeof(AccidentSiteSystem))]</code></td>
        <td><strong>WRONG.</strong> Your <code>RequirePolice</code> value will be unconditionally
            wiped by the <code>&amp;= ~RequirePolice</code> clear at the top of the system's
            evaluation loop. Your changes are lost every tick.</td>
      </tr>
      <tr>
        <td><code>[UpdateAfter(typeof(AccidentSiteSystem))]</code></td>
        <td><strong>CORRECT.</strong> Your system runs after the clear-and-evaluate cycle. You can
            safely set <code>RequirePolice</code> and it will persist until the next
            <code>AccidentSiteSystem</code> tick (64 frames later). The
            <code>PoliceEmergencyDispatchSystem</code> will see your flag during the intervening
            dispatch ticks.</td>
      </tr>
    </tbody>
  </table>

  <p>
    The same pattern applies to <code>MovingVehicles</code>, which is also unconditionally cleared
    then conditionally re-set each tick.
  </p>

  <!-- ============================================================ -->
  <h2>Examples</h2>

  <h3>Force Police to Every Traffic Accident</h3>

  <p>
    Create a system that runs after <code>AccidentSiteSystem</code> and ensures all traffic
    accident sites have the <code>RequirePolice</code> flag set, creating requests as needed.
  </p>

  <pre><code class="language-csharp">using Game.Common;
using Game.Events;
using Game.Prefabs;
using Game.Simulation;
using Unity.Collections;
using Unity.Entities;

public partial class ForcePoliceToAccidentsSystem : GameSystemBase
{
    private EntityQuery m_AccidentQuery;
    private ComponentLookup&lt;PoliceEmergencyRequest&gt; m_PoliceRequestLookup;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_AccidentQuery = GetEntityQuery(
            ComponentType.ReadWrite&lt;AccidentSite&gt;(),
            ComponentType.Exclude&lt;Deleted&gt;(),
            ComponentType.Exclude&lt;Temp&gt;());
        m_PoliceRequestLookup = GetComponentLookup&lt;PoliceEmergencyRequest&gt;(true);
        RequireForUpdate(m_AccidentQuery);
    }

    protected override void OnUpdate()
    {
        m_PoliceRequestLookup.Update(ref CheckedStateRef);
        var entities = m_AccidentQuery.ToEntityArray(Allocator.Temp);
        for (int i = 0; i &lt; entities.Length; i++)
        {
            var site = EntityManager.GetComponentData&lt;AccidentSite&gt;(entities[i]);

            // Only target traffic accidents that are not yet secured
            if ((site.m_Flags &amp; AccidentSiteFlags.TrafficAccident) == 0) continue;
            if ((site.m_Flags &amp; AccidentSiteFlags.Secured) != 0) continue;

            // Force the RequirePolice flag
            site.m_Flags |= AccidentSiteFlags.RequirePolice;
            EntityManager.SetComponentData(entities[i], site);

            // Create police request if none exists
            if (!m_PoliceRequestLookup.HasComponent(site.m_PoliceRequest))
            {
                Entity request = EntityManager.CreateEntity();
                EntityManager.AddComponentData(request, new ServiceRequest());
                EntityManager.AddComponentData(request,
                    new PoliceEmergencyRequest(entities[i], entities[i], 1f,
                        PolicePurpose.Emergency));
                EntityManager.AddComponentData(request, new RequestGroup(4u));
            }
        }
        entities.Dispose();
    }
}</code></pre>

  <h3>Send Fire Engines to an Accident Scene</h3>

  <p>
    Fire dispatch requires <code>OnFire</code> or <code>RescueTarget</code> on the target.
    Add <code>RescueTarget</code> to the accident entity, then create a
    <code>FireRescueRequest</code>.
  </p>

  <pre><code class="language-csharp">using Game.Buildings;
using Game.Common;
using Game.Events;
using Game.Simulation;
using Unity.Collections;
using Unity.Entities;

public partial class FireToAccidentsSystem : GameSystemBase
{
    private EntityQuery m_AccidentQuery;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_AccidentQuery = GetEntityQuery(
            ComponentType.ReadOnly&lt;AccidentSite&gt;(),
            ComponentType.Exclude&lt;RescueTarget&gt;(),
            ComponentType.Exclude&lt;Deleted&gt;());
        RequireForUpdate(m_AccidentQuery);
    }

    protected override void OnUpdate()
    {
        var entities = m_AccidentQuery.ToEntityArray(Allocator.Temp);
        for (int i = 0; i &lt; entities.Length; i++)
        {
            var site = EntityManager.GetComponentData&lt;AccidentSite&gt;(entities[i]);
            if ((site.m_Flags &amp; AccidentSiteFlags.TrafficAccident) == 0) continue;
            if ((site.m_Flags &amp; AccidentSiteFlags.Secured) != 0) continue;

            // Add RescueTarget so FireRescueDispatchSystem validates this entity
            EntityManager.AddComponentData(entities[i],
                new RescueTarget(Entity.Null));

            // Create fire rescue request
            Entity request = EntityManager.CreateEntity();
            EntityManager.AddComponentData(request, new ServiceRequest());
            EntityManager.AddComponentData(request,
                new FireRescueRequest(entities[i], 1f,
                    FireRescueRequestType.Disaster));
            EntityManager.AddComponentData(request, new RequestGroup(4u));
        }
        entities.Dispose();
    }
}</code></pre>

  <h3>Dispatch an Ambulance Programmatically</h3>

  <p>
    Healthcare dispatch requires <code>HealthProblem</code> with <code>RequireTransport</code>
    on the citizen. If the citizen already has this (e.g., from a sickness event), just create
    the request entity. The example below assumes the citizen already has
    <code>HealthProblem</code> -- see the warning below about how to add it correctly.
  </p>

  <pre><code class="language-csharp">using Game.Citizens;
using Game.Simulation;
using Unity.Entities;

/// &lt;summary&gt;
/// Create an ambulance request for a citizen that already has HealthProblem
/// with RequireTransport flag. Call from a system's OnUpdate.
/// &lt;/summary&gt;
private void DispatchAmbulanceTo(Entity citizen)
{
    if (!EntityManager.HasComponent&lt;HealthProblem&gt;(citizen)) return;

    var problem = EntityManager.GetComponentData&lt;HealthProblem&gt;(citizen);
    if ((problem.m_Flags &amp; HealthProblemFlags.RequireTransport) == 0) return;

    // Check no request already exists
    if (EntityManager.HasComponent&lt;HealthcareRequest&gt;(problem.m_HealthcareRequest))
        return;

    HealthcareRequestType type = (problem.m_Flags &amp; HealthProblemFlags.Dead) != 0
        ? HealthcareRequestType.Hearse
        : HealthcareRequestType.Ambulance;

    Entity request = EntityManager.CreateEntity();
    EntityManager.AddComponentData(request, new ServiceRequest());
    EntityManager.AddComponentData(request,
        new HealthcareRequest(citizen, type));
    EntityManager.AddComponentData(request, new RequestGroup(16u));
}</code></pre>

  <h3>Warning: Do NOT Directly Add HealthProblem to Citizens</h3>

  <p>
    If you need a citizen to have <code>HealthProblem</code> (e.g., to satisfy
    <code>HealthcareDispatchSystem</code> validation), <strong>do not add it directly</strong>
    via <code>EntityManager.AddComponentData()</code>. Directly adding <code>HealthProblem</code>
    bypasses <code>AddHealthProblemSystem</code>, which performs critical side effects:
  </p>

  <ol>
    <li><strong>Stops citizen movement</strong> (<code>StopMoving()</code> clears pathfinding on
        the citizen's transport) -- without this, the citizen keeps walking/driving and
        ambulances may never reach a moving target.</li>
    <li><strong>Fires trigger events</strong> (<code>CitizenGotSick</code>,
        <code>CitizenGotInjured</code>, etc.) -- other systems and mods rely on these.</li>
    <li><strong>Creates journal data</strong> for statistics tracking.</li>
    <li><strong>Merges flags properly</strong> via <code>MergeProblems()</code> (Dead &gt;
        RequireTransport &gt; non-null Event &gt; flag union) -- direct addition can clobber
        existing flags.</li>
  </ol>

  <p>
    <strong>The correct approach</strong> is to create an <code>AddHealthProblem</code> event
    entity (with <code>Game.Common.Event</code> tag + <code>Game.Events.AddHealthProblem</code>
    component) and let <code>AddHealthProblemSystem</code> handle it:
  </p>

  <pre><code class="language-csharp">// CORRECT: Create an event entity for AddHealthProblemSystem to process
Entity cmd = EntityManager.CreateEntity();
EntityManager.AddComponentData(cmd, new Game.Common.Event());
EntityManager.AddComponentData(cmd, new AddHealthProblem
{
    m_Event = Entity.Null,
    m_Target = citizenEntity,
    m_Flags = HealthProblemFlags.Sick | HealthProblemFlags.RequireTransport
});
// AddHealthProblemSystem processes this next frame -- stops movement,
// fires triggers, creates journal data, and merges flags correctly.</code></pre>

  <p>
    See the <a href="citizen-sickness.html">Citizen Sickness</a> topic for full details on
    <code>AddHealthProblemSystem</code>, the event-based approach, and code examples.
  </p>

  <!-- ============================================================ -->
  <h2>Configuration</h2>

  <table>
    <thead>
      <tr>
        <th>Value</th>
        <th>Source</th>
        <th>Notes</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Police request group size</td>
        <td>Hardcoded: 4</td>
        <td>In AccidentSiteSystem.RequestPoliceIfNeeded()</td>
      </tr>
      <tr>
        <td>Fire request group size</td>
        <td>Hardcoded: 4</td>
        <td>In FireSimulationSystem</td>
      </tr>
      <tr>
        <td>Healthcare request group size</td>
        <td>Hardcoded: 16</td>
        <td>In HealthProblemSystem</td>
      </tr>
      <tr>
        <td>Crime alarm delay</td>
        <td>CrimeData.m_AlarmDelay (Bounds1)</td>
        <td>From event prefab, modified by CityModifierType.CrimeResponseTime</td>
      </tr>
      <tr>
        <td>Accident staging timeout</td>
        <td>Hardcoded: 3600 frames (~60s)</td>
        <td>In AccidentSiteSystem</td>
      </tr>
      <tr>
        <td>Dispatch system update interval</td>
        <td>16 frames for all dispatch systems</td>
        <td>Set via GetUpdateInterval()</td>
      </tr>
      <tr>
        <td>AccidentSiteSystem update interval</td>
        <td>64 frames</td>
        <td>Set via GetUpdateInterval()</td>
      </tr>
      <tr>
        <td>Police purpose for accidents</td>
        <td>PolicePurpose.Emergency</td>
        <td>Hardcoded in AccidentSiteSystem</td>
      </tr>
      <tr>
        <td>Police purpose for monitored crimes</td>
        <td>PolicePurpose.Intelligence</td>
        <td>Hardcoded in AccidentSiteSystem</td>
      </tr>
    </tbody>
  </table>

  <!-- ============================================================ -->
  <h2>Archetype Safety: Do Not Add Building Components to Citizens</h2>

  <p>
    In CS2's ECS, every entity has an <strong>archetype</strong> determined by its exact set of
    component types. Adding or removing a component moves the entity to a different archetype,
    changing which <code>EntityQuery</code> results it appears in. This creates a subtle and
    dangerous pitfall for modders working with cross-domain dispatch.
  </p>

  <h3>The Problem</h3>

  <p>
    <code>RescueTarget</code> is defined in the <code>Game.Buildings</code> namespace. It is a
    building-domain component -- the game adds it to <strong>building</strong> entities that need
    fire rescue (e.g., collapsed structures). The <code>FireRescueDispatchSystem.ValidateTarget()</code>
    method checks for <code>OnFire</code> or <code>RescueTarget</code> on the target entity.
  </p>

  <p>
    It may seem logical to add <code>RescueTarget</code> to a <strong>citizen</strong> entity to
    make fire engines respond to citizen emergencies. <strong>Do not do this.</strong> Adding a
    building-domain component to a citizen entity changes the citizen's archetype, which causes
    three problems:
  </p>

  <ol>
    <li>
      <strong>Matches queries it should not match.</strong> Systems that query for entities with
      <code>RescueTarget</code> (building rescue systems, cleanup systems) will pick up this
      citizen entity and may process it incorrectly.
    </li>
    <li>
      <strong>Drops out of queries it should match.</strong> Some systems use
      <code>ComponentType.Exclude</code> or archetype-based chunk filtering. An unexpected
      component can cause the entity to silently disappear from these queries.
    </li>
    <li>
      <strong>Breaks <code>HealthcareDispatchSystem</code>.</strong> Healthcare-adjacent systems
      that iterate over citizen archetypes may skip entities with unexpected building-domain
      components. This can result in ambulances never being dispatched or citizens being silently
      ignored by the healthcare pipeline.
    </li>
  </ol>

  <h3>Bad Example: RescueTarget on Citizens</h3>

  <p>
    The "Send Fire Engines to an Accident Scene" example above adds <code>RescueTarget</code> to
    <strong>accident site entities</strong> (road segments or event entities), which is acceptable
    because those are not citizen entities. However, applying the same pattern to citizens is
    dangerous:
  </p>

  <pre><code class="language-csharp">// BAD: Adding a building-domain component to a citizen entity
EntityManager.AddComponentData(citizenEntity, new RescueTarget(Entity.Null));</code></pre>

  <p>
    This changes the citizen's archetype from something like
    <code>[Citizen, CurrentBuilding, HouseholdMember, HealthProblem, ...]</code> to
    <code>[Citizen, CurrentBuilding, HouseholdMember, HealthProblem, RescueTarget, ...]</code>.
    Any system querying citizen archetypes without expecting <code>RescueTarget</code> may behave
    unpredictably.
  </p>

  <h3>Recommended: Custom Tag Components</h3>

  <p>
    Instead of reusing game components from other domains, define a custom tag component in your
    mod's namespace:
  </p>

  <pre><code class="language-csharp">namespace YourMod.Components
{
    /// &lt;summary&gt;
    /// Tag component marking a citizen as needing fire rescue.
    /// Uses a mod-specific type to avoid archetype conflicts with
    /// Game.Buildings.RescueTarget.
    /// &lt;/summary&gt;
    public struct NeedsFireRescue : IComponentData
    {
        public Entity m_Request;
    }
}</code></pre>

  <p>Then create a custom system that:</p>

  <ol>
    <li>Queries for citizens with your <code>NeedsFireRescue</code> tag</li>
    <li>Creates <code>FireRescueRequest</code> entities pointing to the citizen's
        <strong>current building</strong> (not the citizen) as the target</li>
    <li>Adds <code>RescueTarget</code> to the <strong>building</strong> entity (where it belongs),
        not the citizen</li>
  </ol>

  <p>This keeps citizen archetypes clean and avoids breaking <code>HealthcareDispatchSystem</code>
     or any other system that queries citizens.</p>

  <h3>General Rule</h3>

  <p>
    <strong>Never add components from one domain to entities of another domain:</strong>
  </p>

  <ul>
    <li>Do not add <code>Game.Buildings.*</code> components to citizen or vehicle entities</li>
    <li>Do not add <code>Game.Citizens.*</code> components to building or vehicle entities</li>
    <li>Do not add <code>Game.Vehicles.*</code> components to citizen or building entities</li>
  </ul>

  <p>
    If you need cross-domain relationships, use custom components in your mod's namespace and a
    bridging system that operates on the correct entity types.
  </p>

  <!-- ============================================================ -->
  <h2>RescueTarget Lifecycle</h2>

  <p>
    <code>RescueTarget</code> (<code>Game.Buildings</code>) is a component added to
    <strong>collapsed/destroyed buildings</strong> that need fire engine rescue crews. It is used
    exclusively for disaster rescue (not for active fires). The full lifecycle is managed by two systems:
    <code>CollapsedBuildingSystem</code> (creation and removal) and <code>FireEngineAISystem</code>
    (response behavior).
  </p>

  <h3>Lifecycle Stages</h3>

  <ol>
    <li>
      <strong>Created by CollapsedBuildingSystem:</strong> When a building is destroyed, the
      <code>Destroyed</code> component is added with <code>m_Cleared</code> starting negative (collapse
      animation). Once <code>m_Cleared</code> reaches 0, the system checks
      <code>BuildingFlags.RequireRoad</code>. Road-connected buildings get <code>RescueTarget</code>
      added and a <code>FireRescueRequest</code> created with type <code>Disaster</code> and priority
      <code>10f</code>. Non-road buildings skip rescue entirely (<code>m_Cleared</code> set to 1.0).
    </li>
    <li>
      <strong>Updated:</strong> <code>FireExtinguishingJob</code> updates <code>m_Request</code> to link
      the responding fire engine's request to the rescue target.
    </li>
    <li>
      <strong>Used:</strong> <code>FireEngineAISystem</code> checks for <code>RescueTarget</code> in two
      key methods:
      <ul>
        <li><code>BeginExtinguishing</code>: When a fire engine arrives at a target, checks
            <code>OnFire</code> first, then falls back to <code>RescueTarget</code> to determine behavior.</li>
        <li><code>SelectNextDispatch</code>: When selecting the next assignment, validates
            Disaster-type requests by checking <code>RescueTarget</code> is still present on the target.</li>
      </ul>
    </li>
    <li>
      <strong>Work performed:</strong> <code>FireEngineAISystem</code>'s
      <code>ObjectExtinguishIterator.TryExtinguish</code> checks for a <code>Destroyed</code> component
      with <code>m_Cleared &lt; 1.0</code> and advances clearing progress at rate
      <code>4/15 * clearRate</code> per tick. The engine stays until clearing is complete.
    </li>
    <li>
      <strong>Cleanup by CollapsedBuildingSystem:</strong> Every 64 frames, the system checks all entities
      with <code>RescueTarget</code>. If <code>Destroyed.m_Cleared &gt;= 1.0</code>, it removes the
      <code>RescueTarget</code> component. If <code>m_Cleared &lt; 1.0</code>, it re-creates the
      <code>FireRescueRequest</code> to keep fire engines coming until the job is done.
    </li>
  </ol>

  <p>
    <strong>Modding implication:</strong> If you add <code>RescueTarget</code> to an entity that is NOT a
    destroyed building, <code>CollapsedBuildingSystem</code> will NOT clean it up (the system only queries
    entities with <code>Destroyed</code>). Your mod must handle its own cleanup. A lingering
    <code>RescueTarget</code> will cause <code>FireRescueDispatchSystem</code> to consider fire rescue
    requests for that entity as valid even after the original event is over.
  </p>

  <!-- ============================================================ -->
  <h2>Fire Engine AI at Non-Fire RescueTarget</h2>

  <p>
    When a fire engine is dispatched to a <code>RescueTarget</code> entity that is NOT on fire, the
    following sequence occurs in <code>FireEngineAISystem.BeginExtinguishing</code>:
  </p>

  <ol>
    <li><strong>Arrival:</strong> The fire engine reaches the target (path end reached).</li>
    <li><strong>OnFire check:</strong> The system checks for <code>OnFire</code> first. If present, the
        engine enters the <strong>Extinguishing</strong> state.</li>
    <li><strong>RescueTarget fallback:</strong> If no <code>OnFire</code> but <code>RescueTarget</code>
        is present, the engine enters the <strong>Rescueing</strong> state (note: &quot;Rescueing&quot; is
        a typo in the game code, not &quot;Rescuing&quot;).</li>
    <li><strong>Vehicle stops:</strong> <code>StopVehicle</code> is called to halt the engine at the
        location.</li>
    <li><strong>TryExtinguishFire evaluation:</strong> The system calls <code>TryExtinguishFire</code>,
        which behaves differently depending on the entity state:
      <ul>
        <li>If the entity has the <code>Destroyed</code> component with <code>m_Cleared &lt; 1.0</code>:
            the engine advances rubble clearing progress at a rate of <code>4/15 * clearRate</code>.</li>
        <li>If the entity is NOT destroyed AND NOT on fire: <code>TryExtinguishFire</code> returns
            <code>false</code> immediately (nothing to do).</li>
      </ul>
    </li>
    <li><strong>Next dispatch:</strong> When <code>TryExtinguishFire</code> returns <code>false</code>,
        the engine calls <code>SelectNextDispatch</code> to find another assignment or returns to its
        station/depot.</li>
  </ol>

  <h3>Key Answer</h3>

  <p>
    At a non-fire, non-destroyed <code>RescueTarget</code>, the fire engine enters the
    <code>Rescueing</code> state, stops, calls <code>TryExtinguishFire</code> which finds nothing to do
    (no fire intensity to reduce, no rubble to clear), returns <code>false</code>, and the engine
    immediately moves on to the next dispatch or returns to the station.
    <strong>It does NOT idle indefinitely.</strong>
  </p>

  <p>
    This is important for mods that add <code>RescueTarget</code> to accident sites or other non-fire
    entities: the fire engine will arrive, briefly stop, determine there is nothing to do, and leave. If
    the goal is to have the fire engine perform some action at the scene, a Harmony patch on
    <code>TryExtinguishFire</code> or <code>BeginExtinguishing</code> would be needed to inject custom
    behavior.
  </p>

  <h3>Destroyed Entity Clearing</h3>

  <p>
    For entities that have the <code>Destroyed</code> component (e.g., collapsed buildings), the fire
    engine will actively clear rubble at a rate of <code>4/15 * clearRate</code> per tick. The engine stays
    until <code>m_Cleared &gt;= 1.0</code>. This is the intended use case for <code>RescueTarget</code>
    without <code>OnFire</code> -- rubble clearing at destroyed buildings.
  </p>

  <!-- ============================================================ -->
  <h2>Open Questions</h2>

  <ul>
    <li>How does the pathfinder match <code>SetupTargetType.PolicePatrol</code> to stations? Does it filter by PolicePurpose flags or only by distance?</li>
    <li>What happens if multiple requests exist for the same AccidentSite? The system checks <code>m_PoliceRequest</code> on AccidentSite -- does this prevent duplicates?</li>
    <li>How do reversed requests (station/vehicle proactively seeking work) interact with manually-created forward requests?</li>
    <li>Does <code>PolicePatrolDispatchSystem</code> ever create emergency-type responses, or is patrol strictly separate?</li>
  </ul>

  <h3>Answered Questions</h3>

  <ul>
    <li><strong>When <code>RescueTarget</code> is added manually to a non-burning entity, does the fire engine AI handle it correctly after arrival?</strong>
        Yes. The fire engine enters <code>Rescueing</code> state, stops, calls <code>TryExtinguishFire</code>.
        If the entity is not on fire and not destroyed, <code>TryExtinguishFire</code> returns <code>false</code>
        immediately and the engine moves on to its next dispatch or returns to the station. It does not idle
        indefinitely. See &quot;Fire Engine AI at Non-Fire RescueTarget&quot; section above.</li>
  </ul>

  <!-- ============================================================ -->
  <h2>Sources</h2>

  <ul>
    <li>Decompiled from: Game.dll -- Game.Simulation (ServiceRequest, ServiceDispatch, Dispatched, HandleRequest, RequestGroup, PoliceEmergencyRequest, FireRescueRequest, HealthcareRequest, ServiceRequestSystem, AccidentSiteSystem, PoliceEmergencyDispatchSystem, FireRescueDispatchSystem, HealthcareDispatchSystem, FireSimulationSystem, HealthProblemSystem, FireEngineAISystem, CollapsedBuildingSystem)</li>
    <li>Decompiled from: Game.dll -- Game.Events (AccidentSite, AccidentSiteFlags, OnFire, InvolvedInAccident)</li>
    <li>Decompiled from: Game.dll -- Game.Citizens (HealthProblem, HealthProblemFlags)</li>
    <li>Decompiled from: Game.dll -- Game.Prefabs (PolicePurpose), Game.Buildings (RescueTarget)</li>
  </ul>

    <footer>
      <p>Source: Decompiled from Game.dll (Cities: Skylines II) using ilspycmd v9.1. Game version as of 2026-02-15.</p>
      <div class="attribution-footer">
        <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
      </div>
    </footer>
    </main>

  </div>
</body>
</html>
