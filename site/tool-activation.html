<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tool Activation from Non-Update Contexts</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="top-bar">
  <a href="index.html" class="site-title">CS2 Modding Research</a>
  <span class="attribution">Generated with Claude | Supervised by repository owner</span>
</div>

<div class="page-layout">

    <aside class="sidebar">
    <h3>Events &amp; Simulation</h3>
    <a href="event-entity-archetype.html">Event Entity Archetype</a>
    <a href="fire-ignition.html">Fire Ignition</a>
    <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
    <a href="crime-trigger.html">Crime Trigger</a>
    <a href="citizen-sickness.html">Citizen Sickness</a>
    <a href="water-system.html">Water System</a>
    <a href="emergency-dispatch.html">Emergency Dispatch</a>
    <a href="disaster-simulation.html">Disaster Simulation</a>

    <h3>Infrastructure</h3>
    <a href="electricity-grid.html">Electricity Grid</a>
    <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
    <a href="road-network.html">Road &amp; Network Building</a>
    <a href="zoning.html">Zoning</a>
    <a href="pathfinding.html">Pathfinding</a>
    <a href="traffic-flow.html">Traffic Flow</a>

    <h3>Economy &amp; Population</h3>
    <a href="citizens-households.html">Citizens &amp; Households</a>
    <a href="economy-budget.html">Economy &amp; Budget</a>
    <a href="demand-systems.html">Demand Systems</a>
    <a href="resource-production.html">Resource Production</a>
    <a href="company-simulation.html">Company Simulation</a>
    <a href="workplace-labor.html">Workplace &amp; Labor</a>
    <a href="land-value-property.html">Land Value &amp; Property</a>
    <a href="trade-connections.html">Trade &amp; Connections</a>
    <a href="tourism-economy.html">Tourism Economy</a>
    <a href="cargo-transport.html">Cargo Transport</a>

    <h3>City Services</h3>
    <a href="garbage-collection.html">Garbage Collection</a>
    <a href="education.html">Education</a>
    <a href="public-transit.html">Public Transit</a>
    <a href="healthcare.html">Healthcare</a>
    <a href="deathcare.html">Deathcare</a>
    <a href="parks-recreation.html">Parks &amp; Recreation</a>
    <a href="police-dispatch.html">Police Dispatch</a>

    <h3>Governance</h3>
    <a href="districts-policies.html">Districts &amp; Policies</a>
    <a href="map-tile-purchase.html">Map Tile Purchase</a>

    <h3>Environment</h3>
    <a href="weather-climate.html">Weather &amp; Climate</a>
    <a href="pollution.html">Pollution</a>
    <a href="terrain-resources.html">Terrain &amp; Resources</a>

    <h3>Vehicles &amp; Transport</h3>
    <a href="vehicle-spawning.html">Vehicle Spawning</a>

    <h3>Tools &amp; Input</h3>
    <a href="tool-activation.html" class="active">Tool Activation</a>
    <a href="tool-raycast.html">Tool Raycast</a>
    <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
    <a href="mod-hotkey-input.html">Mod Hotkey Input</a>
    <a href="object-tool-system.html">Object Placement Tool</a>

    <h3>UI &amp; Settings</h3>
    <a href="mod-ui-buttons.html">Mod UI Buttons</a>
    <a href="mod-options-ui.html">Mod Options UI</a>
    <a href="info-views-overlays.html">Info Views &amp; Overlays</a>
    <a href="chirper-notifications.html">Chirper Notifications</a>

    <h3>Modding Framework</h3>
    <a href="save-load-persistence.html">Save/Load Persistence</a>
    <a href="prefab-system.html">Prefab System</a>
    <a href="localization.html">Localization</a>
    <a href="harmony-transpilers.html">Harmony Transpilers</a>
    <a href="mod-loading-dependencies.html">Mod Loading</a>
  </aside>

  <main class="content">

  <h1>Tool Activation from Non-Update Contexts</h1>

  <div class="scope">
    <h2>Scope</h2>
    <p>
      <strong>Question:</strong> Is it safe to set <code>ToolSystem.activeTool</code> from outside the
      normal <code>ToolUpdate</code> phase -- for example, from a <code>TriggerBinding</code> callback
      triggered by a UI button?
    </p>
    <p>
      <strong>Verdict:</strong> Yes. Setting <code>activeTool</code> from a TriggerBinding callback is
      fully safe. No deferral pattern is needed. This matches how the vanilla game works.
    </p>
    <p>
      <strong>Out of scope:</strong> Tool behavior after activation, input binding setup, and tool UI rendering.
    </p>
  </div>

  <!-- ============================================================ -->
  <h2>How It Works</h2>

  <p>
    When a mod needs to activate a custom tool, it typically does so from a UI callback --
    a <code>TriggerBinding</code> that fires when the player clicks a button. The concern is whether
    this can cause race conditions, since the callback runs outside the ECS tool update phase.
  </p>

  <p>
    The short answer: CS2 is single-threaded. TriggerBinding callbacks fire on the Unity main thread.
    There is no concurrent access, and the setter writes its value immediately. Let's trace through exactly
    what happens.
  </p>

  <h3>The activeTool Setter</h3>

  <p>When you assign <code>activeTool</code>, three things happen synchronously:</p>

  <pre><code class="language-csharp">public ToolBaseSystem activeTool
{
    set
    {
        if (value != m_ActiveTool)
        {
            m_ActiveTool = value;           // 1. writes field immediately
            RequireFullUpdate();            // 2. sets update flag
            EventToolChanged?.Invoke(value); // 3. fires delegates synchronously
        }
    }
}</code></pre>

  <p>
    Step 1 is the key insight: the backing field is overwritten right away, on the calling thread.
    There is no queue, no deferred buffer. The new tool is the active tool the instant you set it.
  </p>

  <h3>The RequireFullUpdate() Branch</h3>

  <p>
    Step 2 has a branching path that depends on <em>when</em> the setter is called.
    <code>RequireFullUpdate()</code> checks whether the ToolSystem is currently mid-update:
  </p>

  <pre><code class="language-csharp">public void RequireFullUpdate()
{
    if (m_IsUpdating)
        m_FullUpdateRequired = true;    // deferred: flushed at end of OnUpdate
    else
        fullUpdateRequired = true;      // immediate: written to public property
}</code></pre>

  <p>
    From a TriggerBinding callback, <code>m_IsUpdating</code> is always <code>false</code> (callbacks
    run outside <code>OnUpdate</code>). So it takes the <code>else</code> branch and writes the flag
    directly. Either way, the net result is the same: <code>fullUpdateRequired</code> is <code>true</code>
    before the next frame.
  </p>

  <h3>How ToolUpdate() Detects the Change</h3>

  <p>
    Here is the important part: <code>ToolUpdate()</code> does <strong>not</strong> rely on the
    <code>fullUpdateRequired</code> flag to detect tool switches. It compares the current tool against
    the last-known tool every frame:
  </p>

  <pre><code class="language-csharp">private void ToolUpdate()
{
    if (activeTool != m_LastTool)
    {
        if (m_LastTool != null)
        {
            m_LastTool.Enabled = false;   // disable old tool
            m_LastTool.Update();          // final cleanup update
        }
        m_LastTool = activeTool;          // commit the change
    }

    if (m_LastTool != null)
        m_LastTool.Enabled = true;        // enable new tool

    m_UpdateSystem.Update(SystemUpdatePhase.ToolUpdate);
}</code></pre>

  <p>
    Since the setter already wrote <code>m_ActiveTool</code> synchronously, <code>ToolUpdate()</code>
    will see the new value on its next invocation -- no matter when the setter was called.
  </p>

  <!-- ============================================================ -->
  <h2>Data Flow</h2>

  <div class="diagram">
<pre>
  UI Button Click
       |
       v
  TriggerBinding callback         (Unity main thread, outside OnUpdate)
       |
       +---> m_ActiveTool = newTool        [immediate write]
       +---> fullUpdateRequired = true     [m_IsUpdating is false]
       +---> EventToolChanged.Invoke()     [UI subscribers update]
       |
       ~  (frame boundary)  ~
       |
       v
  ToolSystem.OnUpdate()
       |
       v
  ToolUpdate()
       |
       +---> activeTool != m_LastTool?   --YES-->  disable old tool
       |                                           m_LastTool = newTool
       v
  m_LastTool.Enabled = true
       |
       v
  SystemUpdatePhase.ToolUpdate           (new tool's OnUpdate runs)
</pre>
  </div>

  <!-- ============================================================ -->
  <h2>Key Components</h2>

  <table>
    <thead>
      <tr>
        <th>Assembly</th>
        <th>Namespace</th>
        <th>What's There</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Game.dll</td>
        <td>Game.Tools</td>
        <td>ToolSystem, ToolBaseSystem</td>
      </tr>
      <tr>
        <td>Colossal.UI.Binding.dll</td>
        <td>Colossal.UI.Binding</td>
        <td>TriggerBinding, RawTriggerBindingBase</td>
      </tr>
    </tbody>
  </table>

  <h3>Risk Assessment</h3>

  <table>
    <thead>
      <tr>
        <th>Concern</th>
        <th>Risk</th>
        <th>Why</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Thread safety of <code>m_ActiveTool</code> write</td>
        <td>None</td>
        <td>CS2 is single-threaded. Callbacks fire on the Unity main thread.</td>
      </tr>
      <tr>
        <td><code>RequireFullUpdate()</code> with <code>m_IsUpdating = false</code></td>
        <td>None</td>
        <td>Takes the <code>else</code> branch, writes directly. Same net result.</td>
      </tr>
      <tr>
        <td><code>ToolUpdate()</code> missing the change</td>
        <td>None</td>
        <td>Checks <code>activeTool != m_LastTool</code> every frame.</td>
      </tr>
      <tr>
        <td><code>EventToolChanged</code> subscribers outside ToolUpdate</td>
        <td>Low</td>
        <td>Subscribers are typically UI systems doing panel updates.</td>
      </tr>
      <tr>
        <td>ECS structural changes from subscribers</td>
        <td>Conditional</td>
        <td>Safe unless a subscriber performs structural changes while a job is scheduled.</td>
      </tr>
    </tbody>
  </table>

  <!-- ============================================================ -->
  <h2>Vanilla Precedent</h2>

  <p>
    The game itself calls <code>activeTool</code> from outside <code>ToolUpdate</code> all the time.
    For example, <code>ActivatePrefabTool()</code> is called from UI events and input callbacks:
  </p>

  <pre><code class="language-csharp">public bool ActivatePrefabTool(PrefabBase prefab)
{
    ...
    activeTool = tool;   // same setter, called from outside ToolUpdate
    return true;
}</code></pre>

  <p>
    This confirms that Colossal Order considers setting <code>activeTool</code> from outside
    <code>ToolUpdate</code> to be the normal usage pattern.
  </p>

  <!-- ============================================================ -->
  <h2>Examples</h2>

  <h3>Activate a Custom Tool from a UI Button</h3>

  <p>The most common pattern. A TriggerBinding switches the active tool when the player clicks a button.</p>

  <pre><code class="language-csharp">public partial class MyToolUISystem : UISystemBase
{
    private const string kGroup = "myMod";

    private ToolSystem _toolSystem;
    private MyCustomToolSystem _myTool;

    protected override void OnCreate()
    {
        base.OnCreate();

        _toolSystem = World.GetOrCreateSystemManaged&lt;ToolSystem&gt;();
        _myTool = World.GetOrCreateSystemManaged&lt;MyCustomToolSystem&gt;();

        AddBinding(new TriggerBinding(kGroup, "ActivateMyTool", () =&gt;
        {
            _toolSystem.activeTool = _myTool;
        }));
    }
}</code></pre>

  <h3>Toggle Between Custom and Default Tool</h3>

  <p>Switch to your tool if inactive, or back to the default tool if already active.</p>

  <pre><code class="language-csharp">public partial class ToggleToolUISystem : UISystemBase
{
    private const string kGroup = "myMod";

    private ToolSystem _toolSystem;
    private MyCustomToolSystem _myTool;
    private DefaultToolSystem _defaultTool;

    protected override void OnCreate()
    {
        base.OnCreate();

        _toolSystem = World.GetOrCreateSystemManaged&lt;ToolSystem&gt;();
        _myTool = World.GetOrCreateSystemManaged&lt;MyCustomToolSystem&gt;();
        _defaultTool = World.GetOrCreateSystemManaged&lt;DefaultToolSystem&gt;();

        AddBinding(new TriggerBinding(kGroup, "ToggleMyTool", () =&gt;
        {
            if (_toolSystem.activeTool == _myTool)
                _toolSystem.activeTool = _defaultTool;
            else
                _toolSystem.activeTool = _myTool;
        }));
    }
}</code></pre>

  <h3>Listen for Tool Changes via EventToolChanged</h3>

  <p>
    Subscribe to <code>EventToolChanged</code> to update your UI whenever any tool becomes active,
    including changes made by other mods or the base game.
  </p>

  <pre><code class="language-csharp">public partial class ToolStateUISystem : UISystemBase
{
    private const string kGroup = "myMod";

    private ToolSystem _toolSystem;
    private MyCustomToolSystem _myTool;
    private ValueBinding&lt;bool&gt; _isMyToolActiveBinding;

    protected override void OnCreate()
    {
        base.OnCreate();

        _toolSystem = World.GetOrCreateSystemManaged&lt;ToolSystem&gt;();
        _myTool = World.GetOrCreateSystemManaged&lt;MyCustomToolSystem&gt;();

        _isMyToolActiveBinding = new ValueBinding&lt;bool&gt;(kGroup, "IsMyToolActive", false);
        AddBinding(_isMyToolActiveBinding);

        _toolSystem.EventToolChanged += OnToolChanged;
    }

    private void OnToolChanged(ToolBaseSystem newTool)
    {
        _isMyToolActiveBinding.Update(newTool == _myTool);
    }

    protected override void OnDestroy()
    {
        _toolSystem.EventToolChanged -= OnToolChanged;
        base.OnDestroy();
    }
}</code></pre>

  <h3>Activate a Tool via Prefab (Vanilla Pattern)</h3>

  <p>
    Use <code>ActivatePrefabTool()</code> when you want the game to find the right tool for a given
    prefab. This iterates over all registered <code>ToolBaseSystem</code> instances and sets
    <code>activeTool</code> to the first one that accepts the prefab.
  </p>

  <pre><code class="language-csharp">public void ActivateToolForPrefab(ToolSystem toolSystem, PrefabBase prefab)
{
    bool activated = toolSystem.ActivatePrefabTool(prefab);

    if (!activated)
    {
        Mod.Log.Info($"No tool accepted prefab '{prefab.name}', fell back to default tool.");
    }
}</code></pre>

  <h3>Example 5: Guard Pattern for ActivatePrefabTool (FindIt Pattern)</h3>
  <p>Check <code>activePrefab</code> before calling <code>ActivatePrefabTool</code> to avoid redundant switches.
  Use a flag to distinguish mod-initiated changes from user actions:</p>

  <pre><code>private bool _settingPrefab;

internal void TryActivatePrefabTool(PrefabBase prefab)
{
    if (prefab != null &amp;&amp; _toolSystem.activePrefab != prefab)
    {
        _settingPrefab = true;
        _toolSystem.ActivatePrefabTool(prefab);
        _settingPrefab = false;
    }
}

private void OnPrefabChanged(PrefabBase prefab)
{
    if (_settingPrefab) return; // We initiated this, ignore
    // User changed prefab via vanilla UI -- update mod state
}</code></pre>

  <h3>Example 6: ToolbarUISystem.Apply Postfix for Theme Tracking</h3>
  <p>Patch <code>ToolbarUISystem.Apply</code> to detect toolbar theme/category changes:</p>

  <pre><code>[HarmonyPatch(typeof(Game.UI.InGame.ToolbarUISystem), "Apply")]
public static class ToolbarApplyPatch
{
    // Apply(List&lt;Entity&gt; themes, List&lt;Entity&gt; packs,
    //   Entity assetMenuEntity, Entity assetCategoryEntity,
    //   Entity assetEntity, bool updateTool)
    static void Postfix(List&lt;Entity&gt; themes, Entity assetEntity)
    {
        if (themes.Count != _lastThemeCount)
        {
            _lastThemeCount = themes.Count;
            UpdateSelectionSet = true;
        }
    }
}</code></pre>

  <!-- ============================================================ -->
  <h2>toolID Spoofing for Custom Sub-Tools</h2>

  <p>
    Custom tools can return another tool's <code>toolID</code> to appear as that tool to the game's
    UI system. This is useful when a mod provides alternative behavior for an existing tool category.
    The game's UI checks <code>activeTool.toolID</code> to decide which panels, overlays, and toolbar
    states to show.
  </p>

  <pre><code class="language-csharp">// BetterBulldozer pattern: custom tool impersonates the vanilla bulldozer
public class SubElementBulldozerTool : ToolBaseSystem
{
    private BulldozeToolSystem m_BulldozeToolSystem;

    // Return the vanilla bulldozer's toolID so the UI shows the bulldozer
    // panel, toolbar highlight, etc. as if the vanilla tool were active.
    public override string toolID =&gt; m_BulldozeToolSystem.toolID;

    // ...custom raycast and behavior logic...
}</code></pre>

  <p>
    This pattern is used by BetterBulldozer to provide sub-element bulldozing and vehicle/citizen
    removal while keeping the bulldozer UI active.
  </p>

  <h2>ToolSystem.tools -- Mutable Tool Registration List</h2>

  <p>
    <code>ToolSystem.tools</code> is a <code>List&lt;ToolBaseSystem&gt;</code> that is <strong>mutable
    at runtime</strong>. The game populates it with vanilla tools, and mods can add their own tools
    to it. The list's iteration order matters for <code>ActivatePrefabTool()</code>, which iterates
    <code>tools</code> and calls <code>TrySetPrefab()</code> on each -- the first tool that returns
    <code>true</code> wins.
  </p>

  <pre><code class="language-csharp">// ToolSystem field
public List&lt;ToolBaseSystem&gt; tools;

// ActivatePrefabTool iterates the list
public bool ActivatePrefabTool(PrefabBase prefab)
{
    foreach (ToolBaseSystem tool in tools)
    {
        if (tool.TrySetPrefab(prefab))
        {
            activeTool = tool;
            return true;
        }
    }
    return false;
}</code></pre>

  <p>
    Mods that want their tool to handle certain prefabs (before vanilla tools) should insert at the
    beginning of the list. Mods that add fallback behavior can append to the end.
  </p>

  <h2>EventPrefabChanged and activePrefab</h2>

  <p>
    <code>ToolSystem</code> exposes <code>activePrefab</code> (read-only, returns
    <code>activeTool.GetPrefab()</code>) and fires <code>EventPrefabChanged</code> when the prefab
    changes. Mods can subscribe to this event to react to prefab selection:
  </p>

  <pre><code class="language-csharp">// ToolSystem events
public event Action&lt;ToolBaseSystem&gt; EventToolChanged;
public event Action&lt;PrefabBase&gt; EventPrefabChanged;

// activePrefab property
public PrefabBase activePrefab =&gt; activeTool?.GetPrefab();</code></pre>

  <p>
    <code>EventPrefabChanged</code> fires during <code>ToolUpdate()</code> when the current tool's
    <code>GetPrefab()</code> returns a different value than last frame. Both
    <code>EventToolChanged</code> and <code>EventPrefabChanged</code> subscribers may do more than
    UI updates -- Anarchy's systems check <code>activeTool.toolID</code> and
    <code>activePrefab</code> in these handlers to conditionally enable/disable features.
  </p>

  <h3>Reactivating a Custom Tool on Prefab Change</h3>

  <p>
    Subscribe to <code>ToolSystem.EventPrefabChanged</code> to reactivate a custom tool when the user
    selects a different prefab via the toolbar. Use a deferred flag rather than setting
    <code>activeTool</code> directly inside the event handler to avoid re-entrant tool switching:
  </p>

  <pre><code class="language-csharp">public partial class CustomPlacementToolSystem : ToolBaseSystem
{
    public override string toolID =&gt; "Custom Placement Tool";

    private ToolSystem _toolSystem;
    private bool _reactivateNextFrame;

    [Preserve]
    protected override void OnCreate()
    {
        base.OnCreate();
        _toolSystem = World.GetOrCreateSystemManaged&lt;ToolSystem&gt;();
        _toolSystem.EventPrefabChanged += OnPrefabChanged;
    }

    private void OnPrefabChanged(PrefabBase newPrefab)
    {
        // Only react if our tool lost focus due to prefab change
        if (_toolSystem.activeTool != this &amp;&amp; newPrefab != null)
        {
            // Don't set activeTool here -- we're inside event dispatch.
            // Defer to next frame to avoid re-entrant EventToolChanged.
            _reactivateNextFrame = true;
        }
    }

    [Preserve]
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        if (_reactivateNextFrame)
        {
            _reactivateNextFrame = false;
            _toolSystem.activeTool = this;
        }
        // ... normal tool logic ...
        return inputDeps;
    }

    public override PrefabBase GetPrefab() =&gt; _toolSystem.activePrefab;
    public override bool TrySetPrefab(PrefabBase prefab) =&gt; false;

    [Preserve]
    protected override void OnDestroy()
    {
        _toolSystem.EventPrefabChanged -= OnPrefabChanged;
        base.OnDestroy();
    }
}</code></pre>

  <p>
    <strong>Key pattern:</strong> Setting <code>activeTool</code> inside <code>EventPrefabChanged</code>
    is technically safe (single-threaded), but causes re-entrant event dispatch --
    <code>EventToolChanged</code> fires while <code>EventPrefabChanged</code> subscribers are still
    running. The deferred flag avoids this by waiting until the next <code>OnUpdate</code>.
  </p>

  <!-- ============================================================ -->
  <h2>EventToolChanged Subscription</h2>

  <p>
    Subscribe to <code>ToolSystem.EventToolChanged</code> for systems that should only run when
    a specific tool is active. More efficient than checking tool state every frame:
  </p>

  <pre><code class="language-csharp">protected override void OnCreate()
{
    Enabled = false;
    m_ToolSystem.EventToolChanged += (ToolBaseSystem tool) =&gt;
        Enabled = tool == m_ObjectToolSystem
               || (tool.toolID != null &amp;&amp; tool.toolID == "Line Tool");
}</code></pre>

  <h2>EntityCommandBuffer Barrier Selection</h2>

  <table>
    <thead>
      <tr><th>Barrier</th><th>When to Use</th></tr>
    </thead>
    <tbody>
      <tr><td><code>EndFrameBarrier</code></td><td>Simulation-phase systems (GameSimulation, ModificationEnd)</td></tr>
      <tr><td><code>ToolOutputBarrier</code></td><td>Tool-phase systems (ToolUpdate)</td></tr>
    </tbody>
  </table>

  <p>
    Rule: use the barrier that matches your system's update phase. For parallel jobs, use
    <code>CreateCommandBuffer().AsParallelWriter()</code> and call
    <code>barrier.AddJobHandleForProducer(jobHandle)</code>.
  </p>

  <h2>Open Questions</h2>

  <p>All questions from this research have been resolved:</p>

  <ul>
    <li><strong>Is activeTool safe to set from TriggerBinding callbacks?</strong> -- Yes, fully safe.</li>
    <li><strong>Does RequireFullUpdate() behave differently outside OnUpdate?</strong> -- Different branch, same outcome.</li>
    <li><strong>Does ToolUpdate() rely on a flag to detect tool changes?</strong> -- No, it checks <code>activeTool != m_LastTool</code> directly.</li>
    <li><strong>Are EventToolChanged subscribers phase-dependent?</strong> -- No, they are UI-focused.</li>
  </ul>

  <!-- ============================================================ -->
  <h2>ModificationBarrier Pattern</h2>

  <table>
    <thead><tr><th>Barrier</th><th>Phase</th><th>Use When</th></tr></thead>
    <tbody>
      <tr><td><code>ModificationBarrier4B</code></td><td>Modification4B</td><td>Systems in Modification4</td></tr>
      <tr><td><code>ModificationBarrier5</code></td><td>Modification5</td><td>Systems in Modification5</td></tr>
      <tr><td><code>ToolOutputBarrier</code></td><td>After tool phases</td><td>Tool systems</td></tr>
      <tr><td><code>EndFrameBarrier</code></td><td>End of frame</td><td>General-purpose</td></tr>
    </tbody>
  </table>

  <pre><code class="language-csharp">m_Barrier = World.GetOrCreateSystemManaged&lt;ModificationBarrier4B&gt;();
var ecb = m_Barrier.CreateCommandBuffer().AsParallelWriter();
// Schedule job using ecb...
m_Barrier.AddJobHandleForProducer(Dependency);</code></pre>

  <h2>OverlayRenderSystem for Custom Overlays</h2>

  <p>
    Register a system at <code>SystemUpdatePhase.Rendering</code> and use
    <code>OverlayRenderSystem.GetBuffer()</code> for drawing custom overlays:
  </p>

  <pre><code class="language-csharp">public partial class CustomOverlaySystem : GameSystemBase
{
    private OverlayRenderSystem m_OverlayRenderSystem;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_OverlayRenderSystem = World.GetOrCreateSystemManaged&lt;OverlayRenderSystem&gt;();
    }

    protected override void OnUpdate()
    {
        var buffer = m_OverlayRenderSystem.GetBuffer(out var dependencies);
        dependencies.Complete();

        // Draw shapes
        buffer.DrawCircle(color, outlineColor, 0f, styleFlags,
            new float2(0f, 1f), position, radius);
        buffer.DrawLine(color, outlineColor, 0f, styleFlags,
            new Line3.Segment(start, end), width, 1f);
        buffer.DrawDashedLine(color, outlineColor, 0f, styleFlags,
            line, width, dashLength, gapLength);

        m_OverlayRenderSystem.AddBufferWriter(Dependency);
    }
}</code></pre>

  <p>
    <strong>Key details:</strong> Use <code>RenderingSettingsData</code> singleton for game-consistent
    colors. For performance, use <code>[BurstCompile]</code> IJob with <code>Allocator.TempJob</code>.
    Register at <code>SystemUpdatePhase.Rendering</code>.
  </p>

  <h2>Custom ToolBaseSystem (Picker)</h2>

  <pre><code class="language-csharp">public partial class PickerToolSystem : ToolBaseSystem
{
    public override string toolID =&gt; "Picker Tool";

    public override void InitializeRaycast()
    {
        base.InitializeRaycast();
        m_ToolRaycastSystem.collisionMask = CollisionMask.Overground
            | CollisionMask.OnGround | CollisionMask.Underground;
        m_ToolRaycastSystem.typeMask |= TypeMask.StaticObjects | TypeMask.Net;
        m_ToolRaycastSystem.netLayerMask = Layer.All;
    }
    // Highlight via Highlighted + BatchesUpdated, traverse Owner for root
}</code></pre>

  <!-- ============================================================ -->
  <h2>Sources</h2>

  <ul>
    <li>Decompiled from: Game.dll (Game.Tools.ToolSystem), Colossal.UI.Binding.dll (TriggerBinding, RawTriggerBindingBase)</li>
    <li>Related research: ToolRaycast (ToolSystem architecture), ModUIButtons (TriggerBinding usage)</li>
  </ul>

  <footer>
    <p>Source: Decompiled from Game.dll (Game.Tools.ToolSystem), Colossal.UI.Binding.dll (TriggerBinding, RawTriggerBindingBase)</p>
    <div class="attribution-footer">
      <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
    </div>
  </footer>

  </main>

</div>

</body>
</html>
