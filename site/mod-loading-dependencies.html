<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mod Loading &amp; Dependencies</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="top-bar">
  <a href="index.html" class="site-title">CS2 Modding Research</a>
  <span class="attribution">Generated with Claude | Supervised by repository owner</span>
</div>

<div class="page-layout">

    <aside class="sidebar">
    <h3>Events &amp; Simulation</h3>
    <a href="event-entity-archetype.html">Event Entity Archetype</a>
    <a href="fire-ignition.html">Fire Ignition</a>
    <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
    <a href="crime-trigger.html">Crime Trigger</a>
    <a href="citizen-sickness.html">Citizen Sickness</a>
    <a href="water-system.html">Water System</a>
    <a href="emergency-dispatch.html">Emergency Dispatch</a>
    <a href="disaster-simulation.html">Disaster Simulation</a>

    <h3>Infrastructure</h3>
    <a href="electricity-grid.html">Electricity Grid</a>
    <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
    <a href="road-network.html">Road &amp; Network Building</a>
    <a href="zoning.html">Zoning</a>
    <a href="building-construction.html">Building Construction</a>
    <a href="pathfinding.html">Pathfinding</a>
    <a href="traffic-flow.html">Traffic Flow</a>

    <h3>Economy &amp; Population</h3>
    <a href="citizens-households.html">Citizens &amp; Households</a>
    <a href="economy-budget.html">Economy &amp; Budget</a>
    <a href="demand-systems.html">Demand Systems</a>
    <a href="resource-production.html">Resource Production</a>
    <a href="company-simulation.html">Company Simulation</a>
    <a href="workplace-labor.html">Workplace &amp; Labor</a>
    <a href="land-value-property.html">Land Value &amp; Property</a>
    <a href="trade-connections.html">Trade &amp; Connections</a>
    <a href="tourism-economy.html">Tourism Economy</a>
    <a href="cargo-transport.html">Cargo Transport</a>

    <h3>City Services</h3>
    <a href="garbage-collection.html">Garbage Collection</a>
    <a href="education.html">Education</a>
    <a href="public-transit.html">Public Transit</a>
    <a href="healthcare.html">Healthcare</a>
    <a href="deathcare.html">Deathcare</a>
    <a href="parks-recreation.html">Parks &amp; Recreation</a>
    <a href="police-dispatch.html">Police Dispatch</a>

    <h3>Governance</h3>
    <a href="districts-policies.html">Districts &amp; Policies</a>
    <a href="map-tile-purchase.html">Map Tile Purchase</a>

    <h3>Environment</h3>
    <a href="weather-climate.html">Weather &amp; Climate</a>
    <a href="pollution.html">Pollution</a>
    <a href="terrain-resources.html">Terrain &amp; Resources</a>

    <h3>Vehicles &amp; Transport</h3>
    <a href="vehicle-spawning.html">Vehicle Spawning</a>
    <a href="parking-system.html">Parking System</a>

    <h3>Tools &amp; Input</h3>
    <a href="tool-activation.html">Tool Activation</a>
    <a href="tool-raycast.html">Tool Raycast</a>
    <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
    <a href="mod-hotkey-input.html">Mod Hotkey Input</a>
    <a href="object-tool-system.html">Object Placement Tool</a>

    <h3>UI &amp; Settings</h3>
    <a href="mod-ui-buttons.html">Mod UI Buttons</a>
    <a href="mod-options-ui.html">Mod Options UI</a>
    <a href="info-views-overlays.html">Info Views &amp; Overlays</a>
    <a href="chirper-notifications.html">Chirper Notifications</a>

    <h3>Modding Framework</h3>
    <a href="save-load-persistence.html">Save/Load Persistence</a>
    <a href="prefab-system.html">Prefab System</a>
    <a href="localization.html">Localization</a>
    <a href="harmony-transpilers.html">Harmony Transpilers</a>
    <a href="mod-loading-dependencies.html" class="active">Mod Loading</a>
  </aside>

  <main class="content">

  <h1>Mod Loading &amp; Dependencies</h1>

  <div class="scope">
    <h2>Scope</h2>
    <p>
      <strong>Question:</strong> How does CS2 discover, load, and initialize mods? What is the
      IMod lifecycle, how are dependencies resolved, and how do mods register their systems?
    </p>
    <p>
      <strong>Verdict:</strong> CS2 uses a <strong>ModManager</strong> class that scans the
      AssetDatabase for <code>ExecutableAsset</code> entries (mod DLLs). Each DLL is checked for
      <code>IMod</code> implementations. Dependencies are resolved via standard .NET assembly
      references -- if a reference cannot be found, the mod fails with
      <code>MissedDependenciesError</code>. On successful load, the mod's <code>OnLoad</code>
      method receives an <code>UpdateSystem</code> for registering custom ECS systems into
      specific update phases.
    </p>
    <p>
      <strong>Out of scope:</strong> Mod settings UI (see Mod Options UI), Harmony patching
      mechanics (see Harmony Transpilers).
    </p>
  </div>

  <!-- ============================================================ -->
  <h2>Relevant Assemblies &amp; Namespaces</h2>

  <table>
    <thead>
      <tr><th>Assembly</th><th>Namespace</th><th>What's there</th></tr>
    </thead>
    <tbody>
      <tr><td>Game.dll</td><td>Game.Modding</td><td>IMod, ModManager, ModSetting</td></tr>
      <tr><td>Game.dll</td><td>Game</td><td>UpdateSystem, SystemUpdatePhase, GameSystemBase</td></tr>
      <tr><td>Game.dll</td><td>Game.SceneFlow</td><td>GameManager (entry point orchestrator)</td></tr>
      <tr><td>Colossal.IO.AssetDatabase.dll</td><td>Colossal.IO.AssetDatabase</td><td>ExecutableAsset, AssetDatabase (mod discovery)</td></tr>
      <tr><td>Colossal.PSI.PdxSdk.dll</td><td>Colossal.PSI.PdxSdk</td><td>PdxSdkPlatform (PDX Mods integration)</td></tr>
    </tbody>
  </table>

  <!-- ============================================================ -->
  <h2>How It Works</h2>

  <h3>The IMod Interface</h3>

  <p>Every CS2 code mod must implement this interface:</p>

  <pre><code class="language-csharp">public interface IMod
{
    void OnLoad(UpdateSystem updateSystem);
    void OnDispose();
}</code></pre>

  <ul>
    <li><strong>OnLoad</strong> -- called once during game initialization. Use it to register
    systems, apply Harmony patches, and set up settings.</li>
    <li><strong>OnDispose</strong> -- called on game exit or mod disable. Clean up Harmony
    patches, unregister settings, release resources.</li>
  </ul>

  <h3>Loading Pipeline</h3>

  <p>The <code>ModManager</code> runs four phases during <code>Initialize()</code>:</p>

  <ol>
    <li><strong>RegisterMods</strong> -- scans <code>AssetDatabase.global</code> for
    <code>ExecutableAsset</code> entries. Each mod DLL gets a <code>ModInfo</code> object.</li>
    <li><strong>ResolveModAssets</strong> -- resolves assembly dependencies between mods using
    Cecil. Checks each reference against known assemblies. Mods with unresolvable references
    are marked <code>canBeLoaded = false</code>.</li>
    <li><strong>InitializeMods</strong> -- for each valid mod:
      <ul>
        <li>Loads the assembly via <code>ExecutableAsset.LoadAssembly()</code></li>
        <li>Calls <code>TypeManager.InitializeAdditionalTypes(assembly)</code> to register
        ECS types</li>
        <li>Finds all <code>IMod</code> implementations via reflection</li>
        <li>Creates instances and calls <code>OnLoad(updateSystem)</code></li>
      </ul>
    </li>
    <li><strong>InitializeUIModules</strong> -- registers UI module assets (HTML/JS mods
    that extend the game UI).</li>
  </ol>

  <h3>Mod States</h3>

  <table>
    <thead>
      <tr><th>State</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>Unknown</td><td>Initial state, not yet processed</td></tr>
      <tr><td>Loaded</td><td>Successfully loaded and OnLoad called</td></tr>
      <tr><td>Disposed</td><td>OnDispose called, cleaned up</td></tr>
      <tr><td>IsNotModWarning</td><td>DLL has no IMod implementation</td></tr>
      <tr><td>IsNotUniqueWarning</td><td>Duplicate mod detected</td></tr>
      <tr><td>MissedDependenciesError</td><td>Required assembly references missing</td></tr>
      <tr><td>LoadAssemblyError</td><td>Failed to load the mod DLL</td></tr>
      <tr><td>LoadAssemblyReferenceError</td><td>Failed to load a referenced DLL</td></tr>
      <tr><td>GeneralError</td><td>Other error during loading</td></tr>
    </tbody>
  </table>

  <h3>System Registration via UpdateSystem</h3>

  <p>
    The <code>UpdateSystem</code> passed to <code>OnLoad</code> provides methods to register
    custom systems into the game's update loop:
  </p>

  <table>
    <thead>
      <tr><th>Method</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td><code>UpdateAt&lt;T&gt;(phase)</code></td><td>Register system at a specific update phase</td></tr>
      <tr><td><code>UpdateBefore&lt;T&gt;(phase)</code></td><td>Register to update before others in the phase</td></tr>
      <tr><td><code>UpdateAfter&lt;T&gt;(phase)</code></td><td>Register to update after others in the phase</td></tr>
      <tr><td><code>UpdateBefore&lt;T, Other&gt;(phase)</code></td><td>Register before a specific other system</td></tr>
      <tr><td><code>UpdateAfter&lt;T, Other&gt;(phase)</code></td><td>Register after a specific other system</td></tr>
    </tbody>
  </table>

  <h3>ExecutableAsset</h3>

  <p>
    Represents a mod's DLL in the asset database. Key properties:
  </p>

  <table>
    <thead>
      <tr><th>Property</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td><code>isMod</code></td><td>Whether this asset contains an IMod implementation</td></tr>
      <tr><td><code>isReference</code></td><td>Whether this is a shared library (not a mod itself)</td></tr>
      <tr><td><code>isUnique</code></td><td>No duplicate exists</td></tr>
      <tr><td><code>canBeLoaded</code></td><td>All dependencies are resolved</td></tr>
      <tr><td><code>isLoaded</code></td><td>Assembly has been loaded</td></tr>
      <tr><td><code>isBursted</code></td><td>Has Burst-compiled code</td></tr>
      <tr><td><code>references</code></td><td>Dictionary of assembly references (name -&gt; resolved asset or null)</td></tr>
    </tbody>
  </table>

  <h3>ModSetting</h3>

  <p>
    Abstract base class for mod settings. Extends the game's <code>Setting</code> class.
  </p>

  <table>
    <thead>
      <tr><th>Property</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td><code>mod</code></td><td>IMod</td><td>Reference to the owning mod instance</td></tr>
      <tr><td><code>id</code></td><td>string</td><td>Unique ID: <code>{AssemblyName}.{Namespace}.{ClassName}</code></td></tr>
      <tr><td><code>name</code></td><td>string</td><td>Setting class name</td></tr>
      <tr><td><code>keyBindingRegistered</code></td><td>bool</td><td>Whether key bindings have been registered</td></tr>
    </tbody>
  </table>

  <p>Key methods:</p>
  <ul>
    <li><code>RegisterInOptionsUI()</code> -- adds settings to the game's options menu</li>
    <li><code>UnregisterInOptionsUI()</code> -- removes settings from options menu</li>
  </ul>

  <h3>ModManager</h3>

  <p>
    Central class that orchestrates all mod loading. It is a regular class (not an ECS system),
    implements <code>IDisposable</code>, and is owned by <code>GameManager.instance.modManager</code>.
  </p>

  <p>Key responsibilities:</p>
  <ol>
    <li>Discover mod DLLs via AssetDatabase</li>
    <li>Resolve assembly dependencies between mods</li>
    <li>Load assemblies and find IMod implementations</li>
    <li>Call <code>IMod.OnLoad</code> on each mod</li>
    <li>Handle errors and display notifications</li>
    <li>Register UI modules from UIModuleAsset entries</li>
  </ol>

  <h3>Key Update Phases</h3>

  <table>
    <thead>
      <tr><th>Phase</th><th>When it Runs</th><th>Use For</th></tr>
    </thead>
    <tbody>
      <tr><td>Modification1-5</td><td>Sequential modification passes</td><td>Entity modification systems</td></tr>
      <tr><td>Modification4B</td><td>Extended fourth pass</td><td>Post-Modification4 processing</td></tr>
      <tr><td>ModificationEnd</td><td>Final modification cleanup</td><td>End-of-modification cleanup</td></tr>
      <tr><td>PreSimulation</td><td>Before simulation tick</td><td>Pre-processing, data preparation</td></tr>
      <tr><td>GameSimulation</td><td>Main simulation tick</td><td>Core mod logic, ECS systems</td></tr>
      <tr><td>PostSimulation</td><td>After simulation tick</td><td>Post-processing, cleanup</td></tr>
      <tr><td>Rendering</td><td>Render frame</td><td>Custom rendering overlays</td></tr>
      <tr><td>Raycast</td><td>Raycast processing</td><td>Custom raycast systems</td></tr>
      <tr><td>PreTool / ToolUpdate / PostTool</td><td>Tool lifecycle phases</td><td>Custom tools</td></tr>
      <tr><td>ApplyTool / ClearTool</td><td>Tool result phases</td><td>Tool result application, state cleanup</td></tr>
      <tr><td>UIUpdate / UITooltip</td><td>UI data refresh</td><td>UI bindings, panel data, tooltips</td></tr>
      <tr><td>PrefabUpdate</td><td>Prefab system update</td><td>Prefab modifications</td></tr>
      <tr><td>Serialize / Deserialize</td><td>Save/load phases</td><td>Custom serialization, cleanup systems</td></tr>
      <tr><td>DebugGizmos</td><td>Debug visualization</td><td>Debug rendering overlays</td></tr>
    </tbody>
  </table>

  <h3>Type-Constrained System Ordering</h3>

  <p>
    The two-type-parameter variants <code>UpdateBefore&lt;T, TOther&gt;</code> and
    <code>UpdateAfter&lt;T, TOther&gt;</code> order your system relative to a specific vanilla
    system. Both must be in the same phase:
  </p>

  <pre><code class="language-csharp">// CustomLaneSystem runs before LaneSystem within Modification4
updateSystem.UpdateBefore&lt;CustomLaneSystem, Game.Net.LaneSystem&gt;(
    SystemUpdatePhase.Modification4);

// CustomOverlaySystem runs after OverlayRenderSystem within Rendering
updateSystem.UpdateAfter&lt;CustomOverlaySystem, Game.Rendering.OverlayRenderSystem&gt;(
    SystemUpdatePhase.Rendering);</code></pre>

  <!-- ============================================================ -->
  <h2>Data Flow</h2>

  <div class="diagram">
<pre>
GAME STARTUP
  GameManager creates ModManager(disabled: false)
        |
        v
  ModManager.Initialize(updateSystem)
        |
        v
  PHASE 1: RegisterMods()
    AssetDatabase scans for ExecutableAsset entries
    Each mod DLL -&gt; ModInfo { asset, state: Unknown }
        |
        v
  PHASE 2: ExecutableAsset.ResolveModAssets(typeof(IMod), assets)
    For each mod:
      Read assembly references via Cecil
      Resolve against game assemblies + other mods
      Set canBeLoaded = false if missing deps
        |
        v
  PHASE 3: InitializeMods(updateSystem)
    For each ModInfo where state == Unknown &amp;&amp; isRequired:
      Check: isMod? isUnique? canBeLoaded?
      LoadAssembly() -&gt; TypeManager.InitializeAdditionalTypes()
      reflection: assembly.GetTypesDerivedFrom&lt;IMod&gt;()
      For each IMod type:
        Create instance (FormatterServices)
        Call instance.OnLoad(updateSystem)
      State -&gt; Loaded
        |
        v
  PHASE 4: InitializeUIModules()
    Scan UIModuleAsset entries
    Register UI host locations
        |
        v
  MOD IS ACTIVE (systems run in registered phases)
        |
        v
  GAME SHUTDOWN: ModManager.Dispose()
    For each ModInfo: call OnDispose(), State -&gt; Disposed
</pre>
  </div>

  <!-- ============================================================ -->
  <h2>Examples</h2>

  <h3>Basic Mod Entry Point</h3>

  <p>Minimal IMod that registers one custom system.</p>

  <pre><code class="language-csharp">using Game;
using Game.Modding;
using Colossal.Logging;

public class MyMod : IMod
{
    internal static ILog Log = LogManager.GetLogger(nameof(MyMod))
        .SetShowsErrorsInUI(true);

    public void OnLoad(UpdateSystem updateSystem)
    {
        Log.Info("MyMod loaded");
        updateSystem.UpdateAt&lt;MyCustomSystem&gt;(
            SystemUpdatePhase.GameSimulation);
    }

    public void OnDispose()
    {
        Log.Info("MyMod disposed");
    }
}</code></pre>

  <h3>Mod with Harmony Patches</h3>

  <p>Apply and clean up Harmony patches properly.</p>

  <pre><code class="language-csharp">using Game;
using Game.Modding;
using HarmonyLib;

public class MyHarmonyMod : IMod
{
    private Harmony _harmony;

    public void OnLoad(UpdateSystem updateSystem)
    {
        _harmony = new Harmony("com.myname.mymod");
        _harmony.PatchAll(typeof(MyHarmonyMod).Assembly);

        updateSystem.UpdateAt&lt;MySystem&gt;(
            SystemUpdatePhase.GameSimulation);
    }

    public void OnDispose()
    {
        _harmony?.UnpatchAll("com.myname.mymod");
    }
}</code></pre>

  <h3>System Registration with Explicit Ordering</h3>

  <p>Register multiple systems with dependencies on game systems.</p>

  <pre><code class="language-csharp">public class MyMod : IMod
{
    public void OnLoad(UpdateSystem updateSystem)
    {
        // Run before simulation
        updateSystem.UpdateAt&lt;PreProcessSystem&gt;(
            SystemUpdatePhase.PreSimulation);

        // Run during simulation, after a specific game system
        updateSystem.UpdateAfter&lt;MySimSystem,
            Game.Simulation.StorageCompanySystem&gt;(
            SystemUpdatePhase.GameSimulation);

        // Run during UI update
        updateSystem.UpdateAt&lt;MyUISystem&gt;(
            SystemUpdatePhase.UIUpdate);
    }

    public void OnDispose() { }
}</code></pre>

  <h3>Mod with Settings</h3>

  <p>Register settings visible in the game's options menu.</p>

  <pre><code class="language-csharp">public class MyMod : IMod
{
    private MyModSettings _settings;

    public void OnLoad(UpdateSystem updateSystem)
    {
        _settings = new MyModSettings(this);
        _settings.RegisterInOptionsUI();

        GameManager.instance.localizationManager.AddSource(
            "en-US", new MyModLocale());
    }

    public void OnDispose()
    {
        _settings?.UnregisterInOptionsUI();
    }
}

public class MyModSettings : ModSetting
{
    [SettingsUISection("General")]
    public bool EnableFeature { get; set; } = true;

    [SettingsUISection("General")]
    [SettingsUISlider(min = 0.1f, max = 5.0f, step = 0.1f)]
    public float Multiplier { get; set; } = 1.0f;

    public MyModSettings(IMod mod) : base(mod) { }
}</code></pre>

  <h3>Access Mod Asset Information</h3>

  <p>Find the mod's installation path and metadata at runtime.</p>

  <pre><code class="language-csharp">public class MyMod : IMod
{
    public void OnLoad(UpdateSystem updateSystem)
    {
        var modManager = GameManager.instance.modManager;
        if (modManager.TryGetExecutableAsset(this, out var asset))
        {
            Log.Info($"Mod name: {asset.fullName}");
            Log.Info($"Mod path: {asset.path}");
            Log.Info($"Is local: {asset.isLocal}");

            string modDir = Path.GetDirectoryName(asset.path);
            string configPath = Path.Combine(modDir, "config.json");
        }
    }

    public void OnDispose() { }
}</code></pre>

  <h3>Find Mod Assembly Path via SearchFilter (Alternative)</h3>

  <p>
    An alternative to <code>TryGetExecutableAsset</code> for finding the mod's assembly path. Uses
    <code>SearchFilter&lt;ExecutableAsset&gt;</code> to query the asset database directly. This is
    useful when you don't have a reference to the <code>ModManager</code> or need to search for
    other mods' assets.
  </p>

  <pre><code class="language-csharp">using Colossal.IO.AssetDatabase;
using Game;
using Game.Modding;

public class MyMod : IMod
{
    public void OnLoad(UpdateSystem updateSystem)
    {
        // SearchFilter&lt;ExecutableAsset&gt; queries the AssetDatabase for
        // mod DLLs. Each result is an ExecutableAsset with path, name,
        // and metadata.
        foreach (var asset in AssetDatabase.global.GetAsset&lt;ExecutableAsset&gt;(
            SearchFilter&lt;ExecutableAsset&gt;.ByCondition(
                a =&gt; a.isLoaded &amp;&amp; a.isMod)))
        {
            if (asset.assembly == typeof(MyMod).Assembly)
            {
                string modPath = asset.path;
                string modDir = System.IO.Path.GetDirectoryName(modPath);
                Log.Info($"Mod directory: {modDir}");
                break;
            }
        }
    }

    public void OnDispose() { }
}</code></pre>

  <p><strong>When to use which approach:</strong></p>

  <ul>
    <li><strong><code>TryGetExecutableAsset</code></strong> -- simplest way to find your own mod's
    asset. Requires access to <code>GameManager.instance.modManager</code> and passes <code>this</code>
    (the IMod instance).</li>
    <li><strong><code>SearchFilter&lt;ExecutableAsset&gt;</code></strong> -- more flexible. Can search
    for any mod's assets by arbitrary conditions. Useful for inter-mod discovery or enumerating all
    loaded mods.</li>
  </ul>

  <!-- ============================================================ -->
  <h2>System Replacement Pattern</h2>

  <p>
    A common community modding pattern is to replace vanilla ECS systems entirely with custom
    implementations. This is more reliable than Harmony-patching complex systems with Burst-compiled
    jobs, since the jobs themselves cannot be patched.
  </p>

  <h3>Disabling Vanilla Systems</h3>

  <p>
    Any <code>GameSystemBase</code> can be disabled by setting <code>.Enabled = false</code>. The
    update loop skips disabled systems. Do this in <code>IMod.OnLoad()</code>:
  </p>

  <pre><code class="language-csharp">public void OnLoad(UpdateSystem updateSystem)
{
    // Disable the vanilla system
    var vanillaSystem = World.DefaultGameObjectInjectionWorld
        .GetOrCreateSystemManaged&lt;Game.Simulation.ResidentialDemandSystem&gt;();
    vanillaSystem.Enabled = false;

    // Register your replacement in the same phase
    updateSystem.UpdateAt&lt;CustomResidentialDemandSystem&gt;(
        SystemUpdatePhase.GameSimulation);
}</code></pre>

  <p>
    The replacement system should implement the same public interface (properties, methods)
    that other systems depend on. For example, replacing <code>ResidentialDemandSystem</code>
    means your replacement must expose <code>householdDemand</code>, <code>buildingDemand</code>,
    and <code>GetLowDensityDemandFactors()</code> because <code>ZoneSpawnSystem</code> and
    UI systems read these.
  </p>

  <h3>Registering Replacement Systems with UpdateAt</h3>

  <p>
    The replacement system must be registered in the same <code>SystemUpdatePhase</code> as the
    vanilla system it replaces. Use <code>UpdateAfter</code> or <code>UpdateBefore</code> if
    ordering relative to other systems matters:
  </p>

  <pre><code class="language-csharp">// Replace ZoneSpawnSystem with a custom version
updateSystem.UpdateBefore&lt;CustomZoneSpawnSystem,
    Game.Simulation.ZoneSpawnSystem&gt;(
    SystemUpdatePhase.GameSimulation);</code></pre>

  <h3>Full System Replacement: ResidentAISystem Example</h3>

  <p>
    Complex vanilla systems like <code>ResidentAISystem</code> use <code>NativeQueue</code>
    producer/consumer patterns internally. When replacing these, the replacement must replicate
    the queue interface so that other systems interacting with those queues continue to function:
  </p>

  <pre><code class="language-csharp">public class Mod : IMod
{
    public void OnLoad(UpdateSystem updateSystem)
    {
        // 1. Disable the vanilla system
        var vanillaSystem = World.DefaultGameObjectInjectionWorld
            .GetOrCreateSystemManaged&lt;Game.Simulation.ResidentAISystem&gt;();
        vanillaSystem.Enabled = false;

        // 2. Register replacement with explicit ordering
        updateSystem.UpdateAfter&lt;CustomResidentAISystem,
            Game.Simulation.ResidentAISystem&gt;(
            SystemUpdatePhase.GameSimulation);
    }
}

public partial class CustomResidentAISystem : GameSystemBase
{
    // Replicate the NativeQueue producer/consumer interface
    // that other systems (e.g., HouseholdBehaviorSystem) write to
    private NativeQueue&lt;SetupQueueItem&gt; m_SetupQueue;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_SetupQueue = new NativeQueue&lt;SetupQueueItem&gt;(Allocator.Persistent);
    }

    protected override void OnDestroy()
    {
        m_SetupQueue.Dispose();
        base.OnDestroy();
    }

    // Expose the queue writer so producer systems can enqueue work
    public NativeQueue&lt;SetupQueueItem&gt;.ParallelWriter GetSetupQueueWriter()
        =&gt; m_SetupQueue.AsParallelWriter();

    protected override void OnUpdate()
    {
        // Drain the queue and process items
        while (m_SetupQueue.TryDequeue(out var item))
        {
            // Custom processing logic replacing vanilla behavior
        }
    }
}</code></pre>

  <h3>Disabling with Enabled=false in OnCreate</h3>

  <p>
    An alternative to disabling vanilla systems in <code>IMod.OnLoad()</code> is to disable them
    from within the replacement system's <code>OnCreate()</code>. This keeps the disable logic
    co-located with the replacement:
  </p>

  <pre><code class="language-csharp">public partial class CustomZoneSpawnSystem : GameSystemBase
{
    protected override void OnCreate()
    {
        base.OnCreate();

        // Disable the vanilla system from within the replacement
        var vanillaSystem = World.DefaultGameObjectInjectionWorld
            .GetOrCreateSystemManaged&lt;Game.Simulation.ZoneSpawnSystem&gt;();
        vanillaSystem.Enabled = false;
    }

    protected override void OnUpdate()
    {
        // Replacement logic
    }
}

// In IMod.OnLoad -- register with UpdateAfter to maintain ordering
updateSystem.UpdateAfter&lt;CustomZoneSpawnSystem,
    Game.Simulation.ZoneSpawnSystem&gt;(SystemUpdatePhase.GameSimulation);</code></pre>

  <h3>Handling Inner Systems</h3>

  <p>
    Some vanilla systems contain inner system classes that must also be disabled. Check the
    decompiled source for nested <code>GameSystemBase</code> subclasses:
  </p>

  <pre><code class="language-csharp">protected override void OnCreate()
{
    base.OnCreate();

    // Disable main system
    var mainSystem = World.DefaultGameObjectInjectionWorld
        .GetOrCreateSystemManaged&lt;Game.Simulation.SomeSystem&gt;();
    mainSystem.Enabled = false;

    // Also disable inner systems that the main system delegates to
    var innerSystem = World.DefaultGameObjectInjectionWorld
        .GetOrCreateSystemManaged&lt;Game.Simulation.SomeSystem.InnerUpdateSystem&gt;();
    innerSystem.Enabled = false;
}</code></pre>

  <h3>When NOT to Use Enabled=false Replacement</h3>

  <p>The full system replacement pattern is not always appropriate:</p>

  <ul>
    <li><strong>Simple calculation tweaks</strong>: If you only need to change one formula or constant, a Harmony patch is simpler than reimplementing the entire system</li>
    <li><strong>UI-only modifications</strong>: Patching a UI method is lower risk than replacing the whole UI system</li>
    <li><strong>Systems with many dependents</strong>: If dozens of other systems read from the vanilla system's public properties, replicating the entire interface is error-prone</li>
    <li><strong>Frequently updated systems</strong>: Vanilla systems that change every game patch require constant maintenance of the full replacement</li>
  </ul>

  <h3>Harmony Prefix as System Replacement Alternative</h3>

  <p>
    Instead of disabling vanilla systems in <code>OnLoad</code> or <code>OnCreate</code>, a Harmony
    prefix on <code>OnUpdate</code> can both disable the system and skip execution in a single patch:
  </p>

  <pre><code class="language-csharp">[HarmonyPatch(typeof(Game.Simulation.SomeVanillaSystem), "OnUpdate")]
public static class SomeVanillaSystemPatch
{
    public static bool Prefix(Game.Simulation.SomeVanillaSystem __instance)
    {
        // Disable the system so it won't be scheduled again
        __instance.Enabled = false;
        // Return false to skip the original OnUpdate execution
        return false;
    }
}</code></pre>

  <p><strong>Trade-offs vs Enabled=false in OnLoad:</strong></p>

  <table>
    <thead>
      <tr><th>Aspect</th><th>Harmony Prefix</th><th>Enabled=false in OnLoad</th></tr>
    </thead>
    <tbody>
      <tr><td>Timing</td><td>Runs on first OnUpdate tick</td><td>Runs before any simulation</td></tr>
      <tr><td>First frame</td><td>Vanilla system runs once before patch fires</td><td>Never runs</td></tr>
      <tr><td>Dependencies</td><td>Requires Harmony library</td><td>No extra dependencies</td></tr>
      <tr><td>Discoverability</td><td>Patch is in a separate class</td><td>Disable logic is in OnLoad</td></tr>
      <tr><td>Reversibility</td><td>Can unpatch cleanly</td><td>Must re-enable manually</td></tr>
    </tbody>
  </table>

  <p>
    Use the Harmony prefix approach when you need the vanilla system to complete its first
    <code>OnCreate</code>/<code>OnUpdate</code> cycle before being replaced, or when you want to
    conditionally disable based on runtime state inspected during the first tick.
  </p>

  <h3>Inter-Mod Detection</h3>

  <p>
    When multiple mods might replace the same system, detect each other to avoid conflicts:
  </p>

  <pre><code class="language-csharp">// Check if system is already disabled by another mod
var vanillaSystem = World.DefaultGameObjectInjectionWorld
    .GetOrCreateSystemManaged&lt;Game.Simulation.SomeSystem&gt;();
if (vanillaSystem.Enabled)
{
    vanillaSystem.Enabled = false;
    // Register replacement
}
else
{
    Log.Warn("SomeSystem already disabled by another mod");
}

// Or check for another mod's assembly
bool otherModLoaded = AppDomain.CurrentDomain.GetAssemblies()
    .Any(a =&gt; a.GetName().Name == "OtherModAssembly");</code></pre>

  <h3>Caveats</h3>

  <ul>
    <li>The disabled system's <code>OnCreate</code> still ran (it was created before your mod loaded). Only <code>OnUpdate</code> is skipped.</li>
    <li>If the vanilla system implements <code>IDefaultSerializable</code>/<code>ISerializable</code>, disabling it does NOT disable serialization. The serialization libraries call those methods directly, bypassing <code>Enabled</code>.</li>
    <li>Burst-compiled jobs inside the vanilla system are not affected -- they simply never get scheduled because <code>OnUpdate</code> is skipped.</li>
  </ul>

  <h3>No-Harmony Architecture</h3>

  <p>
    Some of the most complex CS2 mods use <strong>zero Harmony patches</strong>, achieving all
    functionality through pure ECS patterns. The Traffic mod (krzychu124) demonstrates this at scale
    with a complete lane system replacement, custom tools, custom rendering, and custom serializable
    components.
  </p>

  <table>
    <thead>
      <tr><th>Aspect</th><th>Pure ECS</th><th>Harmony Patching</th></tr>
    </thead>
    <tbody>
      <tr><td>Mod conflicts</td><td>Minimal (each mod owns its systems)</td><td>High (multiple mods patch same method)</td></tr>
      <tr><td>Game update resilience</td><td>Medium (system interfaces may change)</td><td>Low (method signatures change frequently)</td></tr>
      <tr><td>Burst compatibility</td><td>Full (can use Burst-compiled jobs)</td><td>None (Harmony cannot patch Burst jobs)</td></tr>
      <tr><td>Code complexity</td><td>Higher (must reimplement full systems)</td><td>Lower (small targeted patches)</td></tr>
      <tr><td>Debugging</td><td>Standard C# debugging</td><td>Complex (injected IL hard to trace)</td></tr>
    </tbody>
  </table>

  <p>
    <strong>When to use pure ECS</strong>: Complex mods modifying core simulation logic (traffic,
    pathfinding, demand), mods needing Burst performance, or mods where entire system behavior
    changes. <strong>When to use Harmony</strong>: Small targeted tweaks, UI modifications, or
    intercepting specific calls without reimplementing the full system.
  </p>

  <!-- ============================================================ -->
  <h2>Configuration</h2>

  <h3>Mod Discovery Path</h3>

  <p>Mods are discovered from the AssetDatabase, which scans:</p>

  <ul>
    <li>PDX Mods subscription directory (managed by Paradox launcher)</li>
    <li>Local mods directory: <code>{EnvPath.kUserDataPath}/Mods/</code></li>
  </ul>

  <h3>Mod Assembly Structure</h3>

  <p>A valid mod requires:</p>

  <ul>
    <li>A .NET Standard 2.1 DLL</li>
    <li>At least one class implementing <code>IMod</code></li>
    <li>Proper assembly references (game assemblies with Copy Local = No)</li>
  </ul>

  <h3>Dependency Declaration</h3>

  <p>
    Dependencies are declared through standard .NET assembly references in your
    <code>.csproj</code> file. At load time, <code>ExecutableAsset.ResolveModAssets()</code>
    uses Cecil to read your assembly's references and attempts to resolve them against:
  </p>

  <ol>
    <li>Game assemblies (Game.dll, Unity assemblies, etc.)</li>
    <li>Other mod assemblies registered in AssetDatabase</li>
    <li>Assemblies in the current AppDomain search directories</li>
  </ol>

  <p>If any reference cannot be resolved, the mod is marked with
  <code>MissedDependenciesError</code> and will not load.</p>

  <h3>Mod Settings Storage</h3>

  <p>
    <code>ModSetting</code> instances are stored in
    <code>{EnvPath.kUserDataPath}/ModsSettings/</code>. The setting ID is generated as
    <code>{AssemblyName}.{Namespace}.{ClassName}</code>.
  </p>

  <!-- ============================================================ -->
  <h2>Harmony Patch Points</h2>

  <h3>Candidate 1: ModManager.InitializeMods</h3>

  <ul>
    <li><strong>Signature</strong>: <code>private void InitializeMods(UpdateSystem updateSystem)</code></li>
    <li><strong>Patch type</strong>: Prefix or Postfix</li>
    <li><strong>What it enables</strong>: Intercept mod loading, modify load order, add custom initialization</li>
    <li><strong>Risk level</strong>: High (core mod infrastructure)</li>
  </ul>

  <h3>Candidate 2: ModManager.RegisterMods</h3>

  <ul>
    <li><strong>Signature</strong>: <code>private void RegisterMods()</code></li>
    <li><strong>Patch type</strong>: Postfix</li>
    <li><strong>What it enables</strong>: Inject additional mods, modify mod discovery</li>
    <li><strong>Risk level</strong>: High</li>
  </ul>

  <!-- ============================================================ -->
  <h2>Mod Blueprint</h2>

  <ul>
    <li><strong>Entry point</strong>: Implement <code>IMod</code> interface with <code>OnLoad</code>/<code>OnDispose</code></li>
    <li><strong>System registration</strong>: Use <code>UpdateSystem.UpdateAt&lt;T&gt;(phase)</code> in OnLoad</li>
    <li><strong>Settings</strong>: Extend <code>ModSetting</code>, call <code>RegisterInOptionsUI()</code> in OnLoad</li>
    <li><strong>Harmony</strong>: Create <code>Harmony</code> instance, call <code>PatchAll()</code> in OnLoad, <code>UnpatchAll()</code> in OnDispose</li>
    <li><strong>Logging</strong>: Use <code>LogManager.GetLogger(nameof(YourMod))</code> for game-integrated logging</li>
  </ul>

  <!-- ============================================================ -->
  <h2>Cross-Mod Detection Patterns</h2>

  <h3>ModManager Iteration</h3>

  <p>Simple mod presence detection by iterating <code>GameManager.instance.modManager</code>:</p>

  <pre><code class="language-csharp">foreach (ModManager.ModInfo modInfo in GameManager.instance.modManager)
{
    if (modInfo.asset.name.Equals("RWH"))
    {
        Log.Info("Found Realistic Workplaces and Households mod");
    }
}</code></pre>

  <h3>ListModsEnabled</h3>

  <p>
    Returns assembly-qualified names of enabled mods. Use <code>StartsWith</code> for matching
    and cache results with nullable backing fields:
  </p>

  <pre><code class="language-csharp">private static bool? isRoadBuilderEnabled;
public static bool IsRoadBuilderEnabled =&gt; isRoadBuilderEnabled ??=
    GameManager.instance.modManager.ListModsEnabled()
        .Any(x =&gt; x.StartsWith("RoadBuilder, "));</code></pre>

  <h3>Enabled=false Safety Pattern</h3>

  <p>
    Systems that perform destructive one-shot operations should start disabled
    (<code>Enabled = false</code> in <code>OnCreate</code>) and re-disable after each execution.
    This differs from <code>RequireForUpdate</code> which auto-enables based on entity query emptiness.
  </p>

  <pre><code class="language-csharp">protected override void OnCreate()
{
    base.OnCreate();
    Enabled = false; // Only enable explicitly from UI/trigger
}

protected override void OnUpdate()
{
    PerformDangerousOperation();
    Enabled = false; // Re-disable after execution
}</code></pre>

  <!-- ============================================================ -->
  <h2>Cross-Mod Interop via Reflection</h2>

  <h3>Assembly Scanning with AppDomain</h3>

  <p>
    For discovering types and reading static fields from other mods without a direct assembly
    reference, scan <code>AppDomain.CurrentDomain.GetAssemblies()</code>:
  </p>

  <pre><code class="language-csharp">private static Lazy&lt;Type&gt; s_OtherModApi = new Lazy&lt;Type&gt;(() =&gt;
{
    foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
    {
        if (assembly.GetName().Name != "OtherModAssembly")
            continue;

        try
        {
            return assembly.GetType("OtherMod.PublicApi");
        }
        catch (ReflectionTypeLoadException ex)
        {
            // Some types may fail to load if their dependencies
            // are missing. Log and continue with partial results.
            Log.Warn($"Partial type load from {assembly.GetName().Name}: "
                + $"{ex.LoaderExceptions.Length} failures");
            return ex.Types.FirstOrDefault(t =&gt;
                t?.FullName == "OtherMod.PublicApi");
        }
    }
    return null;
});

// Read a static field from the discovered type
public static int GetOtherModValue()
{
    var apiType = s_OtherModApi.Value;
    if (apiType == null)
        return 100; // Fallback to neutral/default value

    var field = apiType.GetField("SomeStaticValue",
        BindingFlags.Static | BindingFlags.Public);
    return field != null ? (int)field.GetValue(null) : 100;
}</code></pre>

  <h3>Discovering API Methods via ModManager</h3>

  <p>
    Pattern for discovering public static API methods from other mods by scanning all loaded
    mod assemblies:
  </p>

  <pre><code class="language-csharp">foreach (var item in GameManager.instance.modManager)
{
    var modType = item.asset.assembly?.GetTypesDerivedFrom&lt;IMod&gt;().FirstOrDefault();
    if (modType == null) continue;

    // Discover API methods by convention (name + signature)
    var apiMethod = modType.GetMethod("GetSearchMethod",
        BindingFlags.Static | BindingFlags.Public);
    if (apiMethod != null)
    {
        // Validate return type and parameters before invoking
        if (apiMethod.ReturnType == typeof(Func&lt;string, bool&gt;))
        {
            var searchFunc = (Func&lt;string, bool&gt;)apiMethod.Invoke(null, null);
            // Use the discovered API
        }
    }
}</code></pre>

  <p><strong>Key considerations:</strong></p>

  <ul>
    <li>Handle <code>ReflectionTypeLoadException</code> when scanning assemblies -- some types may fail to load if their dependencies are missing</li>
    <li>Use <code>Lazy&lt;T&gt;</code> initialization to cache discovered types and avoid repeated assembly scanning</li>
    <li>Always provide fallback/neutral values when the other mod is not present</li>
    <li>Use <code>GetTypesDerivedFrom&lt;IMod&gt;()</code> on <code>item.asset.assembly</code> to find the mod's main type</li>
    <li>Validate method signatures before invoking (return type + parameters)</li>
    <li>This is fragile -- API methods may change between mod versions</li>
  </ul>

  <!-- ============================================================ -->
  <h2>PDX Mods Metadata Access</h2>

  <p>
    Access PDX Mods platform details via <code>PdxSdkPlatform</code> (requires reflection for
    private <code>m_SDKContext</code>):
  </p>

  <pre><code class="language-csharp">var pdxPlatform = PlatformManager.instance.GetPSI&lt;PdxSdkPlatform&gt;("PdxSdk");
var context = typeof(PdxSdkPlatform)
    .GetField("m_SDKContext", BindingFlags.NonPublic | BindingFlags.Instance)
    .GetValue(pdxPlatform) as IContext; // PDX.SDK.Contracts.IContext

// Get local mod details by platform ID
var details = await context.Mods.GetLocalModDetails(platformID);
string folderPath = details.Mod.LocalData.FolderAbsolutePath;
DateTime lastUpdate = details.Mod.LatestUpdate;</code></pre>

  <p>
    <strong>Simpler checks</strong>: <code>prefab.asset?.database == AssetDatabase&lt;ParadoxMods&gt;.instance</code>
    for PDX Mods detection, <code>prefab.asset.GetMeta().platformID</code> for the mod's platform identifier.
  </p>

  <!-- ============================================================ -->
  <h2>Lifecycle Callbacks</h2>

  <h3>OnGameLoadingComplete</h3>

  <p>
    Override <code>OnGameLoadingComplete(Purpose, GameMode)</code> to enable/disable features based
    on whether the player is in Game mode, Editor mode, or the Main Menu. Fires after the game
    finishes loading a save or entering a mode:
  </p>

  <pre><code class="language-csharp">protected override void OnGameLoadingComplete(Purpose purpose, GameMode mode)
{
    base.OnGameLoadingComplete(purpose, mode);
    bool isGameOrEditor = mode == GameMode.Game || mode == GameMode.Editor;
    m_ToggleAction.shouldBeEnabled = isGameOrEditor;
}</code></pre>

  <p>
    <strong><code>OnGameLoadingComplete</code> vs <code>OnGameLoaded</code></strong>:
    <code>OnGameLoaded</code> fires during serialization context (for restoring system state).
    <code>OnGameLoadingComplete</code> fires after the full load &mdash; use it for enabling
    input actions, UI elements, and mode-dependent features.
  </p>

  <h3>GameManager.RegisterUpdater</h3>

  <p>
    <code>GameManager.instance.RegisterUpdater()</code> defers work to the next update cycle on the
    main thread. Use it when system references aren&rsquo;t available during <code>OnCreate</code>,
    when showing UI dialogs after initialization, or to start async work after the game loop is running:
  </p>

  <pre><code class="language-csharp">protected override void OnCreate()
{
    base.OnCreate();
    // Defer to next frame â€” some systems aren't ready during OnCreate
    GameManager.instance.RegisterUpdater(() =&gt;
    {
        var otherSystem = World.GetExistingSystemManaged&lt;SomeOtherSystem&gt;();
        // Now safe to access otherSystem
        return Task.CompletedTask;
    });
}

// Async work from IMod.OnLoad:
GameManager.instance.RegisterUpdater(async () =&gt;
{
    await Task.Run(() =&gt; LoadExternalResources());
});</code></pre>

  <h3>onSettingsApplied Callback</h3>

  <p>
    <code>ModSetting.onSettingsApplied</code> fires when settings change at runtime (user clicks
    Apply in the options menu). Use it to update cached values, UI bindings, or rendering parameters
    without restarting:
  </p>

  <pre><code class="language-csharp">m_Settings.onSettingsApplied += OnSettingsApplied;

private void OnSettingsApplied(Setting setting)
{
    if (setting is ModSettings modSettings)
    {
        UpdateKeybindingLabels(modSettings);
        UpdateOverlayColors(modSettings);
    }
}</code></pre>

  <h3>OnGameLoaded Callback</h3>

  <p>
    <code>OnGameLoaded(Context context)</code> is a virtual callback on <code>GameSystemBase</code>
    that fires after save deserialization completes but before the first simulation frame runs. It
    provides a safe point to initialize system state that depends on loaded game data:
  </p>

  <pre><code class="language-csharp">public partial class MyModSystem : GameSystemBase
{
    private bool m_Initialized;

    protected override void OnGameLoaded(Context context)
    {
        base.OnGameLoaded(context);

        // Safe to query entities here -- deserialization is complete
        var query = GetEntityQuery(ComponentType.ReadOnly&lt;MyComponent&gt;());
        if (!query.IsEmpty)
        {
            InitializeFromExistingData(query);
        }

        m_Initialized = true;
    }

    protected override void OnUpdate()
    {
        // Guard against running before game data is loaded
        if (!m_Initialized)
            return;

        // Normal update logic
    }
}</code></pre>

  <h3>Frame-Skip Pattern for Race Conditions</h3>

  <p>
    Some systems need to wait an additional frame after <code>OnGameLoaded</code> to ensure all
    other systems have processed the loaded data. Use a frame-skip counter:
  </p>

  <pre><code class="language-csharp">public partial class DeferredInitSystem : GameSystemBase
{
    private int m_SkipFrames;

    protected override void OnGameLoaded(Context context)
    {
        base.OnGameLoaded(context);
        // Skip 2 frames to let dependent systems process loaded data
        m_SkipFrames = 2;
    }

    protected override void OnUpdate()
    {
        if (m_SkipFrames &gt; 0)
        {
            m_SkipFrames--;
            return;
        }

        // All systems have had time to process loaded data
        ProcessData();
    }
}</code></pre>

  <h3>Init Flag Pattern</h3>

  <p>
    For systems that require both <code>OnGameLoaded</code> and <code>OnCreate</code> initialization,
    use an explicit flag to track readiness:
  </p>

  <pre><code class="language-csharp">public partial class TwoPhaseInitSystem : GameSystemBase
{
    private bool m_SystemReady;
    private NativeArray&lt;float&gt; m_CachedData;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_CachedData = new NativeArray&lt;float&gt;(1024, Allocator.Persistent);
        // System exists but is not ready until game data loads
    }

    protected override void OnGameLoaded(Context context)
    {
        base.OnGameLoaded(context);
        // Populate cached data from loaded entities
        PopulateCacheFromEntities();
        m_SystemReady = true;
    }

    protected override void OnUpdate()
    {
        if (!m_SystemReady) return;
        // Use m_CachedData safely
    }
}</code></pre>

  <p>
    <strong><code>OnGameLoaded</code> vs <code>OnGameLoadingComplete</code></strong>:
    <code>OnGameLoaded</code> fires in the serialization context, after deserialization but before
    the first simulation frame. <code>OnGameLoadingComplete</code> fires later, after the full loading
    process including UI setup. Use <code>OnGameLoaded</code> for data initialization; use
    <code>OnGameLoadingComplete</code> for UI and input setup.
  </p>

  <!-- ============================================================ -->
  <h2>Deserialization Cleanup Pattern</h2>

  <p>
    When a mod creates transient entities at runtime that should not persist across save/load,
    register a cleanup system in the <code>Deserialize</code> phase. This ensures stale entities
    from a previous session are destroyed when a new game loads:
  </p>

  <pre><code class="language-csharp">public partial class ModDataClearSystem : GameSystemBase
{
    private EntityQuery m_TransientQuery;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_TransientQuery = GetEntityQuery(
            ComponentType.ReadOnly&lt;MyTransientComponent&gt;(),
            ComponentType.Exclude&lt;FakePrefabData&gt;()); // Don't destroy prefabs
    }

    protected override void OnUpdate()
    {
        EntityManager.DestroyEntity(m_TransientQuery);
    }
}

// Register in Deserialize phase:
updateSystem.UpdateAt&lt;ModDataClearSystem&gt;(SystemUpdatePhase.Deserialize);</code></pre>

  <p>
    <strong>Key details</strong>: Exclude <code>FakePrefabData</code> to avoid destroying permanent
    prefab entities. The <code>Deserialize</code> phase runs when loading a save or starting a new
    game. This is for runtime-only transient entities &mdash; serialized components survive by design.
  </p>

  <!-- ============================================================ -->
  <h2>Build Configuration Patterns</h2>

  <h3>Conditional Attribute for Debug Logging</h3>

  <p>
    The <code>[Conditional]</code> attribute strips method calls from Release builds at compile time,
    providing zero-cost debug logging:
  </p>

  <pre><code class="language-csharp">[System.Diagnostics.Conditional("DEBUG_TOOL")]
public static void DebugTool(string message)
{
    Log.Info($"[Tool] {message}");
}

// Calls are omitted by the compiler when DEBUG_TOOL is not defined:
ModLogger.DebugTool($"Processing node {entity}"); // zero-cost in Release</code></pre>

  <p>Define symbols in your <code>.csproj</code> per configuration:</p>

  <pre><code class="language-xml">&lt;PropertyGroup Condition="'$(Configuration)' == 'Debug'"&gt;
  &lt;DefineConstants&gt;DEBUG;DEBUG_TOOL;DEBUG_CONNECTIONS&lt;/DefineConstants&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup Condition="'$(Configuration)' == 'Release'"&gt;
  &lt;DefineConstants&gt;&lt;/DefineConstants&gt;
&lt;/PropertyGroup&gt;</code></pre>

  <h3>WITH_BURST Conditional Compilation</h3>

  <p>
    Use conditional Burst compilation: develop with standard C# debugging, release with Burst
    performance. Define <code>WITH_BURST</code> only in Release:
  </p>

  <pre><code class="language-csharp">#if WITH_BURST
[Unity.Burst.BurstCompile]
#endif
public partial struct MyExpensiveJob : IJobChunk
{
    public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex,
        bool useEnabledMask, in v128 chunkEnabledMask)
    {
        // Burst-compiled in Release, debuggable in Debug
    }
}</code></pre>

  <pre><code class="language-xml">&lt;PropertyGroup Condition="'$(Configuration)' == 'Release'"&gt;
  &lt;DefineConstants&gt;WITH_BURST&lt;/DefineConstants&gt;
  &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
&lt;/PropertyGroup&gt;</code></pre>

  <!-- ============================================================ -->
  <h2>GetUpdateInterval: Controlling System Tick Frequency</h2>

  <p>
    Custom systems do not need to run every frame. <code>GameSystemBase</code> provides a virtual
    method <code>GetUpdateInterval(SystemUpdatePhase)</code> that controls how many frames elapse
    between each <code>OnUpdate</code> call:
  </p>

  <pre><code class="language-csharp">// Decompiled from Game.GameSystemBase
public virtual int GetUpdateInterval(SystemUpdatePhase phase)
{
    return 1; // Default: run every frame
}</code></pre>

  <p>
    Override this to reduce how often your system ticks. For example, the vanilla
    <code>TreeGrowthSystem</code> and community mods like Tree_Controller use an interval of 512:
  </p>

  <pre><code class="language-csharp">public override int GetUpdateInterval(SystemUpdatePhase phase)
{
    return 512; // Run every 512 frames (= 32 updates per day)
}</code></pre>

  <h3>SimulationUtils.GetUpdateFrame: Work Distribution</h3>

  <p>
    When a system runs at a reduced interval, it typically processes only a subset of entities per
    tick using the <code>UpdateFrame</code> shared component filter. The
    <code>SimulationUtils.GetUpdateFrame</code> method determines which group to process:
  </p>

  <pre><code class="language-csharp">// Decompiled from Game.Simulation.SimulationUtils
public static uint GetUpdateFrame(uint frame, int updatesPerDay, int groupCount)
{
    return (uint)((frame / (262144 / (updatesPerDay * groupCount)))
                  &amp; (groupCount - 1));
}</code></pre>

  <ul>
    <li><code>frame</code> -- the current <code>SimulationSystem.frameIndex</code></li>
    <li><code>updatesPerDay</code> -- how many times per day each entity should be processed (e.g., 32)</li>
    <li><code>groupCount</code> -- how many groups entities are divided into (e.g., 16)</li>
  </ul>

  <p>
    The method divides the day (262144 frames) into <code>updatesPerDay * groupCount</code> buckets
    and returns the current bucket index masked to <code>groupCount - 1</code>.
  </p>

  <h3>Applying the UpdateFrame Filter</h3>

  <p>
    Use <code>SetSharedComponentFilter</code> on your <code>EntityQuery</code> to process only the
    current group:
  </p>

  <pre><code class="language-csharp">private SimulationSystem m_SimulationSystem;
private EntityQuery m_TreeQuery;

protected override void OnUpdate()
{
    // 32 updates/day, 16 groups -&gt; each group processed every 512 frames
    uint updateFrame = SimulationUtils.GetUpdateFrame(
        m_SimulationSystem.frameIndex, 32, 16);
    m_TreeQuery.ResetFilter();
    m_TreeQuery.SetSharedComponentFilter(new UpdateFrame(updateFrame));

    // Now m_TreeQuery only contains entities in the current group
    // Process them...
}</code></pre>

  <h3>Relationship: Interval vs Updates-Per-Day</h3>

  <table>
    <thead>
      <tr><th>Interval</th><th>Updates/Day</th><th>Groups</th><th>Entities per tick</th></tr>
    </thead>
    <tbody>
      <tr><td>512</td><td>32</td><td>16</td><td>1/16 of total</td></tr>
      <tr><td>256</td><td>64</td><td>16</td><td>1/16 of total</td></tr>
      <tr><td>128</td><td>128</td><td>16</td><td>1/16 of total</td></tr>
      <tr><td>16</td><td>1024</td><td>16</td><td>1/16 of total</td></tr>
    </tbody>
  </table>

  <p>
    The interval determines how often your <code>OnUpdate</code> runs. The <code>groupCount</code>
    determines what fraction of entities are processed per tick. Together they control total
    throughput: with interval=512 and groups=16, each entity is processed 32 times per day.
  </p>

  <h3>When to Match Vanilla Intervals</h3>

  <p>
    Custom systems that read data produced by vanilla systems should match or be a multiple of the
    vanilla system&rsquo;s interval. For example, a mod system that reads tree growth data should use
    interval 512 (same as <code>TreeGrowthSystem</code>) to ensure synchronized data. Running at a
    faster interval wastes CPU cycles processing stale data.
  </p>

  <h3>GetUpdateOffset: Staggering System Execution</h3>

  <p>
    <code>GameSystemBase</code> also provides <code>GetUpdateOffset(SystemUpdatePhase)</code>
    (default: -1, meaning auto-assigned) to stagger when systems run within the same interval. The
    game distributes systems across frames to avoid spikes. Override this only if your system must
    run on a specific frame offset.
  </p>

  <!-- ============================================================ -->
  <h2>Custom Buffer Components on Vanilla Entities</h2>

  <p>
    Mods can add custom <code>IBufferElementData</code> to vanilla entities (e.g., Nodes, Edges) to
    store mod-specific data alongside game data. The pattern uses a two-level ownership model:
  </p>

  <pre><code class="language-csharp">// 1. Tag component on vanilla Node entity (zero-data, IEmptySerializable)
public struct ModifiedConnections : IComponentData, IEmptySerializable { }

// 2. Buffer on vanilla Node entity referencing external data entities
public struct ModifiedLaneConnections : IBufferElementData, ISerializable
{
    public Entity m_DataEntity;  // Points to separate entity with full data
    public int m_LaneIndex;
    // ISerializable for save/load persistence
}

// 3. Separate entity with the actual data buffer
public struct GeneratedConnection : IBufferElementData, ISerializable
{
    public Entity m_SourceEntity;
    public Entity m_TargetEntity;
    public PathMethod m_Method;
}

// 4. Back-reference component on data entity
public struct DataOwner : IComponentData, ISerializable
{
    public Entity m_Owner;  // Back to the vanilla Node entity
}</code></pre>

  <p>
    <strong>Why two levels?</strong> Vanilla entities have fixed archetypes. Adding a large buffer
    directly would disrupt chunk layout. The two-level model keeps the vanilla entity lightweight
    (just a tag + small buffer of entity refs) and stores heavy data in separate entities.
  </p>

  <h3>Cascade Cleanup</h3>

  <p>
    When vanilla entities with mod data are deleted, the mod's data entities must be cleaned up too.
    Register a cleanup system at <code>SystemUpdatePhase.Modification4B</code>:
  </p>

  <pre><code class="language-csharp">// Query: vanilla entities that have mod data AND are being deleted
EntityQuery deletedWithModData = SystemAPI.QueryBuilder()
    .WithAll&lt;Game.Net.Node, ModifiedLaneConnections, Deleted&gt;()
    .Build();

// In OnUpdate: destroy referenced data entities
var chunks = deletedWithModData.ToArchetypeChunkArray(Allocator.Temp);
foreach (var chunk in chunks)
{
    var buffers = chunk.GetBufferAccessor(ref modLaneConnectionsHandle);
    for (int i = 0; i &lt; buffers.Length; i++)
        foreach (var conn in buffers[i])
            EntityManager.DestroyEntity(conn.m_DataEntity);
}</code></pre>

  <!-- ============================================================ -->
  <h2>Camera Navigation to Entity</h2>

  <p>
    <code>CameraUpdateSystem.orbitCameraController</code> supports "Jump to Entity" navigation:
  </p>

  <pre><code class="language-csharp">var cameraSystem = World.GetOrCreateSystemManaged&lt;CameraUpdateSystem&gt;();
cameraSystem.orbitCameraController.followedEntity = targetEntity;
cameraSystem.orbitCameraController.TryMatchPosition(cameraSystem.activeCameraController);
cameraSystem.activeCameraController = cameraSystem.orbitCameraController;</code></pre>

  <p>
    This smoothly transitions the camera to follow a specific entity, useful for "Find and Navigate"
    features.
  </p>

  <!-- ============================================================ -->
  <h2>Burst Native Library Loading</h2>

  <p>
    Mods that include Burst-compiled jobs can ship platform-specific native libraries. Use
    <code>BurstRuntime.LoadAdditionalLibrary(string path)</code> to load them at runtime:
  </p>

  <pre><code class="language-csharp">public void OnLoad(UpdateSystem updateSystem)
{
    string modDir = GetModDirectory();
    string libraryPath;

    switch (Application.platform)
    {
        case RuntimePlatform.WindowsPlayer:
            libraryPath = Path.Combine(modDir, "lib_burst_generated.dll");
            break;
        case RuntimePlatform.OSXPlayer:
            libraryPath = Path.Combine(modDir, "lib_burst_generated.bundle");
            break;
        case RuntimePlatform.LinuxPlayer:
            libraryPath = Path.Combine(modDir, "lib_burst_generated.so");
            break;
        default:
            Log.Warn($"Unsupported platform: {Application.platform}");
            return;
    }

    if (File.Exists(libraryPath))
    {
        BurstRuntime.LoadAdditionalLibrary(libraryPath);
        Log.Info($"Loaded Burst library: {libraryPath}");
    }
    else
    {
        Log.Warn($"Burst library not found: {libraryPath}");
    }
}</code></pre>

  <p>
    <strong>Relationship to <code>ExecutableAsset.isBursted</code></strong>: The <code>isBursted</code>
    property on <code>ExecutableAsset</code> indicates whether the mod DLL was compiled with Burst.
    When <code>isBursted</code> is true, the game expects a companion native library.
    <code>LoadAdditionalLibrary</code> is the mechanism for loading that library when it ships
    alongside the mod rather than in the default search path.
  </p>

  <p><strong>Platform file extensions</strong>:</p>
  <ul>
    <li>Windows: <code>.dll</code></li>
    <li>macOS: <code>.bundle</code></li>
    <li>Linux: <code>.so</code></li>
  </ul>

  <!-- ============================================================ -->
  <h2>Static Asset Deployment</h2>

  <h3>MSBuild AfterBuild Targets</h3>

  <p>
    Non-code files (SVGs, PNGs, JSON, localization files) can be automatically deployed alongside
    the mod DLL using MSBuild <code>AfterBuild</code> targets. These files are then accessible at
    runtime via <code>coui://</code> host locations:
  </p>

  <pre><code class="language-xml">&lt;!-- In .csproj --&gt;
&lt;PropertyGroup&gt;
  &lt;DeployDir&gt;$(CSII_TOOLPATH)\Mods\$(AssemblyName)&lt;/DeployDir&gt;
&lt;/PropertyGroup&gt;

&lt;ItemGroup&gt;
  &lt;!-- Include all files from the Resources folder --&gt;
  &lt;ModAssets Include="Resources\**\*.*" /&gt;
&lt;/ItemGroup&gt;

&lt;Target Name="DeployAssets" AfterTargets="Build"&gt;
  &lt;MakeDir Directories="$(DeployDir)" /&gt;
  &lt;Copy SourceFiles="@(ModAssets)"
        DestinationFolder="$(DeployDir)\%(RecursiveDir)"
        SkipUnchangedFiles="true" /&gt;
&lt;/Target&gt;</code></pre>

  <h3>Runtime Access via coui:// Protocol</h3>

  <p>
    Deployed assets are available at runtime through the <code>coui://</code> protocol. The host
    location maps to the mod's deployment directory:
  </p>

  <pre><code class="language-csharp">// In your UI module or system:
// SVG icons deployed to Mods/MyMod/icons/
string iconUrl = "coui://ui-mods/icons/my-icon.svg";

// JSON configuration deployed to Mods/MyMod/config/
string configUrl = "coui://ui-mods/config/defaults.json";</code></pre>

  <p><strong>Key details</strong>:</p>
  <ul>
    <li>The <code>coui://</code> host location is registered by the game's <code>InitializeUIModules()</code> phase during mod loading</li>
    <li>Assets must be in the mod's deployment directory to be accessible</li>
    <li>SVG files are commonly used for toolbar icons and UI elements</li>
    <li>The <code>SkipUnchangedFiles="true"</code> attribute prevents unnecessary copies during incremental builds</li>
  </ul>

  <!-- ============================================================ -->
  <h2>Shared Resource Library Pattern</h2>

  <p>
    A mod can exist solely to provide shared assets (icons, localization, utilities) to other mods.
    This avoids duplicating common resources across multiple mods:
  </p>

  <pre><code>SharedResources/
â”œâ”€â”€ SharedResources.csproj
â”œâ”€â”€ Resources/
â”‚   â”œâ”€â”€ icons/           # SVG icons shared by multiple mods
â”‚   â”œâ”€â”€ localization/    # Shared localization strings
â”‚   â””â”€â”€ styles/          # Shared CSS/styling
â””â”€â”€ PublishConfiguration.xml</code></pre>

  <h3>Cross-Mod Dependency Declaration</h3>

  <p>
    Mods that depend on the shared resource library declare it in their
    <code>PublishConfiguration.xml</code>:
  </p>

  <pre><code class="language-xml">&lt;!-- In the consuming mod's PublishConfiguration.xml --&gt;
&lt;PublishConfiguration&gt;
  &lt;ModId value="12345" /&gt;
  &lt;DisplayName value="My Feature Mod" /&gt;
  &lt;Dependency id="67890" displayName="Shared Resources" /&gt;
&lt;/PublishConfiguration&gt;</code></pre>

  <p>
    The <code>Dependency</code> element ensures the shared resource mod is installed before the
    consuming mod loads. The <code>id</code> value is the PDX Mods platform ID of the dependency.
  </p>

  <h3>How It Works</h3>

  <ol>
    <li>The shared resource mod is published to PDX Mods as a regular mod (it may or may not have an <code>IMod</code> implementation)</li>
    <li>Its <code>ExecutableAsset</code> has <code>isReference = true</code> if it contains no <code>IMod</code> class (pure library)</li>
    <li>Consuming mods reference the shared assembly and declare the PDX Mods dependency</li>
    <li>The game resolves the dependency during <code>ExecutableAsset.ResolveModAssets()</code> and loads the shared library first</li>
    <li>Assets deployed by the shared mod are available via <code>coui://</code> to all consuming mods</li>
  </ol>

  <!-- ============================================================ -->
  <h2>PublishConfiguration.xml Schema</h2>

  <p>
    The <code>PublishConfiguration.xml</code> file controls mod metadata for PDX Mods publishing:
  </p>

  <pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;PublishConfiguration&gt;
  &lt;!-- PDX Mods platform ID. Empty or -1 for unpublished mods.
       Auto-populated on first publish. --&gt;
  &lt;ModId value="12345" /&gt;

  &lt;!-- Display name on PDX Mods --&gt;
  &lt;DisplayName value="My Mod Name" /&gt;

  &lt;!-- Short description --&gt;
  &lt;ShortDescription value="Brief description of the mod" /&gt;

  &lt;!-- Long description (supports markdown) --&gt;
  &lt;LongDescription value="Detailed description..." /&gt;

  &lt;!-- Game version compatibility. Supports wildcards:
       "1.2.*" matches any patch version of 1.2 --&gt;
  &lt;GameVersion value="1.2.*" /&gt;

  &lt;!-- Thumbnail image path (relative to project root) --&gt;
  &lt;Thumbnail value="Properties/Thumbnail.png" /&gt;

  &lt;!-- Screenshots --&gt;
  &lt;Screenshot value="Properties/Screenshot1.png" /&gt;
  &lt;Screenshot value="Properties/Screenshot2.png" /&gt;

  &lt;!-- Tags for PDX Mods categorization --&gt;
  &lt;Tag value="Code Mod" /&gt;

  &lt;!-- Mod dependencies by PDX Mods platform ID --&gt;
  &lt;Dependency id="67890" displayName="Required Mod" /&gt;
  &lt;Dependency id="11111" displayName="Another Dependency" /&gt;

  &lt;!-- External links --&gt;
  &lt;ExternalLink url="https://github.com/user/repo"
                displayName="Source Code" type="github" /&gt;
  &lt;ExternalLink url="https://discord.gg/invite"
                displayName="Discord" type="discord" /&gt;

  &lt;!-- Changelog for current version --&gt;
  &lt;ChangeLog value="- Fixed bug X\n- Added feature Y" /&gt;

  &lt;!-- Forum topic ID (auto-populated) --&gt;
  &lt;ForumLink value="https://forum.paradoxplaza.com/..." /&gt;
&lt;/PublishConfiguration&gt;</code></pre>

  <h3>GameVersion Wildcards</h3>

  <ul>
    <li><code>"1.2.3"</code> -- exact version match only</li>
    <li><code>"1.2.*"</code> -- any patch version of 1.2</li>
    <li><code>"1.*"</code> -- any version in the 1.x series</li>
    <li>Omitting <code>GameVersion</code> means the mod is compatible with any version (not recommended)</li>
  </ul>

  <h3>XmlPoke Auto-Population Pattern</h3>

  <p>
    Use MSBuild <code>XmlPoke</code> tasks to auto-populate <code>PublishConfiguration.xml</code>
    during build, keeping version numbers and metadata in sync with the project:
  </p>

  <pre><code class="language-xml">&lt;!-- In .csproj --&gt;
&lt;Target Name="UpdatePublishConfig" BeforeTargets="Build"&gt;
  &lt;XmlPoke XmlInputPath="PublishConfiguration.xml"
           Query="/PublishConfiguration/GameVersion/@value"
           Value="$(GameVersion)" /&gt;
  &lt;XmlPoke XmlInputPath="PublishConfiguration.xml"
           Query="/PublishConfiguration/ShortDescription/@value"
           Value="$(Description)" /&gt;
&lt;/Target&gt;</code></pre>

  <p>
    This keeps the publish configuration in sync with <code>.csproj</code> properties, avoiding
    manual duplication.
  </p>

  <!-- ============================================================ -->
  <h2>Build Infrastructure: CSII_TOOLPATH and Mod.props/Mod.targets</h2>

  <h3>CSII_TOOLPATH Environment Variable</h3>

  <p>
    The <code>CSII_TOOLPATH</code> environment variable points to the Cities: Skylines II installation
    directory. This is the standard way to locate game assemblies for building and to determine the
    mod deployment directory:
  </p>

  <pre><code>&lt;!-- Typical value --&gt;
&lt;!-- Windows: C:\Program Files (x86)\Steam\steamapps\common\Cities Skylines II --&gt;
&lt;!-- macOS: /Volumes/steamapps/common/Cities Skylines II --&gt;
&lt;!-- Linux: ~/.steam/steam/steamapps/common/Cities Skylines II --&gt;</code></pre>

  <h3>Mod.props and Mod.targets</h3>

  <p>
    Community-maintained build infrastructure uses shared MSBuild files that standardize the build
    process across mods:
  </p>

  <p><strong>Mod.props</strong> -- Defines common properties:</p>

  <pre><code class="language-xml">&lt;!-- Mod.props --&gt;
&lt;Project&gt;
  &lt;PropertyGroup&gt;
    &lt;GamePath&gt;$(CSII_TOOLPATH)&lt;/GamePath&gt;
    &lt;ManagedPath&gt;$(GamePath)/Cities2_Data/Managed&lt;/ManagedPath&gt;
    &lt;DeployDir&gt;$(LOCALAPPDATA)/Colossal Order/Cities Skylines II/Mods/$(AssemblyName)&lt;/DeployDir&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</code></pre>

  <p><strong>References.csproj</strong> -- Centralizes game assembly references with <code>Private="false"</code> (Copy Local = No):</p>

  <pre><code class="language-xml">&lt;!-- References.csproj or shared props file --&gt;
&lt;ItemGroup&gt;
  &lt;Reference Include="Game"&gt;
    &lt;HintPath&gt;$(ManagedPath)/Game.dll&lt;/HintPath&gt;
    &lt;Private&gt;false&lt;/Private&gt;
  &lt;/Reference&gt;
  &lt;Reference Include="Colossal.Core"&gt;
    &lt;HintPath&gt;$(ManagedPath)/Colossal.Core.dll&lt;/HintPath&gt;
    &lt;Private&gt;false&lt;/Private&gt;
  &lt;/Reference&gt;
  &lt;Reference Include="Unity.Entities"&gt;
    &lt;HintPath&gt;$(ManagedPath)/Unity.Entities.dll&lt;/HintPath&gt;
    &lt;Private&gt;false&lt;/Private&gt;
  &lt;/Reference&gt;
  &lt;!-- Additional game assemblies as needed --&gt;
&lt;/ItemGroup&gt;</code></pre>

  <p><strong>Mod.targets</strong> -- Defines build targets including deployment and cleanup:</p>

  <pre><code class="language-xml">&lt;!-- Mod.targets --&gt;
&lt;Project&gt;
  &lt;!-- Deploy mod DLL and assets to game's Mods folder --&gt;
  &lt;Target Name="DeployMod" AfterTargets="Build"&gt;
    &lt;MakeDir Directories="$(DeployDir)" /&gt;
    &lt;Copy SourceFiles="$(TargetPath)"
          DestinationFolder="$(DeployDir)"
          SkipUnchangedFiles="true" /&gt;
  &lt;/Target&gt;

  &lt;!-- Clean deployed files --&gt;
  &lt;Target Name="CleanupMod" AfterTargets="Clean"&gt;
    &lt;RemoveDir Directories="$(DeployDir)" /&gt;
  &lt;/Target&gt;
&lt;/Project&gt;</code></pre>

  <h3>Usage in a Mod .csproj</h3>

  <pre><code class="language-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;Import Project="$(SolutionDir)Mod.props" /&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt;
    &lt;AssemblyName&gt;MyMod&lt;/AssemblyName&gt;
  &lt;/PropertyGroup&gt;

  &lt;Import Project="$(SolutionDir)References.csproj" /&gt;
  &lt;Import Project="$(SolutionDir)Mod.targets" /&gt;
&lt;/Project&gt;</code></pre>

  <p>
    The <code>DeployDir</code> property automatically places the built mod DLL into the game's local
    mods directory, enabling the build-deploy-test loop.
  </p>

  <!-- ============================================================ -->
  <h2>BepInEx Plugin Pattern</h2>

  <h3>Alternative to IMod</h3>

  <p>
    BepInEx is an alternative mod loading framework used by some CS2 mods. Instead of implementing
    <code>IMod</code>, mods extend <code>BaseUnityPlugin</code>:
  </p>

  <pre><code class="language-csharp">using BepInEx;
using HarmonyLib;

[BepInPlugin("com.myname.mymod", "My Mod", "1.0.0")]
public class MyPlugin : BaseUnityPlugin
{
    private Harmony _harmony;

    private void Awake()
    {
        _harmony = new Harmony("com.myname.mymod");
        _harmony.PatchAll(typeof(MyPlugin).Assembly);

        Logger.LogInfo("My BepInEx mod loaded");
    }

    private void OnDestroy()
    {
        _harmony?.UnpatchAll("com.myname.mymod");
    }
}</code></pre>

  <h3>System Injection via SystemOrder.Initialize</h3>

  <p>
    BepInEx plugins cannot use <code>UpdateSystem</code> directly (it is passed only to
    <code>IMod.OnLoad</code>). Instead, they inject systems using a Harmony postfix on
    <code>SystemOrder.Initialize</code>:
  </p>

  <pre><code class="language-csharp">[HarmonyPatch(typeof(SystemOrder), "Initialize")]
public static class SystemOrderPatch
{
    public static void Postfix(UpdateSystem updateSystem)
    {
        // Now we have access to the UpdateSystem instance
        updateSystem.UpdateAt&lt;MyCustomSystem&gt;(SystemUpdatePhase.GameSimulation);
    }
}</code></pre>

  <h3>OnCreateWorld vs OnLoad Distinction</h3>

  <table>
    <thead>
      <tr><th>Aspect</th><th>IMod.OnLoad</th><th>BepInEx Awake + SystemOrder Postfix</th></tr>
    </thead>
    <tbody>
      <tr><td>When it runs</td><td>After ModManager initializes mods</td><td>Awake: early in Unity lifecycle; Postfix: when SystemOrder initializes</td></tr>
      <tr><td>UpdateSystem access</td><td>Direct parameter</td><td>Via Harmony postfix on SystemOrder.Initialize</td></tr>
      <tr><td>Mod settings</td><td>Full ModSetting integration</td><td>Must implement custom settings handling</td></tr>
      <tr><td>PDX Mods support</td><td>Native</td><td>Not natively supported</td></tr>
      <tr><td>Game lifecycle</td><td>Managed by ModManager</td><td>Managed by BepInEx chain loader</td></tr>
    </tbody>
  </table>

  <p>
    <strong>When to use BepInEx</strong>: When you need very early initialization (before the mod
    manager runs), when porting from other Unity games that use BepInEx, or when using BepInEx-specific
    features like configuration files and plugin dependencies.
  </p>

  <p>
    <strong>When to use IMod</strong>: For standard CS2 mods distributed via PDX Mods. The
    <code>IMod</code> pattern is the officially supported approach and provides full integration with
    mod settings, the options UI, and the mod manager lifecycle.
  </p>

  <!-- ============================================================ -->
  <h2>EntityManager.CreateSingleton for Mod-Global ECS State</h2>

  <p>
    <code>EntityManager.CreateSingleton&lt;T&gt;()</code> creates an entity with a single component
    that serves as mod-global state accessible from any ECS system. This is the ECS-idiomatic way to
    share configuration or state across multiple systems without static fields:
  </p>

  <pre><code class="language-csharp">// Define the singleton component
public struct MyModConfig : IComponentData
{
    public float SpeedMultiplier;
    public int MaxEntities;
    public bool FeatureEnabled;
}

// Create the singleton in OnCreate of a primary system
public partial class MyModConfigSystem : GameSystemBase
{
    protected override void OnCreate()
    {
        base.OnCreate();

        EntityManager.CreateSingleton(new MyModConfig
        {
            SpeedMultiplier = 1.0f,
            MaxEntities = 100,
            FeatureEnabled = true
        });
    }

    protected override void OnUpdate() { }
}</code></pre>

  <h3>Accessing from Other Systems</h3>

  <p>
    Any system can read or write the singleton using <code>SystemAPI.GetSingleton&lt;T&gt;()</code>
    and <code>SystemAPI.SetSingleton&lt;T&gt;()</code>:
  </p>

  <pre><code class="language-csharp">public partial class MySimulationSystem : GameSystemBase
{
    protected override void OnUpdate()
    {
        // Read the singleton
        var config = SystemAPI.GetSingleton&lt;MyModConfig&gt;();
        if (!config.FeatureEnabled) return;

        float speed = config.SpeedMultiplier;
        // Use speed in simulation logic...
    }
}

public partial class MySettingsSyncSystem : GameSystemBase
{
    protected override void OnUpdate()
    {
        // Write to the singleton (e.g., when mod settings change)
        var config = SystemAPI.GetSingleton&lt;MyModConfig&gt;();
        config.SpeedMultiplier = ModSettings.Instance.SpeedMultiplier;
        SystemAPI.SetSingleton(config);
    }
}</code></pre>

  <h3>Key Considerations</h3>

  <ul>
    <li><strong>One entity per singleton type</strong>: <code>CreateSingleton&lt;T&gt;</code> creates exactly one entity. Calling it again with the same type will throw an exception.</li>
    <li><strong>Burst-compatible</strong>: Singleton components are plain <code>IComponentData</code> structs, fully compatible with Burst-compiled jobs via <code>GetSingleton</code>/<code>SetSingleton</code> in job code.</li>
    <li><strong>Not for Harmony patches</strong>: Singletons are ECS-only. Harmony patches operate outside the ECS world and should use static fields instead.</li>
    <li><strong>Lifecycle</strong>: The singleton entity persists until explicitly destroyed or the World is disposed. It does not survive save/load unless the component implements <code>ISerializable</code>.</li>
  </ul>

  <!-- ============================================================ -->
  <h2>Open Questions</h2>

  <ul>
    <li>
      <strong>Load order guarantees:</strong> Mods are loaded in the order they appear in
      AssetDatabase scan results. There is no explicit priority or load-order declaration.
      Assembly references indirectly enforce ordering.
    </li>
    <li>
      <strong>Hot-reloading:</strong> <code>ModManager.RequireRestart()</code> exists but
      actual hot-reload (unload + reload without restart) is not supported for code mods.
      UI modules can be added/removed dynamically.
    </li>
    <li>
      <strong>Inter-mod communication:</strong> No official inter-mod API exists. Mods
      expose public static members and reference each other via assembly references.
    </li>
    <li>
      <strong>PDX Mods dependency metadata:</strong> How dependencies are declared in the
      PDX Mods platform (separate from assembly references) needs testing with the launcher.
    </li>
  </ul>

  <!-- ============================================================ -->
  <h2>Sources</h2>

  <ul>
    <li>Decompiled from: Game.dll -- Game.Modding.IMod, Game.Modding.ModManager, Game.Modding.ModSetting, Game.UpdateSystem, Game.SystemUpdatePhase</li>
    <li>Asset system: Colossal.IO.AssetDatabase.dll -- Colossal.IO.AssetDatabase.ExecutableAsset</li>
    <li><a href="https://www.paradoxinteractive.com/games/cities-skylines-ii/modding/dev-diary-3-code-modding">CS2 Code Modding Dev Diary (Paradox)</a></li>
  </ul>

  <footer>
    <p>Source: Decompiled from Game.dll (Cities: Skylines II) -- IMod, ModManager, ModSetting, UpdateSystem.</p>
    <div class="attribution-footer">
      <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
    </div>
  </footer>

  </main>

</div>

</body>
</html>
