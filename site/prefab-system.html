<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prefab System - CS2 Modding Research</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="top-bar">
  <a href="index.html" class="site-title">CS2 Modding Research</a>
  <span class="attribution">Generated with Claude | Supervised by repository owner</span>
</div>

<div class="page-layout">

    <aside class="sidebar">
    <h3>Events &amp; Simulation</h3>
    <a href="event-entity-archetype.html">Event Entity Archetype</a>
    <a href="fire-ignition.html">Fire Ignition</a>
    <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
    <a href="crime-trigger.html">Crime Trigger</a>
    <a href="citizen-sickness.html">Citizen Sickness</a>
    <a href="water-system.html">Water System</a>
    <a href="emergency-dispatch.html">Emergency Dispatch</a>
    <a href="disaster-simulation.html">Disaster Simulation</a>

    <h3>Infrastructure</h3>
    <a href="electricity-grid.html">Electricity Grid</a>
    <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
    <a href="road-network.html">Road &amp; Network Building</a>
    <a href="zoning.html">Zoning</a>
    <a href="building-construction.html">Building Construction</a>
    <a href="pathfinding.html">Pathfinding</a>
    <a href="traffic-flow.html">Traffic Flow</a>

    <h3>Economy &amp; Population</h3>
    <a href="citizens-households.html">Citizens &amp; Households</a>
    <a href="economy-budget.html">Economy &amp; Budget</a>
    <a href="demand-systems.html">Demand Systems</a>
    <a href="resource-production.html">Resource Production</a>
    <a href="company-simulation.html">Company Simulation</a>
    <a href="workplace-labor.html">Workplace &amp; Labor</a>
    <a href="land-value-property.html">Land Value &amp; Property</a>
    <a href="trade-connections.html">Trade &amp; Connections</a>
    <a href="tourism-economy.html">Tourism Economy</a>
    <a href="cargo-transport.html">Cargo Transport</a>

    <h3>City Services</h3>
    <a href="garbage-collection.html">Garbage Collection</a>
    <a href="education.html">Education</a>
    <a href="public-transit.html">Public Transit</a>
    <a href="healthcare.html">Healthcare</a>
    <a href="deathcare.html">Deathcare</a>
    <a href="parks-recreation.html">Parks &amp; Recreation</a>
    <a href="police-dispatch.html">Police Dispatch</a>

    <h3>Governance</h3>
    <a href="districts-policies.html">Districts &amp; Policies</a>
    <a href="map-tile-purchase.html">Map Tile Purchase</a>

    <h3>Environment</h3>
    <a href="weather-climate.html">Weather &amp; Climate</a>
    <a href="pollution.html">Pollution</a>
    <a href="terrain-resources.html">Terrain &amp; Resources</a>

    <h3>Vehicles &amp; Transport</h3>
    <a href="vehicle-spawning.html">Vehicle Spawning</a>
    <a href="parking-system.html">Parking System</a>

    <h3>Tools &amp; Input</h3>
    <a href="tool-activation.html">Tool Activation</a>
    <a href="tool-raycast.html">Tool Raycast</a>
    <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
    <a href="mod-hotkey-input.html">Mod Hotkey Input</a>
    <a href="object-tool-system.html">Object Placement Tool</a>

    <h3>UI &amp; Settings</h3>
    <a href="mod-ui-buttons.html">Mod UI Buttons</a>
    <a href="mod-options-ui.html">Mod Options UI</a>
    <a href="info-views-overlays.html">Info Views &amp; Overlays</a>
    <a href="chirper-notifications.html">Chirper Notifications</a>

    <h3>Modding Framework</h3>
    <a href="save-load-persistence.html">Save/Load Persistence</a>
    <a href="prefab-system.html" class="active">Prefab System</a>
    <a href="localization.html">Localization</a>
    <a href="harmony-transpilers.html">Harmony Transpilers</a>
    <a href="mod-loading-dependencies.html">Mod Loading</a>
  </aside>

  <main class="content">

  <h1>Prefab System &amp; Custom Assets</h1>

  <div class="scope">
    <h2>Scope</h2>
    <p>
      <strong>Question:</strong> How does CS2 load, index, and resolve prefabs at runtime?
      How can mods add custom prefabs, modify existing ones, or query the prefab database?
    </p>
    <p>
      <strong>Verdict:</strong> CS2 uses a <strong>two-entity model</strong> where managed
      <code>PrefabBase</code> objects (loaded from asset bundles) are registered with
      <code>PrefabSystem</code>, which creates corresponding ECS entities. Each prefab entity
      stores configuration data and an <code>ObjectData.m_Archetype</code> used to instantiate
      game-world objects. Mods can add, duplicate, modify, and query prefabs through the
      <code>PrefabSystem</code> API.
    </p>
  </div>

  <h2>How It Works</h2>

  <p>
    The prefab system bridges the gap between Unity's managed <code>ScriptableObject</code>
    world and the ECS simulation. Every prefab goes through a registration and initialization
    pipeline that creates an ECS entity with the right components and generates an archetype
    template for spawning game instances.
  </p>

  <div class="diagram"><pre>
[Asset Database loads PrefabBase objects]
        |
[PrefabSystem.AddPrefab(prefab)]
  - Collects ComponentBase list from prefab
  - Each ComponentBase declares ECS components via GetPrefabComponents()
  - Creates Entity with those components + Created + Updated
  - Sets PrefabData.m_Index
  - Registers in m_Entities and m_PrefabIndices
        |
[PrefabInitializeSystem.OnUpdate]
  - Phase 1: ComponentBase.Initialize() + dependency discovery
  - Dependencies queued and added via PrefabSystem.AddPrefab()
  - Phase 2: ComponentBase.LateInitialize()
  - Sets up unlock requirements
        |
[ObjectPrefab.LateInitialize -&gt; RefreshArchetype]
  - GetArchetypeComponents() collects instance components
  - Creates EntityArchetype stored in ObjectData.m_Archetype
  - This archetype is used when spawning game objects
  </pre></div>

  <h2>Two-Entity Model</h2>

  <p>
    CS2 maintains two kinds of entities for each prefab:
  </p>

  <table>
    <thead><tr><th>Entity Type</th><th>Created By</th><th>Key Component</th><th>Count</th></tr></thead>
    <tbody>
      <tr><td>Prefab Entity</td><td><code>PrefabSystem.AddPrefab()</code></td><td><code>PrefabData</code> (index into master list)</td><td>One per prefab type</td></tr>
      <tr><td>Instance Entity</td><td>Object placement / simulation</td><td><code>PrefabRef</code> (points to prefab entity)</td><td>Many per prefab type</td></tr>
    </tbody>
  </table>

  <h2>Prefab Type Hierarchy</h2>

  <pre><code>PrefabBase (abstract)
  +-- ObjectPrefab                    // Any standalone object
  |     +-- StaticObjectPrefab        // Non-moving objects
  |     |     +-- BuildingPrefab      // Buildings with lots
  |     |     +-- SignObjectPrefab    // Signs
  |     +-- MovingObjectPrefab        // Vehicles, citizens
  |     |     +-- VehiclePrefab
  |     |     |     +-- WatercraftPrefab  // Boats, ships
  |     |     +-- CreaturePrefab
  |     +-- ObjectGeometryPrefab      // Geometry/LOD data for objects
  +-- NetPrefab                       // Networks (roads, pipes)
  |     +-- NetLaneGeometryPrefab     // Lane geometry definitions
  +-- AreaPrefab                      // Zones, districts
  +-- UIAssetMenuPrefab               // UI menu entries
  +-- ClimatePrefab                   // Climate settings
  +-- ContentPrefab                   // DLC/mod content markers
  +-- UnlockRequirementPrefab         // Milestone prerequisites</code></pre>

  <h2>Key Components</h2>

  <h3>PrefabBase (Managed)</h3>
  <p>Abstract base class for all prefab definitions. Extends <code>ScriptableObject</code>.</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>components</code></td><td>List&lt;ComponentBase&gt;</td><td>Attached component definitions</td></tr>
      <tr><td><code>isDirty</code></td><td>bool</td><td>Needs re-initialization</td></tr>
      <tr><td><code>asset</code></td><td>PrefabAsset</td><td>Asset database entry reference</td></tr>
      <tr><td><code>isBuiltin</code></td><td>bool</td><td>True if from base game</td></tr>
      <tr><td><code>isSubscribedMod</code></td><td>bool</td><td>True if from ParadoxMods</td></tr>
    </tbody>
  </table>

  <h3>PrefabID (Struct)</h3>
  <p>Unique identifier for prefab lookup. Composed of type name + prefab name + optional hash.</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Type</code></td><td>string</td><td>Type name (e.g., "BuildingPrefab")</td></tr>
      <tr><td><code>m_Name</code></td><td>string</td><td>Prefab name (e.g., "Commercial_CornerStore01")</td></tr>
      <tr><td><code>m_Hash</code></td><td>Hash128</td><td>Asset GUID or platform ID hash</td></tr>
    </tbody>
  </table>

  <h3>PrefabData (ECS)</h3>
  <p>Minimal ECS component on prefab entities. Links back to the managed prefab via index.</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Index</code></td><td>int</td><td>Index into PrefabSystem's master list</td></tr>
    </tbody>
  </table>

  <h3>ComponentBase (Managed)</h3>
  <p>
    Abstract data container attached to prefabs. Each subclass declares which ECS components
    its prefab entity and game instances need via <code>GetPrefabComponents()</code> and
    <code>GetArchetypeComponents()</code>.
  </p>

  <h3>ObjectGeometryData (ECS)</h3>
  <p>Stores geometry bounds for prefab entities. Controls collision zones during placement.</p>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Size</code></td><td>float3</td><td>Full bounding box (e.g., tree canopy)</td></tr>
      <tr><td><code>m_LegSize</code></td><td>float3</td><td>Base/trunk footprint (smaller for trees)</td></tr>
    </tbody>
  </table>
  <p>
    <strong>Tree Anarchy</strong>: Copy <code>m_LegSize</code> to <code>m_Size</code> to reduce
    conflict zone to trunk only. <strong>Tree vs bush</strong>: <code>SubMesh</code> buffer
    length &gt; 5 = tree (6 growth stages), &le; 5 = bush.
  </p>

  <h3>PseudoRandomSeed (ECS)</h3>
  <table>
    <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>m_Seed</code></td><td>ushort</td><td>Controls visual variation (mesh variant, color, rotation)</td></tr>
    </tbody>
  </table>

  <h3>Prefab Metadata Components (ComponentBase)</h3>
  <table>
    <thead><tr><th>Component</th><th>Key Fields</th><th>Purpose</th></tr></thead>
    <tbody>
      <tr><td><code>EditorAssetCategoryOverride</code></td><td><code>m_IncludeCategories</code>, <code>m_ExcludeCategories</code> (string[])</td><td>Override toolbar categorization</td></tr>
      <tr><td><code>ThemeObject</code></td><td><code>m_Theme</code> (ThemePrefab)</td><td>Link to city theme (EU, NA)</td></tr>
      <tr><td><code>AssetPackItem</code></td><td><code>m_Packs</code> (AssetPackPrefab[])</td><td>Group into asset packs</td></tr>
      <tr><td><code>ContentPrerequisite</code></td><td><code>m_ContentPrerequisite</code> (PrefabBase)</td><td>DLC/content gating</td></tr>
      <tr><td><code>UIObject</code></td><td><code>m_Priority</code> (int), <code>m_Group</code> (UIAssetMenuPrefab)</td><td>Toolbar sort order and grouping</td></tr>
      <tr><td><code>Unlockable</code></td><td><code>m_RequireAll</code>, <code>m_RequireAny</code> (PrefabBase[])</td><td>Milestone gating requirements</td></tr>
      <tr><td><code>ServiceObject</code></td><td><code>m_Service</code> (ServicePrefab)</td><td>Toolbar service tab (Roads, Transportation, etc.)</td></tr>
      <tr><td><code>PlaceableInfoviewItem</code></td><td>(ECS, auto-added)</td><td>Auto-added by init pipeline; remove from custom prefabs</td></tr>
    </tbody>
  </table>

  <h2>PrefabSystem API</h2>

  <table>
    <thead><tr><th>Method</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>AddPrefab(prefab)</code></td><td>Register a new prefab, create ECS entity</td></tr>
      <tr><td><code>RemovePrefab(prefab)</code></td><td>Unregister, mark entity Deleted</td></tr>
      <tr><td><code>UpdatePrefab(prefab)</code></td><td>Schedule for re-initialization</td></tr>
      <tr><td><code>DuplicatePrefab(template, name)</code></td><td>Clone an existing prefab</td></tr>
      <tr><td><code>GetEntity(prefab)</code></td><td>Get ECS entity for a managed prefab</td></tr>
      <tr><td><code>GetPrefab&lt;T&gt;(entity)</code></td><td>Get managed prefab from ECS entity</td></tr>
      <tr><td><code>TryGetPrefab(PrefabID, out prefab)</code></td><td>Lookup by type name + prefab name</td></tr>
      <tr><td><code>GetComponentData&lt;T&gt;(prefab)</code></td><td>Read ECS data from prefab entity</td></tr>
      <tr><td><code>AddComponentData&lt;T&gt;(prefab, data)</code></td><td>Add ECS data to prefab entity</td></tr>
    </tbody>
  </table>

  <h2>Examples</h2>

  <h3>Example 1: Looking Up a Prefab by ID</h3>
  <pre><code>PrefabID id = new PrefabID(nameof(BuildingPrefab), "Commercial_CornerStore01");
if (prefabSystem.TryGetPrefab(id, out PrefabBase prefab))
{
    Entity prefabEntity = prefabSystem.GetEntity(prefab);
    // Use prefab or its entity
}</code></pre>

  <h3>Example 2: Duplicating and Registering a Prefab</h3>
  <pre><code>PrefabID templateID = new PrefabID(
    nameof(BuildingPrefab), "Commercial_CornerStore01");

if (prefabSystem.TryGetPrefab(templateID, out PrefabBase template))
{
    PrefabBase clone = prefabSystem.DuplicatePrefab(
        template, "MyMod_CustomStore");
    // clone is now registered and has its own ECS entity
}</code></pre>

  <h3>Example 3: Reading Prefab Data from a Game Entity</h3>
  <pre><code>if (EntityManager.TryGetComponent&lt;PrefabRef&gt;(entity, out PrefabRef prefabRef))
{
    Entity prefabEntity = prefabRef.m_Prefab;
    PrefabData data = EntityManager.GetComponentData&lt;PrefabData&gt;(prefabEntity);
    PrefabBase prefab = prefabSystem.GetPrefab&lt;PrefabBase&gt;(data);

    string name = prefab.name;           // e.g., "Commercial_CornerStore01"
    string type = prefab.GetType().Name; // e.g., "BuildingPrefab"
    bool builtin = prefab.isBuiltin;     // true for base game prefabs
}</code></pre>

  <h3>Example 4: Modifying Prefab ECS Data</h3>
  <pre><code>PrefabID id = new PrefabID(nameof(BuildingPrefab), "SomeBuilding");
if (prefabSystem.TryGetPrefab(id, out PrefabBase prefab))
{
    Entity entity = prefabSystem.GetEntity(prefab);
    if (EntityManager.TryGetComponent&lt;PlaceableObjectData&gt;(entity, out var data))
    {
        data.m_ConstructionCost = 5000;
        EntityManager.SetComponentData(entity, data);
    }
}</code></pre>

  <h3>Example 5: Iterating All Building Prefabs</h3>
  <pre><code>foreach (PrefabBase prefab in prefabSystem.prefabs)
{
    if (prefab is BuildingPrefab building)
    {
        int lotSize = building.m_LotWidth * building.m_LotDepth;
        // Process building prefab
    }
}</code></pre>

  <h2>City Service Building Prefab Components</h2>

  <p>
    City service buildings carry type-specific prefab data components (ECS <code>IComponentData</code>)
    that define their capacities and behaviors:
  </p>

  <table>
    <thead><tr><th>Component</th><th>Key Fields</th><th>Used By</th></tr></thead>
    <tbody>
      <tr><td><code>SchoolData</code></td><td><code>m_StudentCapacity</code>, <code>m_EducationLevel</code></td><td>Education</td></tr>
      <tr><td><code>HospitalData</code></td><td><code>m_PatientCapacity</code>, <code>m_TreatmentBonus</code></td><td>Healthcare</td></tr>
      <tr><td><code>PrisonData</code></td><td><code>m_PrisonerCapacity</code></td><td>Police</td></tr>
      <tr><td><code>PowerPlantData</code></td><td><code>m_ElectricityProduction</code></td><td>Electricity</td></tr>
      <tr><td><code>FireStationData</code></td><td>(capacity fields)</td><td>Fire response</td></tr>
      <tr><td><code>PoliceStationData</code></td><td>(capacity fields)</td><td>Police dispatch</td></tr>
      <tr><td><code>GarbageFacilityData</code></td><td>(capacity fields)</td><td>Garbage collection</td></tr>
      <tr><td><code>MaintenanceDepotData</code></td><td>(capacity fields)</td><td>Road maintenance</td></tr>
      <tr><td><code>TransportDepotData</code></td><td>(capacity fields)</td><td>Public transport</td></tr>
      <tr><td><code>TransportStationData</code></td><td><code>m_WatercraftRefuelTypes</code>, <code>m_AircraftRefuelTypes</code>, <code>m_ComfortFactor</code></td><td>Transport</td></tr>
      <tr><td><code>CargoTransportStationData</code></td><td>(cargo-specific fields)</td><td>Cargo transport</td></tr>
      <tr><td><code>ParkData</code></td><td>(capacity fields)</td><td>Parks &amp; recreation</td></tr>
      <tr><td><code>SolarPoweredData</code></td><td>(identifies solar plants)</td><td>Power system</td></tr>
    </tbody>
  </table>

  <h3>Station Subtype Detection Pattern</h3>

  <p>
    <code>TransportStationData</code> can be classified by checking refuel types and comfort factor:
  </p>

  <ul>
    <li><strong>Port:</strong> <code>m_WatercraftRefuelTypes != 0</code></li>
    <li><strong>Airport:</strong> <code>m_AircraftRefuelTypes != 0</code></li>
    <li><strong>Passenger station:</strong> <code>m_ComfortFactor &gt; 0</code> (without watercraft/aircraft refuel)</li>
    <li><strong>Cargo station:</strong> has <code>CargoTransportStationData</code></li>
  </ul>

  <h2>DLC Asset Pack Detection</h2>

  <p>
    Buildings can be linked to DLC content packs via the <code>AssetPackData</code> and
    <code>AssetPackElement</code> components:
  </p>

  <pre><code class="language-csharp">// Query asset packs
EntityQuery m_AssetPackQuery = GetEntityQuery(new EntityQueryDesc
{
    All = new[] {
        ComponentType.ReadOnly&lt;AssetPackData&gt;(),
        ComponentType.ReadOnly&lt;PrefabData&gt;(),
    }
});

// Detect DLC membership on a building
if (AssetPackElementBufferLookup.TryGetBuffer(buildingEntity, out var elements))
{
    for (int index = 0; index &lt; elements.Length; ++index)
    {
        Entity pack = elements[index].m_Pack;
        string packName = PrefabSystem.GetPrefabName(pack);
        // Known pack names: "uk", "de", "nl", "fr", "jp", "cn", "ee",
        //   "ussw", "usne", "mediterraneanheritage", "dragongate", "skyscrapers"
    }
}</code></pre>

  <p>
    This is useful for mods that need per-DLC behavior adjustments (e.g., region-specific density factors).
  </p>

  <h2>ObjectGeometryPrefab and RenderPrefab</h2>

  <p>
    <code>ObjectGeometryPrefab</code> is a <code>ComponentBase</code> subclass that provides mesh/LOD
    data for objects. <code>RenderPrefab</code> provides computed mesh bounds. Combine them to
    determine physical mesh size at the prefab level:
  </p>

  <pre><code class="language-csharp">if (prefab.TryGet&lt;ObjectGeometryPrefab&gt;(out var geom))
{
    foreach (var meshInfo in geom.m_Meshes)
    {
        RenderPrefab renderPrefab = meshInfo.m_Mesh;
        if (renderPrefab != null)
        {
            Bounds3 bounds = renderPrefab.bounds;
            float3 size = bounds.max - bounds.min;
            // size.x = width, size.y = height, size.z = depth
        }
    }
}</code></pre>

  <h2>Content Source Detection</h2>

  <p>
    CS2 prefabs come from different sources (vanilla, PDX Mods, DLC).
    <code>PrefabBase</code> provides properties to distinguish content origin:
  </p>

  <pre><code>// How isBuiltin works (decompiled)
public bool isBuiltin
{
    get
    {
        if (AssetDatabase.global.resources.prefabsMap.TryGetGuid(this, out _))
            return true;
        return asset?.database is AssetDatabase&lt;Game&gt;;
    }
}

public bool isSubscribedMod =&gt; asset?.database is AssetDatabase&lt;ParadoxMods&gt;;</code></pre>

  <table>
    <thead><tr><th>Source</th><th>Check</th><th>Notes</th></tr></thead>
    <tbody>
      <tr><td>Vanilla</td><td><code>prefab.isBuiltin</code></td><td>True for Game database or global resources map</td></tr>
      <tr><td>PDX Mods</td><td><code>prefab.asset?.database == AssetDatabase&lt;ParadoxMods&gt;.instance</code></td><td>Also via <code>isSubscribedMod</code></td></tr>
      <tr><td>Platform ID</td><td><code>prefab.asset.GetMeta().platformID</code></td><td>Unique per-mod identifier (&gt; 0 for published)</td></tr>
      <tr><td>DLC</td><td>ContentPrerequisite chain</td><td>Requires checking unlock prerequisite components</td></tr>
      <tr><td>Mod-generated</td><td>Custom tag component</td><td>Runtime-created prefabs have no asset database entry</td></tr>
    </tbody>
  </table>

  <h2>Placeholder Objects (Random Variants)</h2>

  <p>
    Some prefabs use <code>PlaceholderObjectData</code> and <code>PlaceholderObjectElement</code>
    to randomly select from variant prefabs at placement time.
  </p>

  <table>
    <thead><tr><th>Component</th><th>Type</th><th>Key Fields</th></tr></thead>
    <tbody>
      <tr><td><code>PlaceholderObjectData</code></td><td>ComponentBase</td><td><code>m_RequirementMask</code> (ObjectRequirementFlags), <code>m_RandomizeGroupIndex</code> (bool)</td></tr>
      <tr><td><code>PlaceholderObjectElement</code></td><td>IBufferElementData</td><td><code>m_Object</code> (Entity) &mdash; variant prefab reference</td></tr>
      <tr><td><code>PlaceholderBuildingData</code></td><td>ComponentBase</td><td><code>m_ZonePrefab</code> (Entity), <code>m_Type</code> (BuildingType)</td></tr>
    </tbody>
  </table>

  <h2>Decal Detection via MeshData</h2>

  <p>Detect decal objects by checking <code>MeshFlags.Decal</code> on the first sub-mesh:</p>

  <pre><code>public static bool IsDecal(EntityManager em, Entity prefabEntity)
{
    if (!em.TryGetBuffer&lt;SubMesh&gt;(prefabEntity, true, out var subMesh)
        || subMesh.Length == 0)
        return false;

    if (!em.TryGetComponent&lt;MeshData&gt;(subMesh[0].m_SubMesh, out var meshData))
        return false;

    return meshData.m_State == MeshFlags.Decal;
}</code></pre>

  <table>
    <thead><tr><th>MeshFlags</th><th>Value</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>Decal</code></td><td>1</td><td>Flat surface overlay object</td></tr>
      <tr><td><code>StackX</code></td><td>2</td><td>Stacks along X axis</td></tr>
      <tr><td><code>StackZ</code></td><td>4</td><td>Stacks along Z axis</td></tr>
    </tbody>
  </table>

  <h2>GetPrefabComponents Override</h2>

  <p>
    Custom <code>PrefabBase</code> subclasses can override <code>GetPrefabComponents()</code> to
    register mod-specific ECS components on prefab entities, enabling efficient entity queries:
  </p>

  <pre><code class="language-csharp">public class RoadBuilderPrefab : NetPrefab
{
    public override void GetPrefabComponents(HashSet&lt;ComponentType&gt; components)
    {
        base.GetPrefabComponents(components);
        components.Add(ComponentType.ReadWrite&lt;RoadBuilderPrefabData&gt;());
    }
}

// Efficiently query all RoadBuilder prefab entities:
EntityQuery query = SystemAPI.QueryBuilder()
    .WithAll&lt;RoadBuilderPrefabData&gt;()
    .Build();</code></pre>

  <h2>Prefab Icon &amp; Name Resolution</h2>

  <pre><code class="language-csharp">// Icon resolution via ImageSystem
var imageSystem = World.GetOrCreateSystemManaged&lt;Game.UI.ImageSystem&gt;();
string thumbnail = imageSystem.GetThumbnail(prefab);
string icon = imageSystem.GetIcon(prefab);

// Localized name via PrefabUISystem
var prefabUI = World.GetOrCreateSystemManaged&lt;PrefabUISystem&gt;();
prefabUI.GetTitleAndDescription(entity, out string titleId, out string descId);
// titleId = "Assets.NAME[PrefabName]"
GameManager.instance.localizationManager.activeDictionary
    .TryGetValue(titleId, out string displayName);</code></pre>

  <h2>ECS Query Patterns for Prefab Detection</h2>

  <table>
    <thead><tr><th>Category</th><th>All Components</th><th>None Components</th></tr></thead>
    <tbody>
      <tr><td>Service buildings</td><td>BuildingData, ServiceObjectData</td><td></td></tr>
      <tr><td>Zoned buildings</td><td>BuildingData, SpawnableBuildingData</td><td></td></tr>
      <tr><td>Props</td><td>StaticObjectData</td><td>BuildingData, TreeData, NetObjectData</td></tr>
      <tr><td>Trees</td><td>TreeData, GrowthScaleData</td><td></td></tr>
      <tr><td>Vehicles</td><td>VehicleData</td><td></td></tr>
      <tr><td>Networks</td><td>NetData</td><td></td></tr>
      <tr><td>Net objects (pillars)</td><td>NetObjectData</td><td></td></tr>
      <tr><td>Areas</td><td>AreaData</td><td></td></tr>
    </tbody>
  </table>

  <h2>Runtime Prefab Creation</h2>

  <p>Full pattern for creating prefabs at runtime. Use <code>OnGamePreload</code> for timing:</p>

  <pre><code class="language-csharp">protected override void OnGamePreload(Purpose purpose, GameMode mode)
{
    base.OnGamePreload(purpose, mode);
    var newPrefab = ScriptableObject.CreateInstance&lt;StaticObjectPrefab&gt;();
    newPrefab.name = "MyMod_CustomProp";

    // Copy components from template
    if (m_PrefabSystem.TryGetPrefab(templateId, out var template))
        if (template.Has&lt;ObjectGeometryPrefab&gt;())
            newPrefab.AddComponentFrom(template.GetComponent&lt;ObjectGeometryPrefab&gt;());

    newPrefab.AddComponent&lt;ObsoleteIdentifiers&gt;(); // Save compatibility
    m_PrefabSystem.AddPrefab(newPrefab);
}</code></pre>

  <h2>CreationDefinition Prefab Substitution</h2>

  <p>
    Substitute the prefab being placed by modifying <code>CreationDefinition.m_Prefab</code>
    during <code>Modification1</code> phase:
  </p>

  <pre><code class="language-csharp">m_CreationQuery = SystemAPI.QueryBuilder()
    .WithAllRW&lt;CreationDefinition, ObjectDefinition&gt;()
    .WithAll&lt;Updated&gt;()
    .WithNone&lt;Deleted, Overridden&gt;()
    .Build();

// In OnUpdate: swap the prefab entity reference
var def = EntityManager.GetComponentData&lt;CreationDefinition&gt;(entity);
def.m_Prefab = alternativePrefabEntity;
EntityManager.SetComponentData(entity, def);</code></pre>

  <h2>ActivatePrefabTool</h2>

  <p>
    <code>ToolSystem.ActivatePrefabTool(PrefabBase)</code> programmatically switches to placement
    mode. Iterates <code>ToolSystem.tools</code> calling <code>TrySetPrefab()</code> on each.
    In Editor mode, set <code>EditorToolUISystem.activeTool = EditorPrefabTool</code> first and
    defer via <code>RegisterUpdater</code>.
  </p>

  <h2>Incremental Prefab Update with Created/Updated Queries</h2>

  <p>
    To build efficient systems that react to prefab changes (e.g., maintaining a search index), use
    <code>Created</code> and <code>Updated</code> marker components:
  </p>

  <pre><code class="language-csharp">// Only run when prefabs have changed
RequireForUpdate(SystemAPI.QueryBuilder()
    .WithAll&lt;PrefabData&gt;()
    .WithAny&lt;Created, Updated&gt;()
    .Build());

// Handle removals via Deleted component
EntityQuery deletedQuery = SystemAPI.QueryBuilder()
    .WithAll&lt;PrefabData, Deleted&gt;()
    .Build();</code></pre>

  <p>
    <code>Created</code> is added by <code>PrefabInitializeSystem</code> when a prefab entity is first
    created. <code>Updated</code> is added when a prefab is modified. Both are removed the frame after
    processing. <code>Deleted</code> marks entities being destroyed.
  </p>

  <h2>FakePrefab Pattern (Custom Mod Entities)</h2>

  <p>
    Mods that need custom entities which pass vanilla <code>PrefabRef</code> validation can use the
    "FakePrefab" pattern: create a minimal <code>PrefabBase</code> subclass, register it with
    <code>PrefabSystem.AddPrefab()</code>, and use the resulting prefab entity as the
    <code>PrefabRef.m_Prefab</code> for mod-created entities.
  </p>

  <h3>Timing: IPreDeserialize</h3>

  <p>
    Register fake prefabs during <code>IPreDeserialize.PreDeserialize()</code> -- this runs before
    <code>PrefabInitializeSystem</code> processes entities, ensuring the prefab is indexed before any
    entity references it:
  </p>

  <pre><code class="language-csharp">public class Mod : IMod, IPreDeserialize
{
    public void PreDeserialize(Context context)
    {
        var prefabSystem = World.DefaultGameObjectInjectionWorld
            .GetOrCreateSystemManaged&lt;PrefabSystem&gt;();

        // Create a minimal prefab
        var fakePrefab = ScriptableObject.CreateInstance&lt;StaticObjectPrefab&gt;();
        fakePrefab.name = "MyMod_DataCarrier";

        // Register it -- creates the ECS entity with PrefabData
        prefabSystem.AddPrefab(fakePrefab);
    }
}

// After registration, retrieve via PrefabID lookup:
PrefabID id = new PrefabID(nameof(StaticObjectPrefab), "MyMod_DataCarrier");
if (m_PrefabSystem.TryGetPrefab(id, out PrefabBase prefab))
{
    Entity prefabEntity = m_PrefabSystem.GetEntity(prefab);
    // Use prefabEntity as PrefabRef.m_Prefab for mod entities
}</code></pre>

  <p>
    <strong>Key constraint:</strong> The fake prefab must be registered before any entity references it
    via <code>PrefabRef</code>. Using <code>IPreDeserialize</code> ensures this.
  </p>

  <h2>UpdatePrefab and Runtime Re-Initialization</h2>

  <p>
    <code>PrefabSystem.UpdatePrefab(prefab)</code> schedules a prefab for re-initialization, causing its
    ECS entity to be rebuilt with updated component data. This is needed when modifying a prefab's
    <code>ComponentBase</code> list after initial registration.
  </p>

  <h3>UIGroupElement Buffer Cleanup</h3>

  <p>
    When updating prefabs that have <code>UIObject</code> components (toolbar entries), clean up
    <code>UIGroupElement</code> buffer references before calling <code>UpdatePrefab()</code>:
  </p>

  <pre><code class="language-csharp">if (prefab.TryGet&lt;UIObject&gt;(out var uiObject) &amp;&amp; uiObject.m_Group != null)
{
    Entity groupEntity = m_PrefabSystem.GetEntity(uiObject.m_Group);
    if (EntityManager.HasBuffer&lt;UIGroupElement&gt;(groupEntity))
    {
        var buffer = EntityManager.GetBuffer&lt;UIGroupElement&gt;(groupEntity);
        Entity prefabEntity = m_PrefabSystem.GetEntity(prefab);
        for (int i = buffer.Length - 1; i &gt;= 0; i--)
        {
            if (buffer[i].m_Prefab == prefabEntity)
                buffer.RemoveAt(i);
        }
    }
}

// Now safe to update -- will re-add UIGroupElement entries
m_PrefabSystem.UpdatePrefab(prefab);</code></pre>

  <p>
    After <code>UpdatePrefab()</code> processes, the prefab entity receives the <code>Updated</code>
    component. Systems that cache prefab data should react to this via queries.
  </p>

  <h2>PlaceableObjectData Cost Modification</h2>

  <p>
    Modify ECS component data on prefab entities at runtime. Use managed <code>PrefabBase.TryGet</code>
    as source of truth for restoring original values:
  </p>

  <pre><code class="language-csharp">protected override void OnGameLoadingComplete(Purpose purpose, GameMode mode)
{
    base.OnGameLoadingComplete(purpose, mode);

    // Make all trees free
    var query = SystemAPI.QueryBuilder()
        .WithAll&lt;TreeData, PlaceableObjectData&gt;()
        .Build();
    var entities = query.ToEntityArray(Allocator.Temp);
    foreach (var entity in entities)
    {
        var data = EntityManager.GetComponentData&lt;PlaceableObjectData&gt;(entity);
        data.m_ConstructionCost = 0;
        EntityManager.SetComponentData(entity, data);
    }
    entities.Dispose();
}

// Restore original cost from managed ComponentBase (immutable original):
PrefabBase prefab = m_PrefabSystem.GetPrefab&lt;PrefabBase&gt;(prefabData);
if (prefab.TryGet&lt;PlaceableObject&gt;(out var original))
{
    // PlaceableObject (managed ComponentBase) = immutable original
    // PlaceableObjectData (ECS component) = mutable runtime copy
}</code></pre>

  <h2>PrefabRef-Based Entity Counting</h2>

  <p>
    Count placed instances of each prefab in the game world using <code>PrefabRef</code>:
  </p>

  <pre><code class="language-csharp">private EntityQuery m_PlacedObjectQuery;

protected override void OnCreate()
{
    base.OnCreate();
    m_PlacedObjectQuery = SystemAPI.QueryBuilder()
        .WithAll&lt;PrefabRef&gt;()
        .WithAny&lt;Game.Objects.Object, Game.Net.Edge&gt;()
        .WithNone&lt;Owner, Controller, Overridden&gt;()
        .Build();
}

public Dictionary&lt;int, int&gt; CountPrefabInstances()
{
    var counts = new Dictionary&lt;int, int&gt;();
    var chunks = m_PlacedObjectQuery.ToArchetypeChunkArray(Allocator.Temp);
    var prefabRefHandle = GetComponentTypeHandle&lt;PrefabRef&gt;(true);

    foreach (var chunk in chunks)
    {
        var prefabRefs = chunk.GetNativeArray(ref prefabRefHandle);
        for (int i = 0; i &lt; prefabRefs.Length; i++)
        {
            int key = prefabRefs[i].m_Prefab.Index;
            counts.TryGetValue(key, out int count);
            counts[key] = count + 1;
        }
    }
    chunks.Dispose();
    return counts;
}</code></pre>

  <p>
    <strong>Performance:</strong> Run on a timer (e.g., every 60 seconds), not every frame. Exclude
    <code>Owner</code> and <code>Controller</code> to count only top-level placed entities.
  </p>

  <h2>Warnings &amp; Pitfalls</h2>

  <ul>
    <li><strong>AddPrefab checks availability</strong> -- prefabs from unavailable mods/DLC will be rejected.</li>
    <li><strong>PrefabData.m_Index can change</strong> -- when prefabs are removed, the last prefab swaps into the removed slot.</li>
    <li><strong>Two initialization phases</strong> -- <code>Initialize()</code> runs first for all components, then <code>LateInitialize()</code>. Dependencies discovered in phase 1 are added before phase 2.</li>
    <li><strong>Duplicate PrefabIDs warn but don't crash</strong> -- the second registration is ignored.</li>
    <li><strong>UpdatePrefab replaces the entity</strong> -- old entity gets <code>Deleted</code>, a new entity is created. Any cached entity references become stale.</li>
  </ul>

  <h2>Open Questions</h2>

  <ul>
    <li>How does the asset database load PrefabAsset objects from disk at startup?</li>
    <li><strong>[Answered]</strong> <code>UpdatePrefab()</code> replaces the entity. Requires reflection-based
    <code>m_PrefabIndices</code> fixup and <code>UIGroupElement</code> buffer cleanup. Cascading
    <code>Updated</code> components signal downstream systems. See "UpdatePrefab and Runtime
    Re-Initialization" above.</li>
    <li><strong>[Answered]</strong> ComponentBase subclasses documented above: PlaceableObject, EditorAssetCategoryOverride, ThemeObject, AssetPackItem, ContentPrerequisite, UIObject, ObjectGeometryPrefab, and many type-specific subclasses.</li>
    <li><strong>[Answered]</strong> <code>ContentPrerequisite.m_ContentPrerequisite.TryGet&lt;DlcRequirement&gt;()</code> chains to get the <code>DlcId</code> enum value. The check runs during <code>PrefabInitializeSystem</code>.</li>
  </ul>

  <h2>Sources</h2>

  <ul>
    <li>Decompiled from Game.dll (Cities: Skylines II)</li>
    <li>Namespaces: Game.Prefabs, Game.Common</li>
    <li>Key types: PrefabSystem, PrefabBase, ComponentBase, PrefabID, PrefabData, PrefabRef, PrefabInitializeSystem, ObjectPrefab, BuildingPrefab, ObjectData</li>
  </ul>

  </main>

</div>

<footer>
  <p>Research decompiled from Cities: Skylines II game assemblies using ilspycmd. For educational and modding purposes.</p>
  <div class="attribution-footer">
    <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
  </div>
</footer>

</body>
</html>
