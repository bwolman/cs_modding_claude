<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zoning System</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="top-bar">
  <a href="index.html" class="site-title">CS2 Modding Research</a>
  <span class="attribution">Generated with Claude | Supervised by repository owner</span>
</div>

<div class="page-layout">

  <aside class="sidebar">
    <h3>Events &amp; Simulation</h3>
    <a href="event-entity-archetype.html">Event Entity Archetype</a>
    <a href="fire-ignition.html">Fire Ignition</a>
    <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
    <a href="crime-trigger.html">Crime Trigger</a>
    <a href="citizen-sickness.html">Citizen Sickness</a>
    <a href="water-system.html">Water System</a>
    <a href="emergency-dispatch.html">Emergency Dispatch</a>
    <a href="disaster-simulation.html">Disaster Simulation</a>

    <h3>Infrastructure</h3>
    <a href="electricity-grid.html">Electricity Grid</a>
    <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
    <a href="road-network.html">Road &amp; Network Building</a>
    <a href="zoning.html" class="active">Zoning</a>
    <a href="building-construction.html">Building Construction</a>
    <a href="pathfinding.html">Pathfinding</a>
    <a href="traffic-flow.html">Traffic Flow</a>

    <h3>Economy &amp; Population</h3>
    <a href="citizens-households.html">Citizens &amp; Households</a>
    <a href="economy-budget.html">Economy &amp; Budget</a>
    <a href="demand-systems.html">Demand Systems</a>
    <a href="resource-production.html">Resource Production</a>
    <a href="company-simulation.html">Company Simulation</a>
    <a href="workplace-labor.html">Workplace &amp; Labor</a>
    <a href="land-value-property.html">Land Value &amp; Property</a>
    <a href="trade-connections.html">Trade &amp; Connections</a>
    <a href="tourism-economy.html">Tourism Economy</a>
    <a href="cargo-transport.html">Cargo Transport</a>

    <h3>City Services</h3>
    <a href="garbage-collection.html">Garbage Collection</a>
    <a href="education.html">Education</a>
    <a href="public-transit.html">Public Transit</a>
    <a href="healthcare.html">Healthcare</a>
    <a href="deathcare.html">Deathcare</a>
    <a href="parks-recreation.html">Parks &amp; Recreation</a>
    <a href="police-dispatch.html">Police Dispatch</a>

    <h3>Governance</h3>
    <a href="districts-policies.html">Districts &amp; Policies</a>
    <a href="map-tile-purchase.html">Map Tile Purchase</a>

    <h3>Environment</h3>
    <a href="weather-climate.html">Weather &amp; Climate</a>
    <a href="pollution.html">Pollution</a>
    <a href="terrain-resources.html">Terrain &amp; Resources</a>

    <h3>Vehicles &amp; Transport</h3>
    <a href="vehicle-spawning.html">Vehicle Spawning</a>
    <a href="parking-system.html">Parking System</a>

    <h3>Tools &amp; Input</h3>
    <a href="tool-activation.html">Tool Activation</a>
    <a href="tool-raycast.html">Tool Raycast</a>
    <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
    <a href="mod-hotkey-input.html">Mod Hotkey Input</a>
    <a href="object-tool-system.html">Object Placement Tool</a>

    <h3>UI &amp; Settings</h3>
    <a href="mod-ui-buttons.html">Mod UI Buttons</a>
    <a href="mod-options-ui.html">Mod Options UI</a>
    <a href="info-views-overlays.html">Info Views &amp; Overlays</a>
    <a href="chirper-notifications.html">Chirper Notifications</a>

    <h3>Modding Framework</h3>
    <a href="save-load-persistence.html">Save/Load Persistence</a>
    <a href="prefab-system.html">Prefab System</a>
    <a href="localization.html">Localization</a>
    <a href="harmony-transpilers.html">Harmony Transpilers</a>
    <a href="mod-loading-dependencies.html">Mod Loading</a>
  </aside>

  <main class="content">

  <h1>Zoning System</h1>

  <div class="scope">
    <h2>Scope</h2>
    <p>
      <strong>Question:</strong> How does CS2 manage the zoning lifecycle -- from road placement
      creating zone blocks, to cells being painted with zone types, to buildings spawning on
      vacant lots? What are the data structures and systems involved?
    </p>
    <p>
      <strong>Verdict:</strong> Zoning uses a block-and-cell grid system. Each road edge owns
      <code>Block</code> entities (via <code>SubBlock</code> buffer). Each block contains a flat
      array of <code>Cell</code> buffer elements. Cells track zone type, flags, and height limits.
      <code>CellCheckSystem</code> identifies <code>VacantLot</code> entries on blocks.
      <code>ZoneSpawnSystem</code> evaluates vacant lots against demand, selects a matching
      building prefab, and creates it. Cell size is 8m x 8m, blocks are max 10 wide x 6 deep.
      No Harmony patches needed for reading zone state or monitoring spawns.
    </p>
    <p>
      <strong>Out of scope:</strong> Zone tool UI rendering, zone ambience/sound systems, and
      the detailed internals of demand calculation systems. Those are separate topics -- we cover
      demand only where it feeds into ZoneSpawnSystem.
    </p>
  </div>

  <!-- ============================================================ -->
  <h2>How It Works</h2>

  <p>
    The zoning system is built on a grid of <strong>blocks</strong> and <strong>cells</strong>.
    When a road with zoning enabled is placed, <code>BlockSystem</code> creates zone block
    entities perpendicular to the road on each side. Each block contains a buffer of cells
    arranged in a grid (width along the road, depth away from the road).
  </p>

  <h3>Block Creation</h3>

  <p>
    <code>BlockSystem</code> reacts to road edge changes. For each road edge with the
    <code>RoadFlags.EnableZoning</code> flag on its composition:
  </p>

  <ul>
    <li>Skips elevated roads, tunnels, and sides with Raised/Lowered flags</li>
    <li>Calculates block width from road width: <code>ceil(roadWidth / 8m)</code></li>
    <li>Block depth is fixed at <strong>6 cells</strong> (48 meters from the road edge)</li>
    <li>Long road segments are split into multiple blocks (max ~10 cells wide per block)</li>
    <li>Each block is linked to its parent road via the <code>SubBlock</code> buffer element</li>
    <li>Blocks at roundabout intersections are handled separately with curve-based geometry</li>
  </ul>

  <p>
    The block's <code>m_Direction</code> field points perpendicular to the road, away from it.
    The <code>m_Position</code> is the center of the block in world space. The
    <code>m_Size</code> gives the grid dimensions in cells.
  </p>

  <h3>Cell State Management</h3>

  <p>
    Each block has a <code>Cell</code> buffer with up to 60 elements (10 x 6 max). Cells are
    indexed as <code>cellIndex.y * block.m_Size.x + cellIndex.x</code>. The cell state is
    managed by <code>CellCheckSystem</code>, which runs multiple jobs:
  </p>

  <ul>
    <li><strong>CellBlockJobs.BlockCellsJob</strong>: Checks for obstructions from nets, objects, and terrain. Sets <code>CellFlags.Blocked</code>.</li>
    <li><strong>CellOccupyJobs.ZoneAndOccupyCellsJob</strong>: Marks cells under existing buildings as <code>CellFlags.Occupied</code>.</li>
    <li><strong>CellOverlapJobs.CheckBlockOverlapJob</strong>: Handles cells shared between overlapping blocks. Sets <code>CellFlags.Shared</code>.</li>
    <li><strong>LotSizeJobs.UpdateLotSizeJob</strong>: Finds contiguous groups of visible, unoccupied cells and creates <code>VacantLot</code> entries.</li>
  </ul>

  <h3>Zone Painting</h3>

  <p>
    When the player uses the zone tool, <code>ZoneToolSystem</code> paints cells with a zone type.
    The <code>SetZoneTypeJob</code> sets <code>Cell.m_Zone</code> to the selected zone type and
    adds the <code>CellFlags.Visible</code> flag. <code>GenerateZonesSystem</code> creates
    temporary zone definitions, and <code>ApplyZonesSystem</code> applies them.
  </p>

  <h3>Building Spawning</h3>

  <p>
    <code>ZoneSpawnSystem</code> runs every 16 frames. It evaluates all <code>VacantLot</code>
    entries on blocks and selects up to 3 buildings to spawn per update (one per area type:
    residential, commercial, industrial). The process:
  </p>

  <ol>
    <li>Check demand from the relevant demand system (residential, commercial, or industrial)</li>
    <li>Look up the <code>ZoneData</code> for the lot's zone type to determine area type</li>
    <li>Search building prefabs matched by <code>BuildingSpawnGroupData.m_ZoneType</code></li>
    <li>Filter buildings: must be level 1, lot size must fit, height must fit</li>
    <li>Score each building: lot coverage ratio * demand * zone evaluation score</li>
    <li>Create a <code>CreationDefinition</code> entity for the winning building</li>
    <li>The <code>EndFrameBarrier</code> processes the creation in the next frame</li>
  </ol>

  <!-- ============================================================ -->
  <h2>Key Components</h2>

  <table>
    <thead>
      <tr><th>Assembly</th><th>Namespace</th><th>What's There</th></tr>
    </thead>
    <tbody>
      <tr>
        <td>Game.dll</td>
        <td>Game.Zones</td>
        <td>Block, Cell, CellFlags, ZoneType, ValidArea, VacantLot, SubBlock, BuildOrder, CurvePosition, ProcessEstimate, LotFlags, AreaType, ZoneUtils, BlockSystem, CellCheckSystem, SearchSystem</td>
      </tr>
      <tr>
        <td>Game.dll</td>
        <td>Game.Simulation</td>
        <td>ZoneSpawnSystem, ZoneAmbienceSystem, ZoneEvaluationUtils</td>
      </tr>
      <tr>
        <td>Game.dll</td>
        <td>Game.Prefabs</td>
        <td>ZoneData, ZonePropertiesData, ZoneFlags, ZoneDensity, ZonePrefabs, ZonePrefab, ZoneBlockData, ZoneBlockPrefab, NetZoneData, ZonePreferenceData, ZoneServiceConsumptionData, ZonePollutionData</td>
      </tr>
      <tr>
        <td>Game.dll</td>
        <td>Game.Tools</td>
        <td>ZoneToolSystem, GenerateZonesSystem, ApplyZonesSystem</td>
      </tr>
      <tr>
        <td>Game.dll</td>
        <td>Game.Buildings</td>
        <td>ZoneCheckSystem</td>
      </tr>
    </tbody>
  </table>

  <h3>Block (Game.Zones)</h3>

  <p>The primary zone grid entity. Created by <code>BlockSystem</code> when a road with zoning is placed.</p>

  <table>
    <thead>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>m_Position</td><td>float3</td><td>World-space center of the block</td></tr>
      <tr><td>m_Direction</td><td>float2</td><td>Forward direction (perpendicular to road, pointing away)</td></tr>
      <tr><td>m_Size</td><td>int2</td><td>Width (x, along road) and depth (y, away from road) in cells</td></tr>
    </tbody>
  </table>

  <h3>Cell (Game.Zones)</h3>

  <p>
    Buffer element on Block entities. Capacity 60 (10 x 6 max). Indexed as
    <code>y * block.m_Size.x + x</code>.
  </p>

  <table>
    <thead>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>m_State</td><td>CellFlags</td><td>Bitfield: Blocked, Visible, Occupied, Shared, Roadside, etc.</td></tr>
      <tr><td>m_Zone</td><td>ZoneType</td><td>Zone type index (maps to zone prefab via ZonePrefabs)</td></tr>
      <tr><td>m_Height</td><td>short</td><td>Maximum building height allowed at this cell</td></tr>
    </tbody>
  </table>

  <h3>CellFlags (Game.Zones)</h3>

  <table>
    <thead>
      <tr><th>Flag</th><th>Value</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>None</td><td>0x0000</td><td>Default state</td></tr>
      <tr><td>Blocked</td><td>0x0001</td><td>Obstructed by object, net, or terrain</td></tr>
      <tr><td>Shared</td><td>0x0002</td><td>Overlaps with another block's cell</td></tr>
      <tr><td>Roadside</td><td>0x0004</td><td>Adjacent to the road edge</td></tr>
      <tr><td>Visible</td><td>0x0008</td><td>Painted with a zone type (visible to player)</td></tr>
      <tr><td>Overridden</td><td>0x0010</td><td>Zone type overridden by newer block</td></tr>
      <tr><td>Occupied</td><td>0x0020</td><td>Building currently occupies this cell</td></tr>
      <tr><td>Selected</td><td>0x0040</td><td>Selected by zone tool</td></tr>
      <tr><td>Redundant</td><td>0x0080</td><td>Redundant (covered by another block)</td></tr>
      <tr><td>Updating</td><td>0x0100</td><td>Being updated this frame</td></tr>
      <tr><td>RoadLeft</td><td>0x0200</td><td>Road exists to the left</td></tr>
      <tr><td>RoadRight</td><td>0x0400</td><td>Road exists to the right</td></tr>
      <tr><td>RoadBack</td><td>0x0800</td><td>Road exists behind</td></tr>
    </tbody>
  </table>

  <h3>VacantLot (Game.Zones)</h3>

  <p>
    Buffer element on Block entities. Represents a contiguous area of visible, unoccupied cells
    where a building can spawn.
  </p>

  <table>
    <thead>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>m_Area</td><td>int4</td><td>Lot bounds within block: (minX, maxX, minY, maxY)</td></tr>
      <tr><td>m_Type</td><td>ZoneType</td><td>Zone type for this lot</td></tr>
      <tr><td>m_Height</td><td>short</td><td>Maximum building height</td></tr>
      <tr><td>m_Flags</td><td>LotFlags</td><td>CornerLeft (1), CornerRight (2)</td></tr>
    </tbody>
  </table>

  <h3>ZoneData (Game.Prefabs)</h3>

  <p>Per-zone-prefab configuration. Links zone type to area type and behavior flags.</p>

  <table>
    <thead>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>m_ZoneType</td><td>ZoneType</td><td>Zone type index</td></tr>
      <tr><td>m_AreaType</td><td>AreaType</td><td>None, Residential, Commercial, Industrial</td></tr>
      <tr><td>m_ZoneFlags</td><td>ZoneFlags</td><td>SupportNarrow, SupportLeftCorner, SupportRightCorner, Office</td></tr>
      <tr><td>m_MinOddHeight</td><td>ushort</td><td>Min height for odd-width lots</td></tr>
      <tr><td>m_MinEvenHeight</td><td>ushort</td><td>Min height for even-width lots</td></tr>
      <tr><td>m_MaxHeight</td><td>ushort</td><td>Max allowed building height</td></tr>
    </tbody>
  </table>

  <h3>ZonePropertiesData (Game.Prefabs)</h3>

  <p>Zone-specific economic and gameplay properties.</p>

  <table>
    <thead>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>m_ScaleResidentials</td><td>bool</td><td>Scale residential properties by lot size</td></tr>
      <tr><td>m_ResidentialProperties</td><td>float</td><td>Base residential property count</td></tr>
      <tr><td>m_SpaceMultiplier</td><td>float</td><td>Space multiplier for commercial/industrial</td></tr>
      <tr><td>m_AllowedSold</td><td>Resource</td><td>Allowed commercial sale resources</td></tr>
      <tr><td>m_AllowedManufactured</td><td>Resource</td><td>Allowed industrial manufacturing resources</td></tr>
      <tr><td>m_AllowedStored</td><td>Resource</td><td>Allowed warehouse storage resources</td></tr>
      <tr><td>m_FireHazardMultiplier</td><td>float</td><td>Fire hazard multiplier for this zone</td></tr>
      <tr><td>m_IgnoreLandValue</td><td>bool</td><td>Whether buildings ignore land value</td></tr>
    </tbody>
  </table>

  <h3>BuildingPropertyData (Game.Prefabs)</h3>

  <p>
    Per-building property configuration attached to spawnable building prefab entities. This is the
    building-level counterpart to <code>ZonePropertiesData</code> (which is zone-level). When a
    building spawns, the game uses <code>BuildingPropertyData</code> to determine household count,
    tradeable resources, and workspace capacity. Community mods modify <code>m_ResidentialProperties</code>
    and <code>m_SpaceMultiplier</code> at runtime to adjust building capacity based on physical dimensions.
  </p>

  <table>
    <thead>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>m_ResidentialProperties</td><td>int</td><td>Number of residential units (households) this building holds</td></tr>
      <tr><td>m_SpaceMultiplier</td><td>float</td><td>Multiplier for workspace/commercial space. Higher = more employees per lot cell.</td></tr>
      <tr><td>m_AllowedSold</td><td>Resource</td><td>Bitmask of resources this building can sell (commercial)</td></tr>
      <tr><td>m_AllowedManufactured</td><td>Resource</td><td>Bitmask of resources this building can manufacture (industrial)</td></tr>
      <tr><td>m_AllowedStored</td><td>Resource</td><td>Bitmask of resources this building can store (warehouse)</td></tr>
    </tbody>
  </table>

  <h3>SpawnableBuildingData (Game.Prefabs)</h3>

  <p>
    The bridge between buildings and zones. Every spawnable zoned building has this component, linking
    it to a zone type and tracking its level. <code>ZoneSpawnSystem</code> reads <code>m_ZonePrefab</code>
    to match buildings to vacant lots and filters for <code>m_Level == 1</code> for initial construction.
  </p>

  <table>
    <thead>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>m_ZonePrefab</td><td>Entity</td><td>Reference to the zone prefab entity (e.g., Low Density Residential)</td></tr>
      <tr><td>m_Level</td><td>byte</td><td>Building level (1-5). Spawns at 1, upgrades based on land value/services.</td></tr>
    </tbody>
  </table>

  <h3>Building Property Type Tags (Game.Buildings)</h3>

  <p>
    Three tag components classify which zone type a building belongs to at the entity level.
    These are empty components (no fields) added at building creation time based on
    <code>SpawnableBuildingData.m_ZonePrefab</code> &rarr; <code>ZoneData.m_AreaType</code>.
    They persist for the building's lifetime.
  </p>

  <table>
    <thead>
      <tr><th>Component</th><th>Zone Type</th></tr>
    </thead>
    <tbody>
      <tr><td><code>ResidentialProperty</code></td><td>Residential zones</td></tr>
      <tr><td><code>CommercialProperty</code></td><td>Commercial zones</td></tr>
      <tr><td><code>IndustrialProperty</code></td><td>Industrial zones (includes office)</td></tr>
    </tbody>
  </table>

  <p>Standard query pattern for all growable buildings:</p>

  <pre><code class="language-csharp">EntityQuery growableQuery = SystemAPI.QueryBuilder()
    .WithAll&lt;Building&gt;()
    .WithAny&lt;ResidentialProperty, IndustrialProperty, CommercialProperty&gt;()
    .WithNone&lt;Temp, Deleted, Signature&gt;()
    .Build();</code></pre>

  <p>
    Note: Signature buildings also have these components but are typically excluded with
    <code>WithNone&lt;Signature&gt;</code> since they have unique behavior.
  </p>

  <h3>Condemned (Game.Buildings)</h3>

  <p>
    Tag component added by <code>ZoneCheckSystem</code> when a building is incompatible with its
    current zone type. Triggers a separate demolition pipeline &mdash; buildings are NOT demolished
    directly by ZoneCheckSystem.
  </p>

  <h3>ExtractorProperty (Game.Buildings)</h3>

  <p>
    Tag component (no fields) marking resource extractor buildings (mines, farms, forestry, oil extractors).
    Mods querying growable buildings should be aware of all four property type tags:
    <code>ResidentialProperty</code>, <code>CommercialProperty</code>, <code>IndustrialProperty</code>,
    and <code>ExtractorProperty</code>.
  </p>

  <h3>UnderConstruction (Game.Buildings)</h3>

  <p>
    Tracks a building being constructed or upgraded. Added by <code>LevelupJob</code> during level-up.
    Processed by <code>BuildingConstructionSystem</code>.
  </p>

  <table>
    <thead>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>m_NewPrefab</td><td>Entity</td><td>New prefab entity to replace the building with</td></tr>
      <tr><td>m_Progress</td><td>byte</td><td>Construction progress (0-255; 255 = instant completion)</td></tr>
    </tbody>
  </table>

  <h3>BuildingSpawnGroupData (Game.Prefabs, ISharedComponentData)</h3>

  <p>
    Shared component that partitions building prefab chunks by zone type. As a shared component,
    all entities with the same zone type are stored in the same archetype chunks. Building selection
    iterates chunks and skips non-matching zone types at the chunk level, making it very efficient.
  </p>

  <table>
    <thead>
      <tr><th>Field</th><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>m_ZoneType</td><td>ZoneType</td><td>Zone type this building group belongs to</td></tr>
    </tbody>
  </table>

  <p>Chunk-level filtering during building selection:</p>

  <pre><code class="language-csharp">// ZoneSpawnSystem and LevelupJob iterate chunks, skipping wrong zone types
for (int i = 0; i &lt; spawnableBuildingChunks.Length; i++)
{
    ArchetypeChunk chunk = spawnableBuildingChunks[i];
    if (!chunk.GetSharedComponent(m_BuildingSpawnGroupType).m_ZoneType.Equals(zoneType))
        continue;  // Skip entire chunk -- all entities have wrong zone type
    // ... iterate and score buildings in matching chunk
}</code></pre>

  <h3>ZoneFlags Semantic Meaning</h3>

  <p>
    The <code>ZoneFlags</code> enum on <code>ZoneData.m_ZoneFlags</code> controls zone behavior beyond
    simple area type classification:
  </p>

  <table>
    <thead>
      <tr><th>Flag</th><th>Value</th><th>Semantic Meaning</th></tr>
    </thead>
    <tbody>
      <tr>
        <td>SupportNarrow</td><td>1</td>
        <td><strong>Row homes / narrow buildings</strong> (1-cell wide). Low-density residential does NOT have this (detached houses need 2+ cells). Medium-density residential DOES (row homes are the defining building type).</td>
      </tr>
      <tr><td>SupportLeftCorner</td><td>2</td><td>Allow corner buildings on the left side</td></tr>
      <tr><td>SupportRightCorner</td><td>4</td><td>Allow corner buildings on the right side</td></tr>
      <tr>
        <td>Office</td><td>8</td>
        <td><strong>Office zone</strong> (still <code>AreaType.Industrial</code> internally). Uses office demand instead of industrial demand. Tax classified as <code>TaxOffice</code>.</td>
      </tr>
    </tbody>
  </table>

  <p>
    <strong>Density tiers</strong> are controlled by the combination of <code>ZoneData.m_MaxHeight</code>
    and <code>ZoneDensity</code>:
  </p>

  <ul>
    <li><strong>Low density</strong> (<code>ZoneDensity.Low</code>): Small <code>m_MaxHeight</code> (18-24). Detached houses, small shops. Does NOT have <code>SupportNarrow</code>.</li>
    <li><strong>Medium density</strong> (<code>ZoneDensity.Medium</code>): Mid-range <code>m_MaxHeight</code>. Row homes, mid-rise buildings. HAS <code>SupportNarrow</code> for residential.</li>
    <li><strong>High density</strong> (<code>ZoneDensity.High</code>): Large <code>m_MaxHeight</code> (60+). Apartment towers, office buildings. May or may not have <code>SupportNarrow</code>.</li>
  </ul>

  <p>
    The <code>m_MaxHeight</code> is written to <code>Cell.m_Height</code> when the zone is painted.
    <code>ZoneSpawnSystem</code> uses it to filter building prefabs -- buildings whose mesh height
    exceeds the cell's height limit are not eligible for spawning.
  </p>

  <h3>Programmatic Zone Classification</h3>

  <p>
    To classify a zone type (low/medium/high density) at runtime using <code>ZonePropertiesData</code>:
  </p>

  <pre><code class="language-csharp">ZonePropertiesData info = ...; // from zone prefab
if (info.m_ResidentialProperties &lt;= 0f)
{
    // Non-residential zone (commercial, industrial, office)
}
else
{
    float ratio = info.m_ResidentialProperties / info.m_SpaceMultiplier;
    if (!info.m_ScaleResidentials)
        // Low density (detached houses)
    else if (ratio &lt; 1f)
        // Check spawnable building lot widths: all &lt;= 2 = row housing, otherwise medium density
    else
        // High density
}</code></pre>

  <h3>Road-to-Zone Integration (ZoneBlockPrefab)</h3>

  <p>
    Road prefabs enable zoning via their <code>m_ZoneBlock</code> field on <code>RoadPrefab</code>.
    Setting this to a <code>ZoneBlockPrefab</code> entity causes <code>BlockSystem</code> to generate
    zone blocks when the road is placed. Setting it to null disables zoning for that road type.
  </p>

  <pre><code class="language-csharp">// Find the zone block prefab
var query = SystemAPI.QueryBuilder().WithAll&lt;ZoneBlockData&gt;().Build();
foreach (var entity in query.ToEntityArray(Allocator.Temp))
{
    if (prefabSystem.TryGetSpecificPrefab&lt;ZoneBlockPrefab&gt;(entity, out var prefab)
        &amp;&amp; prefab.name == "Zone Block")
    {
        zoneBlockPrefab = prefab;
        break;
    }
}

// Enable/disable zoning on a road prefab
roadPrefab.m_ZoneBlock = enableZoning ? zoneBlockPrefab : null;</code></pre>

  <h3>Building Mesh Dimensions Pattern</h3>

  <p>
    When mods need a building's physical size (e.g., to derive realistic workplace counts from volume),
    they use the <code>SubMesh</code> / <code>MeshData</code> / <code>ObjectUtils.GetSize()</code> pattern:
  </p>

  <ol>
    <li><strong>Get SubMesh references:</strong> Each building prefab has a <code>SubMesh</code> buffer with mesh sub-object references.</li>
    <li><strong>Read MeshData:</strong> Each <code>SubMesh</code> entry references a mesh entity with a <code>MeshData</code> component containing bounding box vertices.</li>
    <li><strong>Calculate size:</strong> <code>ObjectUtils.GetSize(size, rotation)</code> returns axis-aligned bounding box dimensions.</li>
  </ol>

  <pre><code class="language-csharp">// Get building prefab mesh dimensions for realistic capacity calculation
Entity buildingPrefab = ...; // from PrefabRef
DynamicBuffer&lt;SubMesh&gt; subMeshes = EntityManager.GetBuffer&lt;SubMesh&gt;(buildingPrefab);

if (subMeshes.Length &gt; 0)
{
    Entity meshEntity = subMeshes[0].m_SubMesh;
    MeshData meshData = EntityManager.GetComponentData&lt;MeshData&gt;(meshEntity);

    // Local-space bounding box
    float3 size = meshData.m_Vertices.max - meshData.m_Vertices.min;

    float volume = size.x * size.y * size.z;
    float floorArea = size.x * size.z;
    int floors = (int)(size.y / 3.0f);  // ~3m per floor
    float usableArea = floorArea * floors * 0.7f;  // 70% usable
    int workplaces = (int)(usableArea / 20.0f);    // ~20 sq m per worker
}</code></pre>

  <h3>Key Constants</h3>

  <table>
    <thead>
      <tr><th>Constant</th><th>Value</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>CELL_SIZE</td><td>8.0 m</td><td>Width and depth of a single cell</td></tr>
      <tr><td>CELL_AREA</td><td>64.0 sq m</td><td>Area of a single cell</td></tr>
      <tr><td>MAX_ZONE_WIDTH</td><td>10 cells</td><td>Maximum block width (along road)</td></tr>
      <tr><td>MAX_ZONE_DEPTH</td><td>6 cells</td><td>Maximum block depth (away from road, 48m)</td></tr>
      <tr><td>MAX_ZONE_TYPES</td><td>339</td><td>Maximum number of zone type indices</td></tr>
      <tr><td>Cell buffer capacity</td><td>60</td><td>InternalBufferCapacity for Cell</td></tr>
      <tr><td>SubBlock buffer capacity</td><td>4</td><td>InternalBufferCapacity for SubBlock</td></tr>
      <tr><td>Spawn interval</td><td>16 frames</td><td>ZoneSpawnSystem update interval</td></tr>
      <tr><td>Spawns per update</td><td>3 max</td><td>One per area type (residential, commercial, industrial)</td></tr>
    </tbody>
  </table>

  <!-- ============================================================ -->
  <h2>ZoneCheckSystem Pipeline (Game.Buildings)</h2>

  <p>
    Checks existing spawnable buildings against their zone blocks to detect zone incompatibility.
    Uses a three-job pipeline:
  </p>

  <ol>
    <li>
      <strong>FindSpawnableBuildingsJob:</strong> Uses <code>SearchSystem.GetStaticSearchTree</code>
      (NativeQuadTree) to find buildings within updated zone bounds. Filters for buildings with
      <code>SpawnableBuildingData</code> but without <code>SignatureBuildingData</code>.
    </li>
    <li>
      <strong>CollectEntitiesJob:</strong> Deduplicates and sorts the building entity list.
    </li>
    <li>
      <strong>CheckBuildingZonesJob:</strong> For each building, validates zone compatibility:
      <ul>
        <li><strong>ValidateAttachedParent:</strong> Checks if the building has an <code>Attached</code> parent
        with <code>PlaceholderBuildingData</code> matching the building's zone prefab. Returns true if
        attached parent's zone matches.</li>
        <li><strong>ValidateZoneBlocks:</strong> Rotates the building's lot grid (8m cell size) to world space,
        iterates the zone SearchTree, and verifies every cell has a matching <code>ZoneType</code> with
        <code>CellFlags.Visible</code> set. Also requires at least one <code>CellFlags.Roadside</code> cell.</li>
      </ul>
    </li>
  </ol>

  <p>Outcomes:</p>

  <ul>
    <li><strong>Valid:</strong> Removes <code>Condemned</code> component and its notification icon.</li>
    <li><strong>Invalid:</strong> Adds <code>Condemned</code> component and
    <code>BuildingConfigurationData.m_CondemnedNotification</code> at <code>IconPriority.FatalProblem</code>
    (unless already Destroyed or Abandoned).</li>
  </ul>

  <p>
    <strong>Key detail:</strong> Buildings are NOT demolished directly by ZoneCheckSystem. They are marked
    with the <code>Condemned</code> component, which triggers a separate demolition pipeline.
  </p>

  <!-- ============================================================ -->
  <h2>Data Flow</h2>

  <div class="diagram">
<pre>
[Road Placed / Modified]
     |
     v
BlockSystem.UpdateBlocksJob
     |-- Checks RoadFlags.EnableZoning on road composition
     |-- Skips elevated, tunnel, raised/lowered sides
     |-- Width = ceil(roadWidth / 8m), Depth = 6 cells
     |-- Creates Block entities with Cell buffers
     |-- Links blocks to road via SubBlock buffer
     |
     v
[Zone Tool Paints Cells]
     |-- ZoneToolSystem.SetZoneTypeJob
     |-- Sets Cell.m_Zone + CellFlags.Visible
     |
     v
CellCheckSystem
     |-- CellBlockJobs: checks obstructions -&gt; CellFlags.Blocked
     |-- CellOccupyJobs: marks occupied cells -&gt; CellFlags.Occupied
     |-- CellOverlapJobs: handles shared cells -&gt; CellFlags.Shared
     |-- LotSizeJobs: finds contiguous vacant areas
     |-- Updates ValidArea, populates VacantLot buffer
     |
     v
[VacantLot Buffer on Block Entities]
     |  m_Area = lot bounds in block coordinates
     |  m_Type = zone type index
     |  m_Height = max building height
     |  m_Flags = corner flags
     |
     v
ZoneSpawnSystem (every 16 frames)
     |
     |-- EvaluateSpawnAreas:
     |   For each VacantLot:
     |     1. Check demand (Residential / Commercial / Industrial)
     |     2. Look up ZoneData.m_AreaType
     |     3. SelectBuilding:
     |        - Match BuildingSpawnGroupData.m_ZoneType
     |        - Filter: level==1, lotSize fits, height fits
     |        - Score: coverage * demand * evaluation
     |     4. Best location per area type queued
     |
     |-- SpawnBuildingJob:
     |   For best location per area type:
     |     1. World position from Block + lot area
     |     2. Create CreationDefinition entity
     |     3. Create sub-areas and sub-nets
     |
     v
[Building Entity Created]
     |  Cells marked CellFlags.Occupied
     |  Building linked to zone via ZoneCheckSystem
</pre>
  </div>

  <!-- ============================================================ -->
  <h2>Examples</h2>

  <h3>Query Zone Blocks Along a Road</h3>

  <p>
    Finds all zone blocks owned by a specific road entity and inspects their cell states.
  </p>

  <pre><code class="language-csharp">public partial class ZoneBlockInspector : GameSystemBase
{
    protected override void OnCreate() { base.OnCreate(); }
    protected override void OnUpdate() { }

    public void InspectRoadZones(Entity roadEntity)
    {
        if (!EntityManager.HasBuffer&lt;SubBlock&gt;(roadEntity))
        {
            Log.Info("Entity has no zone blocks");
            return;
        }

        var subBlocks = EntityManager.GetBuffer&lt;SubBlock&gt;(roadEntity);
        Log.Info($"Road has {subBlocks.Length} zone blocks");

        for (int i = 0; i &lt; subBlocks.Length; i++)
        {
            Entity blockEntity = subBlocks[i].m_SubBlock;
            if (!EntityManager.Exists(blockEntity)) continue;

            Block block = EntityManager.GetComponentData&lt;Block&gt;(blockEntity);
            var cells = EntityManager.GetBuffer&lt;Cell&gt;(blockEntity);

            int visible = 0, occupied = 0, blocked = 0;
            for (int j = 0; j &lt; cells.Length; j++)
            {
                if ((cells[j].m_State &amp; CellFlags.Visible) != 0) visible++;
                if ((cells[j].m_State &amp; CellFlags.Occupied) != 0) occupied++;
                if ((cells[j].m_State &amp; CellFlags.Blocked) != 0) blocked++;
            }

            Log.Info($"Block {i}: size={block.m_Size}, " +
                     $"visible={visible}, occupied={occupied}, blocked={blocked}");
        }
    }
}</code></pre>

  <h3>Count Vacant Lots by Zone Type</h3>

  <p>
    Iterates all zone blocks with vacant lots and tallies them by area type.
  </p>

  <pre><code class="language-csharp">public partial class VacantLotCounter : GameSystemBase
{
    private EntityQuery m_LotQuery;
    private ZoneSystem m_ZoneSystem;

    protected override void OnCreate()
    {
        base.OnCreate();
        m_ZoneSystem = World.GetOrCreateSystemManaged&lt;ZoneSystem&gt;();
        m_LotQuery = GetEntityQuery(
            ComponentType.ReadOnly&lt;Block&gt;(),
            ComponentType.ReadOnly&lt;VacantLot&gt;(),
            ComponentType.Exclude&lt;Deleted&gt;(),
            ComponentType.Exclude&lt;Temp&gt;()
        );
    }

    protected override void OnUpdate()
    {
        ZonePrefabs zonePrefabs = m_ZoneSystem.GetPrefabs();
        var entities = m_LotQuery.ToEntityArray(Allocator.Temp);

        int residential = 0, commercial = 0, industrial = 0;

        for (int i = 0; i &lt; entities.Length; i++)
        {
            var lots = EntityManager.GetBuffer&lt;VacantLot&gt;(entities[i]);
            for (int j = 0; j &lt; lots.Length; j++)
            {
                Entity zonePrefab = zonePrefabs[lots[j].m_Type];
                if (EntityManager.HasComponent&lt;ZoneData&gt;(zonePrefab))
                {
                    ZoneData zoneData = EntityManager.GetComponentData&lt;ZoneData&gt;(zonePrefab);
                    switch (zoneData.m_AreaType)
                    {
                        case AreaType.Residential: residential++; break;
                        case AreaType.Commercial: commercial++; break;
                        case AreaType.Industrial: industrial++; break;
                    }
                }
            }
        }

        entities.Dispose();
        Log.Info($"Vacant lots: R={residential}, C={commercial}, I={industrial}");
    }
}</code></pre>

  <h3>Get World Position of a Cell</h3>

  <p>
    Convert block-relative cell coordinates to world position.
    Cell (0,0) is at the front-right corner (closest to road, rightmost).
  </p>

  <pre><code class="language-csharp">// Get world position of cell at index (cellX, cellY) within a block:
float3 cellWorldPos = ZoneUtils.GetCellPosition(block, new int2(cellX, cellY));

// Get cell index from world position:
int2 cellIndex = ZoneUtils.GetCellIndex(block, worldPosition.xz);

// Validate the index is within bounds:
bool valid = math.all(cellIndex &gt;= 0) &amp;&amp; math.all(cellIndex &lt; block.m_Size);

// Read the cell data:
if (valid)
{
    var cells = EntityManager.GetBuffer&lt;Cell&gt;(blockEntity);
    int index = cellIndex.y * block.m_Size.x + cellIndex.x;
    Cell cell = cells[index];
    bool isZoned = (cell.m_State &amp; CellFlags.Visible) != 0;
    bool isOccupied = (cell.m_State &amp; CellFlags.Occupied) != 0;
}</code></pre>

  <h3>Read Zone Type at a Position</h3>

  <p>
    Find which zone type (if any) is painted at a given world position by searching
    zone blocks.
  </p>

  <pre><code class="language-csharp">public ZoneType GetZoneTypeAt(float3 worldPosition)
{
    // Query all blocks (for efficiency, use SearchSystem's quad tree instead)
    var blocks = m_BlockQuery.ToComponentDataArray&lt;Block&gt;(Allocator.Temp);
    var entities = m_BlockQuery.ToEntityArray(Allocator.Temp);

    for (int i = 0; i &lt; blocks.Length; i++)
    {
        Block block = blocks[i];
        int2 cellIndex = ZoneUtils.GetCellIndex(block, worldPosition.xz);
        if (math.all(cellIndex &gt;= 0) &amp;&amp; math.all(cellIndex &lt; block.m_Size))
        {
            var cells = EntityManager.GetBuffer&lt;Cell&gt;(entities[i]);
            int index = cellIndex.y * block.m_Size.x + cellIndex.x;
            if (index &lt; cells.Length)
            {
                Cell cell = cells[index];
                if ((cell.m_State &amp; CellFlags.Visible) != 0)
                {
                    blocks.Dispose();
                    entities.Dispose();
                    return cell.m_Zone;
                }
            }
        }
    }

    blocks.Dispose();
    entities.Dispose();
    return ZoneType.None;
}</code></pre>

  <h3>Building Selection Scoring Reference</h3>

  <p>
    Illustrates the building selection scoring math used by
    <code>ZoneSpawnSystem.EvaluateSpawnAreas.SelectBuilding()</code>. This is a reference
    reconstruction -- not runnable as-is.
  </p>

  <pre><code class="language-csharp">/// &lt;summary&gt;
/// Reference implementation of building selection scoring.
/// Mirrors ZoneSpawnSystem.EvaluateSpawnAreas.SelectBuilding().
/// &lt;/summary&gt;
public static float CalculateBuildingScore(
    int2 lotSize,         // VacantLot size (max - min)
    int2 buildingLotSize, // BuildingData.m_LotSize
    int demand,           // Demand from demand system
    float evaluationScore, // Score from ZoneEvaluationUtils
    Random random)
{
    // Building must fit within the lot
    if (!math.all(buildingLotSize &lt;= lotSize))
        return 0f;

    // Base score: how well the building fills the lot
    int2 remainder = math.select(
        lotSize - buildingLotSize, 0, buildingLotSize == lotSize - 1);
    float score = (float)(buildingLotSize.x * buildingLotSize.y) * random.NextFloat(1f, 1.05f);
    score += (float)(remainder.x * buildingLotSize.y) * random.NextFloat(0.95f, 1f);
    score += (float)(lotSize.x * remainder.y) * random.NextFloat(0.55f, 0.6f);
    score /= (float)(lotSize.x * lotSize.y);

    // Multiply by demand
    score *= (float)(demand + 1);

    // Multiply by zone evaluation (considers pollution, resources, etc.)
    score *= evaluationScore;

    return score;
}</code></pre>

  <!-- ============================================================ -->
  <h2>Configuration</h2>

  <h3>Zone Types</h3>

  <p>
    Zone types are identified by a <code>ZoneType</code> struct containing a
    <code>ushort m_Index</code> (up to 339 types). Each index maps to a zone prefab entity
    via <code>ZonePrefabs[zoneType]</code>. The prefab carries <code>ZoneData</code> and
    <code>ZonePropertiesData</code>.
  </p>

  <table>
    <thead>
      <tr><th>AreaType</th><th>Description</th><th>Demand Source</th></tr>
    </thead>
    <tbody>
      <tr><td>Residential</td><td>Housing zones (low/medium/high density)</td><td>ResidentialDemandSystem (per density: low, medium, high)</td></tr>
      <tr><td>Commercial</td><td>Shops and services</td><td>CommercialDemandSystem (per resource type)</td></tr>
      <tr><td>Industrial</td><td>Factories, offices, warehouses</td><td>IndustrialDemandSystem (per resource type + storage)</td></tr>
    </tbody>
  </table>

  <h3>Zone Flags</h3>

  <table>
    <thead>
      <tr><th>Flag</th><th>Value</th><th>Effect</th></tr>
    </thead>
    <tbody>
      <tr><td>SupportNarrow</td><td>1</td><td>Allow narrow (1-wide) buildings. If not set, buildings skip 1-width lots.</td></tr>
      <tr><td>SupportLeftCorner</td><td>2</td><td>Allow corner buildings on the left side</td></tr>
      <tr><td>SupportRightCorner</td><td>4</td><td>Allow corner buildings on the right side</td></tr>
      <tr><td>Office</td><td>8</td><td>Industrial area type but office (no manufacturing)</td></tr>
    </tbody>
  </table>

  <h3>Zone Density</h3>

  <table>
    <thead>
      <tr><th>Value</th><th>Index</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr><td>Low</td><td>0</td><td>Low density (houses, small buildings)</td></tr>
      <tr><td>Medium</td><td>1</td><td>Medium density (row houses, mid-rise)</td></tr>
      <tr><td>High</td><td>2</td><td>High density (apartments, towers)</td></tr>
    </tbody>
  </table>

  <h3>Building Selection Factors</h3>

  <p>
    <code>ZoneSpawnSystem.EvaluateSpawnAreas.SelectBuilding()</code> uses these factors to
    score and select buildings:
  </p>

  <table>
    <thead>
      <tr><th>Factor</th><th>Effect</th></tr>
    </thead>
    <tbody>
      <tr><td>Lot coverage ratio</td><td>Buildings that fill more of the lot score higher</td></tr>
      <tr><td>Demand level</td><td>Higher demand = higher score for matching area type</td></tr>
      <tr><td>Land value</td><td>Affects residential scoring (cost per property unit)</td></tr>
      <tr><td>Pollution (ground, air, noise)</td><td>Fed into ZoneEvaluationUtils for evaluation</td></tr>
      <tr><td>Resource availability</td><td>Commercial/industrial score depends on nearby resources</td></tr>
      <tr><td>Corner flags</td><td>Corner lot position bonus for buildings with matching access flags</td></tr>
      <tr><td>Building access direction</td><td>LeftAccess/RightAccess must align with lot orientation</td></tr>
    </tbody>
  </table>

  <!-- ============================================================ -->
  <h2>Patch Points</h2>

  <h3>Candidate 1: ZoneSpawnSystem.OnUpdate()</h3>

  <ul>
    <li><strong>Signature:</strong> <code>protected override void OnUpdate()</code></li>
    <li><strong>Patch type:</strong> Prefix (to block spawning) or Postfix</li>
    <li><strong>What it enables:</strong> Control building spawning -- prevent spawns, force specific buildings, modify demand inputs, redirect spawn locations</li>
    <li><strong>Risk:</strong> Low -- only affects new building spawns</li>
  </ul>

  <h3>Candidate 2: BlockSystem.OnUpdate()</h3>

  <ul>
    <li><strong>Signature:</strong> <code>protected override void OnUpdate()</code></li>
    <li><strong>Patch type:</strong> Prefix or Postfix</li>
    <li><strong>What it enables:</strong> Intercept zone block creation/deletion, modify block sizes, prevent blocks for specific roads</li>
    <li><strong>Risk:</strong> Medium -- affects the fundamental zone grid structure</li>
  </ul>

  <h3>Candidate 3: CellCheckSystem.OnUpdate()</h3>

  <ul>
    <li><strong>Signature:</strong> <code>protected override void OnUpdate()</code></li>
    <li><strong>Patch type:</strong> Prefix or Postfix</li>
    <li><strong>What it enables:</strong> Modify cell validity, override blocked/occupied status, force vacant lots</li>
    <li><strong>Risk:</strong> Medium -- cell state drives the spawn pipeline</li>
  </ul>

  <h3>Candidate 4: ZoneCheckSystem.OnUpdate()</h3>

  <ul>
    <li><strong>Signature:</strong> <code>protected override void OnUpdate()</code></li>
    <li><strong>Patch type:</strong> Prefix or Postfix</li>
    <li><strong>What it enables:</strong> Control building-zone compatibility checks, prevent demolition when zones change</li>
    <li><strong>Risk:</strong> Low -- only affects compatibility checks on existing buildings</li>
  </ul>

  <h3>Alternative: ECS System Approach (No Harmony)</h3>

  <p>
    A custom <code>GameSystemBase</code> can query <code>Block</code>, <code>Cell</code>,
    <code>VacantLot</code>, and <code>ZoneData</code> directly. This is sufficient for:
    reading zone state, monitoring spawns, counting lots, and creating
    <code>CreationDefinition</code> entities to spawn buildings. No Harmony patches needed
    for read-only operations.
  </p>

  <!-- ============================================================ -->
  <h2>Mod Blueprint</h2>

  <h3>Systems to Create</h3>

  <ul>
    <li><strong>ZoneMonitorSystem</strong> -- Track zone state changes and vacant lot availability</li>
    <li><strong>CustomSpawnSystem</strong> -- Run before ZoneSpawnSystem to intercept or modify spawn locations</li>
    <li><strong>ZoneModifierSystem</strong> -- Programmatically modify cell zone types or flags</li>
  </ul>

  <h3>Components to Add</h3>

  <ul>
    <li><strong>SpawnBlocked</strong> -- Marker component on Block entities to prevent spawning on specific blocks</li>
    <li><strong>CustomZoneData</strong> -- Additional per-zone configuration for mod-specific behavior</li>
  </ul>

  <h3>Patches Needed</h3>

  <ul>
    <li><strong>For basic zone reading:</strong> None (ECS queries are sufficient)</li>
    <li><strong>For custom building spawn logic:</strong> Prefix on <code>ZoneSpawnSystem.OnUpdate()</code> to intercept spawn evaluation</li>
    <li><strong>For custom zone block geometry:</strong> Prefix on <code>BlockSystem.OnUpdate()</code> to modify block creation</li>
  </ul>

  <h3>Settings</h3>

  <ul>
    <li>Spawn rate multiplier (default: 1.0)</li>
    <li>Max zone depth override (default: 6)</li>
    <li>Custom zone type registrations</li>
    <li>Building filter preferences per zone type</li>
  </ul>

  <!-- ============================================================ -->
  <h2>Open Questions</h2>

  <ul>
    <li>
      <strong>Zone search tree internals:</strong> <code>Game.Zones.SearchSystem</code> uses a
      <code>NativeQuadTree&lt;Entity, Bounds2&gt;</code> but the rebuild frequency and spatial
      granularity were not fully traced.
    </li>
    <li>
      <strong>Block splitting algorithm:</strong> When <code>BlockSystem</code> divides long road
      edges into multiple blocks, the exact split logic (involving <code>TryOption()</code> with
      width combinations of 2 and 3) was not fully analyzed.
    </li>
    <li>
      <strong>Zone compatibility (RESOLVED):</strong> <code>ZoneCheckSystem</code> never demolishes directly.
      It adds the <code>Condemned</code> tag component when all lot cells don't match the zone type or
      lack a <code>CellFlags.Roadside</code> cell. A separate demolition pipeline handles condemned buildings.
      See the ZoneCheckSystem Pipeline section above for the full three-job pipeline.
    </li>
    <li>
      <strong>Zone type names:</strong> The actual zone prefab names (Low Density Residential,
      etc.) are in game data files, not code. The code only works with numeric
      <code>ZoneType.m_Index</code> values.
    </li>
    <li>
      <strong>ZoneEvaluationUtils.GetScore():</strong> The full scoring formula considering
      pollution, resources, land value, and preferences was not fully traced.
    </li>
    <li>
      <strong>BuildingSpawnGroupData (RESOLVED):</strong> It is an <code>ISharedComponentData</code> with
      a single <code>m_ZoneType</code> field. As a shared component, all entities with the same zone type
      are stored in the same archetype chunks. Building selection iterates chunks and skips non-matching
      zone types at the chunk level, making it very efficient.
    </li>
  </ul>

  <!-- ============================================================ -->

  <footer>
    <p>Source: Decompiled from Game.dll (Cities: Skylines II) -- Game.Zones.BlockSystem, Game.Zones.CellCheckSystem, Game.Simulation.ZoneSpawnSystem, Game.Buildings.ZoneCheckSystem, Game.Zones.ZoneUtils, Game.Prefabs.ZoneData, Game.Prefabs.ZonePropertiesData, Game.Prefabs.ZoneBlockPrefab.</p>
    <div class="attribution-footer">
      <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
    </div>
  </footer>

  </main>

</div>

</body>
</html>
