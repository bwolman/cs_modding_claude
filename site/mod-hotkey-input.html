<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mod Hotkey Input - CS2 Modding Research</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<div class="top-bar">
  <a href="index.html" class="site-title">CS2 Modding Research</a>
  <span class="attribution">Generated with Claude | Supervised by repository owner</span>
</div>

<div class="page-layout">

    <aside class="sidebar">
    <h3>Events &amp; Simulation</h3>
    <a href="event-entity-archetype.html">Event Entity Archetype</a>
    <a href="fire-ignition.html">Fire Ignition</a>
    <a href="vehicle-out-of-control.html">Vehicle Accidents</a>
    <a href="crime-trigger.html">Crime Trigger</a>
    <a href="citizen-sickness.html">Citizen Sickness</a>
    <a href="water-system.html">Water System</a>
    <a href="emergency-dispatch.html">Emergency Dispatch</a>
    <a href="disaster-simulation.html">Disaster Simulation</a>

    <h3>Infrastructure</h3>
    <a href="electricity-grid.html">Electricity Grid</a>
    <a href="water-sewage-pipes.html">Water &amp; Sewage Pipes</a>
    <a href="road-network.html">Road &amp; Network Building</a>
    <a href="zoning.html">Zoning</a>
    <a href="building-construction.html">Building Construction</a>
    <a href="pathfinding.html">Pathfinding</a>
    <a href="traffic-flow.html">Traffic Flow</a>

    <h3>Economy &amp; Population</h3>
    <a href="citizens-households.html">Citizens &amp; Households</a>
    <a href="economy-budget.html">Economy &amp; Budget</a>
    <a href="demand-systems.html">Demand Systems</a>
    <a href="resource-production.html">Resource Production</a>
    <a href="company-simulation.html">Company Simulation</a>
    <a href="workplace-labor.html">Workplace &amp; Labor</a>
    <a href="land-value-property.html">Land Value &amp; Property</a>
    <a href="trade-connections.html">Trade &amp; Connections</a>
    <a href="tourism-economy.html">Tourism Economy</a>
    <a href="cargo-transport.html">Cargo Transport</a>

    <h3>City Services</h3>
    <a href="garbage-collection.html">Garbage Collection</a>
    <a href="education.html">Education</a>
    <a href="public-transit.html">Public Transit</a>
    <a href="healthcare.html">Healthcare</a>
    <a href="deathcare.html">Deathcare</a>
    <a href="parks-recreation.html">Parks &amp; Recreation</a>
    <a href="police-dispatch.html">Police Dispatch</a>

    <h3>Governance</h3>
    <a href="districts-policies.html">Districts &amp; Policies</a>
    <a href="map-tile-purchase.html">Map Tile Purchase</a>

    <h3>Environment</h3>
    <a href="weather-climate.html">Weather &amp; Climate</a>
    <a href="pollution.html">Pollution</a>
    <a href="terrain-resources.html">Terrain &amp; Resources</a>

    <h3>Vehicles &amp; Transport</h3>
    <a href="vehicle-spawning.html">Vehicle Spawning</a>
    <a href="parking-system.html">Parking System</a>

    <h3>Tools &amp; Input</h3>
    <a href="tool-activation.html">Tool Activation</a>
    <a href="tool-raycast.html">Tool Raycast</a>
    <a href="input-action-lifecycle.html">Input Action Lifecycle</a>
    <a href="mod-hotkey-input.html" class="active">Mod Hotkey Input</a>
    <a href="object-tool-system.html">Object Placement Tool</a>

    <h3>UI &amp; Settings</h3>
    <a href="mod-ui-buttons.html">Mod UI Buttons</a>
    <a href="mod-options-ui.html">Mod Options UI</a>
    <a href="info-views-overlays.html">Info Views &amp; Overlays</a>
    <a href="chirper-notifications.html">Chirper Notifications</a>

    <h3>Modding Framework</h3>
    <a href="save-load-persistence.html">Save/Load Persistence</a>
    <a href="prefab-system.html">Prefab System</a>
    <a href="localization.html">Localization</a>
    <a href="harmony-transpilers.html">Harmony Transpilers</a>
    <a href="mod-loading-dependencies.html">Mod Loading</a>
  </aside>

  <main class="content">

<h1>Mod Hotkey Input</h1>

<div class="scope">
  <p><strong>What this covers:</strong> How CS2 handles keyboard input and how mods register rebindable hotkeys that appear in the Options UI.</p>
  <p><strong>Why it matters:</strong> Any mod that needs to trigger logic from a keyboard shortcut must go through this system. It gives you rebindable keys for free.</p>
  <p><strong>Out of scope:</strong> Gamepad bindings, text input fields, and direct Unity Input System usage. Mods should only use the CO wrapper layer.</p>
</div>

<!-- ============================================================ -->
<h2>How It Works</h2>

<p>CS2 wraps Unity's Input System behind a singleton called <code>InputManager</code>. You never touch Unity's <code>InputAction</code> directly. Instead, you declare your hotkeys as attributes on a settings class, and the framework handles registration, rebinding, and persistence automatically.</p>

<p>The process has three stages: <strong>declare</strong>, <strong>register</strong>, and <strong>read</strong>.</p>

<h3>1. Declare: Settings Class with Attributes</h3>

<p>You subclass <code>ModSetting</code> and use two kinds of attributes:</p>

<ul>
  <li><strong>Class-level:</strong> <code>[SettingsUIKeyboardAction]</code> declares an action by name (e.g., "TogglePanel").</li>
  <li><strong>Property-level:</strong> <code>[SettingsUIKeyboardBinding]</code> on a <code>ProxyBinding</code> property sets the default key and links it to the action via <code>actionName</code>.</li>
</ul>

<pre><code class="language-csharp">[FileLocation(nameof(MyMod))]
[SettingsUIKeyboardAction("TriggerAction", ActionType.Button)]
public class MyModSettings : ModSetting
{
    public MyModSettings(IMod mod) : base(mod) { }

    [SettingsUIKeyboardBinding(BindingKeyboard.F5, "TriggerAction", shift: true)]
    public ProxyBinding TriggerActionBinding { get; set; }

    public override void SetDefaults() { }
}</code></pre>

<p>This declares a "TriggerAction" action with a default binding of <code>Shift+F5</code>. The constructor calls <code>InitializeKeyBindings()</code> internally, which reads the attributes via reflection and populates the <code>ProxyBinding</code> properties.</p>

<h3>2. Register: Wire It Up in OnLoad</h3>

<p>In your <code>IMod.OnLoad()</code>, you call three methods. A common ordering is:</p>

<pre><code class="language-csharp">public void OnLoad(UpdateSystem updateSystem)
{
    Settings = new MyModSettings(this);

    Settings.RegisterInOptionsUI();   // 1. Add settings page to Options
    AssetDatabase.global.LoadSettings( // 2. Load saved rebindings from disk
        nameof(MyMod), Settings, new MyModSettings(this));
    Settings.RegisterKeyBindings();    // 3. Register actions with InputManager

    updateSystem.UpdateAt&lt;MyHotkeySystem&gt;(SystemUpdatePhase.MainLoop);
}</code></pre>

<p><strong>Order is flexible</strong>: All three calls must happen, but the order does not appear to be strict. Working mods use different orderings -- e.g., yenyang's mods call <code>RegisterKeyBindings()</code> first, then <code>RegisterInOptionsUI()</code>, then <code>LoadSettings()</code>. The <code>ProxyBinding.Watcher</code> mechanism handles deferred sync when saved rebindings are loaded after actions are registered. <code>RegisterKeyBindings()</code> builds <code>ProxyAction.Info</code> structs, calls <code>InputManager.AddActions()</code>, and creates watchers that auto-sync your properties when the player rebinds.</p>

<h3>3. Read: Poll or Subscribe in a System</h3>

<p>Look up your action in <code>OnCreate()</code>, then poll it each frame in <code>OnUpdate()</code>:</p>

<pre><code class="language-csharp">public partial class MyHotkeySystem : GameSystemBase
{
    private ProxyAction _triggerAction;

    protected override void OnCreate()
    {
        base.OnCreate();
        // Option A: Use ModSetting.GetAction() (preferred -- auto-fills map name)
        _triggerAction = Mod.Settings.GetAction("TriggerAction");

        // Option B: Manual lookup via InputManager
        // _triggerAction = InputManager.instance.FindAction(
        //     Mod.Settings.id, "TriggerAction");
    }

    protected override void OnUpdate()
    {
        if (_triggerAction != null &amp;&amp; _triggerAction.WasPressedThisFrame())
        {
            Log.Info("Hotkey pressed!");
        }
    }
}</code></pre>

<p>The map name is <code>ModSetting.id</code>, which has the format <code>{AssemblyName}.{Namespace}.{ModType}</code>. The <code>GetAction()</code> convenience method auto-fills this map name, so you only need to pass the action name.</p>

<!-- ============================================================ -->
<h2>Data Flow</h2>

<p>The full lifecycle from mod load to player rebind:</p>

<div class="diagram">
ModSetting constructor
  |-- InitializeKeyBindings()
  |     reads [SettingsUIKeyboardBinding] attrs via reflection
  |     populates ProxyBinding properties with default paths + modifiers
  |
  v
Mod.OnLoad()
  |-- RegisterInOptionsUI()     --> Options page appears in game
  |-- LoadSettings()            --> saved rebindings override defaults
  |-- RegisterKeyBindings()
  |     reads [SettingsUIKeyboardAction] class attrs
  |     groups ProxyBinding properties by actionName
  |     builds ProxyAction.Info[] with composites
  |     calls InputManager.AddActions()
  |       creates ProxyActionMap for the mod's ID
  |       creates ProxyAction per action
  |       creates ProxyComposite per device
  |     creates ProxyBinding.Watcher per property
  |
  v
ECS System.OnCreate()
  |-- FindAction(settings.id, "ActionName") --> ProxyAction
  |
  v
ECS System.OnUpdate()  (every frame)
  |-- action.WasPressedThisFrame() / IsPressed() / etc.
  |
  v
Player rebinds in Options UI
  |-- InputManager.SetBinding() updates the path
  |-- ProxyBinding.Watcher fires --> property auto-updates
  |-- settings saved to disk via AssetDatabase
</div>

<!-- ============================================================ -->
<h2>Key Components</h2>

<h3>InputManager</h3>

<p>Singleton that owns all action maps. This is your main entry point for looking up actions.</p>

<table>
  <tr><th>Member</th><th>Returns</th><th>Description</th></tr>
  <tr><td><code>instance</code></td><td>InputManager</td><td>Singleton accessor</td></tr>
  <tr><td><code>FindAction(map, action)</code></td><td>ProxyAction</td><td>Look up an action by map and name</td></tr>
  <tr><td><code>TryFindAction(map, action, out)</code></td><td>bool</td><td>Safe lookup, returns false if not found</td></tr>
  <tr><td><code>FindActionMap(name)</code></td><td>ProxyActionMap</td><td>Look up an action map by name</td></tr>
  <tr><td><code>AddActions(ProxyAction.Info[])</code></td><td>void</td><td>Register new actions (called by RegisterKeyBindings)</td></tr>
  <tr><td><code>SetBinding(binding, out result)</code></td><td>void</td><td>Set or rebind a binding</td></tr>
  <tr><td><code>GetBindings(pathType, options)</code></td><td>IEnumerable&lt;ProxyBinding&gt;</td><td>Get all bindings</td></tr>
  <tr><td><code>CreateMapBarrier(map, name)</code></td><td>InputBarrier</td><td>Block all actions in a map</td></tr>
  <tr><td><code>CreateActionBarrier(map, action, name)</code></td><td>InputBarrier</td><td>Block a specific action from processing input</td></tr>
  <tr><td><code>DeferUpdating()</code></td><td>IDisposable</td><td>Defer binding resolution until disposed</td></tr>
</table>

<h4>Built-in Map Names</h4>

<table>
  <tr><th>Constant</th><th>Value</th></tr>
  <tr><td><code>kSplashScreenMap</code></td><td>"Splash screen"</td></tr>
  <tr><td><code>kNavigationMap</code></td><td>"Navigation"</td></tr>
  <tr><td><code>kMenuMap</code></td><td>"Menu"</td></tr>
  <tr><td><code>kCameraMap</code></td><td>"Camera"</td></tr>
  <tr><td><code>kToolMap</code></td><td>"Tool"</td></tr>
  <tr><td><code>kShortcutsMap</code></td><td>"Shortcuts"</td></tr>
  <tr><td><code>kPhotoModeMap</code></td><td>"Photo mode"</td></tr>
  <tr><td><code>kEditorMap</code></td><td>"Editor"</td></tr>
  <tr><td><code>kDebugMap</code></td><td>"Debug"</td></tr>
  <tr><td><code>kEngagementMap</code></td><td>"Engagement"</td></tr>
</table>

<h4>Modifier Path Constants</h4>

<table>
  <tr><th>Constant</th><th>Value</th></tr>
  <tr><td><code>kShiftName</code></td><td><code>&lt;Keyboard&gt;/shift</code></td></tr>
  <tr><td><code>kCtrlName</code></td><td><code>&lt;Keyboard&gt;/ctrl</code></td></tr>
  <tr><td><code>kAltName</code></td><td><code>&lt;Keyboard&gt;/alt</code></td></tr>
  <tr><td><code>kLeftStick</code></td><td><code>&lt;Gamepad&gt;/leftStickPress</code></td></tr>
  <tr><td><code>kRightStick</code></td><td><code>&lt;Gamepad&gt;/rightStickPress</code></td></tr>
</table>

<h3>ProxyAction</h3>

<p>Wraps a Unity <code>InputAction</code>. This is what you poll each frame or subscribe to for events.</p>

<h4>Key Properties</h4>

<table>
  <tr><th>Member</th><th>Type</th><th>Description</th></tr>
  <tr><td><code>name</code></td><td>string</td><td>Action name</td></tr>
  <tr><td><code>mapName</code></td><td>string</td><td>Parent map name</td></tr>
  <tr><td><code>enabled</code></td><td>bool</td><td>Whether action is currently enabled</td></tr>
  <tr><td><code>isKeyboardAction</code></td><td>bool</td><td>Has keyboard composite</td></tr>
  <tr><td><code>isMouseAction</code></td><td>bool</td><td>Has mouse composite</td></tr>
  <tr><td><code>isGamepadAction</code></td><td>bool</td><td>Has gamepad composite</td></tr>
  <tr><td><code>shouldBeEnabled</code></td><td>bool</td><td>Set to true/false to enable/disable (non-built-in actions only)</td></tr>
  <tr><td><code>composites</code></td><td>IReadOnlyDictionary&lt;DeviceType, ProxyComposite&gt;</td><td>Per-device composites</td></tr>
  <tr><td><code>bindings</code></td><td>IEnumerable&lt;ProxyBinding&gt;</td><td>All bindings across composites</td></tr>
</table>

<h4>Polling Methods</h4>

<table>
  <tr><th>Method</th><th>Returns</th><th>Use When</th></tr>
  <tr><td><code>WasPressedThisFrame()</code></td><td>bool</td><td>Fire once on key-down (toggle, trigger)</td></tr>
  <tr><td><code>IsPressed()</code></td><td>bool</td><td>Fire every frame while held (hold-to-activate)</td></tr>
  <tr><td><code>WasReleasedThisFrame()</code></td><td>bool</td><td>Fire once on key-up (end hold)</td></tr>
  <tr><td><code>WasPerformedThisFrame()</code></td><td>bool</td><td>Fire when action fully performed</td></tr>
  <tr><td><code>IsInProgress()</code></td><td>bool</td><td>True while action is in progress</td></tr>
  <tr><td><code>ReadValue&lt;T&gt;()</code></td><td>T</td><td>Read value for Axis/Vector2 actions</td></tr>
  <tr><td><code>GetMagnitude()</code></td><td>float</td><td>Get current magnitude</td></tr>
</table>

<h4>Other Methods</h4>

<table>
  <tr><th>Method</th><th>Returns</th><th>Description</th></tr>
  <tr><td><code>CreateBarrier(name, mask)</code></td><td>InputBarrier</td><td>Block this action from processing input</td></tr>
  <tr><td><code>CreateActivator(name, mask)</code></td><td>InputActivator</td><td>Enable this action for specific devices</td></tr>
</table>

<p>Nested type: <code>ProxyAction.Info</code> is a blueprint struct with fields <code>m_Name</code>, <code>m_Map</code>, <code>m_Type</code>, <code>m_Composites</code>.</p>

<h4>Event Subscription</h4>

<pre><code class="language-csharp">// Subscribe to interaction events instead of polling
action.onInteraction += (action, phase) =&gt;
{
    // phase: Started, Performed, or Canceled
};
// When no subscribers remain, Unity callbacks are auto-unhooked.</code></pre>

<h3>ProxyBinding</h3>

<p>Struct representing one binding: which map, action, device, key path, and modifiers.</p>

<table>
  <tr><th>Field</th><th>Type</th><th>Description</th></tr>
  <tr><td><code>m_MapName</code></td><td>string</td><td>Action map name</td></tr>
  <tr><td><code>m_ActionName</code></td><td>string</td><td>Action name within the map</td></tr>
  <tr><td><code>m_Path</code></td><td>string</td><td>Unity input path (e.g. <code>&lt;Keyboard&gt;/f5</code>)</td></tr>
  <tr><td><code>m_Modifiers</code></td><td>ProxyModifier[]</td><td>Modifier keys (shift, ctrl, alt)</td></tr>
  <tr><td><code>m_Device</code></td><td>DeviceType</td><td>Keyboard, Mouse, or Gamepad</td></tr>
  <tr><td><code>m_Component</code></td><td>ActionComponent</td><td>Press, Negative, Positive, etc.</td></tr>
</table>

<h4>Key Properties</h4>

<table>
  <tr><th>Property</th><th>Type</th><th>Description</th></tr>
  <tr><td><code>path</code></td><td>string</td><td>Get/set the key path</td></tr>
  <tr><td><code>modifiers</code></td><td>IReadOnlyList&lt;ProxyModifier&gt;</td><td>Get/set modifier keys</td></tr>
  <tr><td><code>isSet</code></td><td>bool</td><td>True if path is non-empty</td></tr>
  <tr><td><code>isBuiltIn</code></td><td>bool</td><td>True if this is a game-original binding</td></tr>
  <tr><td><code>isRebindable</code></td><td>bool</td><td>True if player can rebind</td></tr>
  <tr><td><code>hasConflicts</code></td><td>ConflictType</td><td>Whether this binding conflicts with others</td></tr>
  <tr><td><code>conflicts</code></td><td>IList&lt;ProxyBinding&gt;</td><td>List of conflicting bindings</td></tr>
  <tr><td><code>action</code></td><td>ProxyAction</td><td>Resolved action this binding belongs to</td></tr>
  <tr><td><code>title</code></td><td>string</td><td><code>mapName/actionName/name</code></td></tr>
</table>

<p>Nested types:</p>
<ul>
  <li><code>ProxyBinding.Watcher</code> -- watches for rebinding changes, auto-syncs property values.</li>
  <li><code>ProxyBinding.Comparer</code> -- configurable equality comparer.</li>
  <li><code>ProxyBinding.ConflictType</code> -- None, WithBuiltIn, WithNotBuiltIn, All.</li>
</ul>

<h3>ProxyModifier</h3>

<p>Struct representing a modifier key attached to a binding.</p>

<table>
  <tr><th>Field</th><th>Type</th><th>Description</th></tr>
  <tr><td><code>m_Component</code></td><td>ActionComponent</td><td>Component this modifier applies to</td></tr>
  <tr><td><code>m_Name</code></td><td>string</td><td>Modifier name (e.g. "modifier")</td></tr>
  <tr><td><code>m_Path</code></td><td>string</td><td>Unity input path (e.g. <code>&lt;Keyboard&gt;/shift</code>)</td></tr>
</table>

<h3>ModSetting (Keybinding Lifecycle)</h3>

<p>Base class for mod settings. Handles keybinding registration lifecycle.</p>

<table>
  <tr><th>Member</th><th>Type</th><th>Description</th></tr>
  <tr><td><code>id</code></td><td>string</td><td>Unique ID: <code>{AssemblyName}.{Namespace}.{ModType}</code></td></tr>
  <tr><td><code>keyBindingRegistered</code></td><td>bool</td><td>Whether RegisterKeyBindings has been called</td></tr>
  <tr><td><code>RegisterInOptionsUI()</code></td><td>void</td><td>Registers settings page in Options screen</td></tr>
  <tr><td><code>RegisterKeyBindings()</code></td><td>void</td><td>Reads all ProxyBinding properties, builds ProxyAction.Info[], calls InputManager.AddActions(), creates watchers</td></tr>
  <tr><td><code>InitializeKeyBindings()</code></td><td>void</td><td>Called in constructor. Reads binding attributes via reflection, sets initial ProxyBinding values</td></tr>
  <tr><td><code>GetAction(actionName)</code></td><td>ProxyAction</td><td>Convenience wrapper: returns <code>InputManager.instance.FindAction(id, actionName)</code>. Preferred over manual FindAction calls since it auto-fills the map name from <code>settings.id</code></td></tr>
</table>

<!-- ============================================================ -->
<h2>Settings Attributes</h2>

<h3>SettingsUIKeyboardAction (class-level)</h3>

<p>Applied to the settings class. Declares an input action. Use <code>AllowMultiple = true</code> to declare several actions on one class. <strong>This attribute is optional</strong> -- if omitted, <code>RegisterKeyBindings()</code> auto-creates actions from <code>[SettingsUIKeyboardBinding]</code> properties using default <code>ActionType.Button</code> settings. Explicit class-level attributes give you control over <code>ActionType</code>, <code>usages</code>, <code>rebindOptions</code>, and other parameters. (Yenyang's Recolor mod successfully uses keybindings without any <code>[SettingsUIKeyboardAction]</code> class attributes.)</p>

<table>
  <tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr>
  <tr><td><code>name</code></td><td>string</td><td>required</td><td>Action name (must match binding's actionName)</td></tr>
  <tr><td><code>type</code></td><td>ActionType</td><td>Button</td><td>Button, Axis, or Vector2</td></tr>
  <tr><td><code>rebindOptions</code></td><td>RebindOptions</td><td>All</td><td>What the player can rebind (Key, Modifiers, All)</td></tr>
  <tr><td><code>modifierOptions</code></td><td>ModifierOptions</td><td>Allow</td><td>Whether modifiers are allowed</td></tr>
  <tr><td><code>canBeEmpty</code></td><td>bool</td><td>true</td><td>Whether the binding can be unset</td></tr>
  <tr><td><code>developerOnly</code></td><td>bool</td><td>false</td><td>Hide from non-developer users</td></tr>
  <tr><td><code>mode</code></td><td>Mode</td><td>DigitalNormalized</td><td>Input processing mode</td></tr>
  <tr><td><code>usages</code></td><td>string[]</td><td>null</td><td>Custom usage tags</td></tr>
  <tr><td><code>interactions</code></td><td>string[]</td><td>null</td><td>Unity Input System interactions</td></tr>
  <tr><td><code>processors</code></td><td>string[]</td><td>null</td><td>Unity Input System processors</td></tr>
</table>

<h3>SettingsUIKeyboardBinding (property-level)</h3>

<p>Applied to <code>ProxyBinding</code> properties. Sets the default key for a binding. The <code>actionName</code> parameter links it to its class-level action declaration.</p>

<pre><code class="language-csharp">// Button with default key and modifiers
[SettingsUIKeyboardBinding(BindingKeyboard.F5, "TriggerAction", shift: true)]

// Button with no default key (player must bind manually)
[SettingsUIKeyboardBinding("SecretFeature")]

// Axis or Vector2 component
[SettingsUIKeyboardBinding(BindingKeyboard.W, AxisComponent.Positive, "MoveAxis")]</code></pre>

<p>The attribute converts <code>BindingKeyboard</code> enum values to Unity paths internally (e.g. <code>BindingKeyboard.F5</code> becomes <code>&lt;Keyboard&gt;/f5</code>).</p>

<h3>SettingsUIBindingMimic (property-level)</h3>

<p>Mirrors a built-in game binding. Your mod's key automatically updates when the player rebinds the original.</p>

<pre><code class="language-csharp">[SettingsUIBindingMimic("Shortcuts", "ToggleInfoViews")]
public ProxyBinding MirrorBinding { get; set; }</code></pre>

<!-- ============================================================ -->
<h2>Key Enums</h2>

<table>
  <tr><th>Enum</th><th>Values</th><th>Usage</th></tr>
  <tr><td><code>ActionType</code></td><td>Button, Axis, Vector2</td><td>What kind of input the action reads</td></tr>
  <tr><td><code>ActionComponent</code></td><td>None, Press, Negative, Positive, Down, Up, Left, Right</td><td>Which part of a composite binding</td></tr>
  <tr><td><code>DeviceType</code></td><td>None, Keyboard (1), Mouse (2), Gamepad (4), All (7)</td><td>Flags enum for device filtering</td></tr>
  <tr><td><code>RebindOptions</code></td><td>None, Key (1), Modifiers (2), All (3)</td><td>What the player can rebind</td></tr>
  <tr><td><code>ModifierOptions</code></td><td>Disallow, Allow, Ignore</td><td>Whether modifier keys are supported</td></tr>
  <tr><td><code>Mode</code></td><td>DigitalNormalized, Digital, Analog</td><td>Input processing mode</td></tr>
</table>

<p><code>BindingKeyboard</code> has 106 values covering all standard keys: letters (A-Z), digits (0-9), function keys (F1-F12), navigation, editing, numpad, and symbols.</p>

<!-- ============================================================ -->
<h2>Examples</h2>

<h3>Toggle with WasPressedThisFrame</h3>

<p>The most common pattern. Fires once when the key goes down.</p>

<pre><code class="language-csharp">[FileLocation(nameof(ToggleOverlayMod))]
[SettingsUIKeyboardAction("ToggleOverlay", ActionType.Button)]
public class ToggleOverlaySettings : ModSetting
{
    public ToggleOverlaySettings(IMod mod) : base(mod) { }

    [SettingsUIKeyboardBinding(BindingKeyboard.H, "ToggleOverlay", ctrl: true)]
    public ProxyBinding ToggleOverlayBinding { get; set; }

    public override void SetDefaults() { }
}</code></pre>

<pre><code class="language-csharp">public partial class ToggleOverlaySystem : GameSystemBase
{
    private ProxyAction _toggleAction;
    private bool _overlayVisible;

    protected override void OnCreate()
    {
        base.OnCreate();
        _toggleAction = InputManager.instance.FindAction(
            ToggleOverlayMod.Settings.id, "ToggleOverlay");
    }

    protected override void OnUpdate()
    {
        if (_toggleAction != null &amp;&amp; _toggleAction.WasPressedThisFrame())
        {
            _overlayVisible = !_overlayVisible;
            Log.Info($"Overlay toggled: {_overlayVisible}");
        }
    }
}</code></pre>

<h3>Multiple Actions</h3>

<p>Stack multiple <code>[SettingsUIKeyboardAction]</code> attributes on one class. Each <code>ProxyBinding</code> property links to its action via <code>actionName</code>.</p>

<pre><code class="language-csharp">[FileLocation(nameof(ZoneToolMod))]
[SettingsUIKeyboardAction("CycleZoneUp", ActionType.Button)]
[SettingsUIKeyboardAction("CycleZoneDown", ActionType.Button)]
[SettingsUIKeyboardAction("ResetZone", ActionType.Button)]
public class ZoneToolSettings : ModSetting
{
    public ZoneToolSettings(IMod mod) : base(mod) { }

    [SettingsUIKeyboardBinding(BindingKeyboard.PageUp, "CycleZoneUp")]
    public ProxyBinding CycleZoneUpBinding { get; set; }

    [SettingsUIKeyboardBinding(BindingKeyboard.PageDown, "CycleZoneDown")]
    public ProxyBinding CycleZoneDownBinding { get; set; }

    [SettingsUIKeyboardBinding(BindingKeyboard.R, "ResetZone", ctrl: true, shift: true)]
    public ProxyBinding ResetZoneBinding { get; set; }

    public override void SetDefaults() { }
}</code></pre>

<h3>Hold-to-Activate with IsPressed</h3>

<p>Use <code>IsPressed()</code> for continuous input while a key is held, and <code>WasReleasedThisFrame()</code> to detect when it stops.</p>

<pre><code class="language-csharp">protected override void OnUpdate()
{
    if (_boostAction.IsPressed())
    {
        // Apply speed multiplier every frame while held
    }

    if (_boostAction.WasReleasedThisFrame())
    {
        // Revert to normal speed
    }
}</code></pre>

<h3>Event-Driven with onInteraction</h3>

<p>Subscribe instead of polling. Useful outside the ECS update loop or when you need phase distinction.</p>

<pre><code class="language-csharp">protected override void OnCreate()
{
    base.OnCreate();
    _action = InputManager.instance.FindAction(
        MyMod.Settings.id, "TriggerAction");
    _action.onInteraction += OnHotkeyInteraction;
}

private void OnHotkeyInteraction(ProxyAction action, InputActionPhase phase)
{
    switch (phase)
    {
        case InputActionPhase.Started:   Log.Info("Key down");       break;
        case InputActionPhase.Performed: Log.Info("Performed");      break;
        case InputActionPhase.Canceled:  Log.Info("Key released");   break;
    }
}

protected override void OnDestroy()
{
    if (_action != null)
        _action.onInteraction -= OnHotkeyInteraction;
    base.OnDestroy();
}</code></pre>

<h3>Defensive Lookup with TryFindAction</h3>

<pre><code class="language-csharp">if (InputManager.instance.TryFindAction(MyMod.Settings.id, "TriggerAction", out var action))
{
    _triggerAction = action;
}
else
{
    Log.Warn("Failed to find TriggerAction -- keybinding may not be registered yet.");
}</code></pre>

<h3>Unbound Default (Optional Keybinding)</h3>

<p>Declare an action with no default key. The player binds it themselves in Options. Good for advanced or niche shortcuts.</p>

<pre><code class="language-csharp">[SettingsUIKeyboardAction("SecretFeature", ActionType.Button, canBeEmpty: true)]
public class AdvancedToolSettings : ModSetting
{
    // No default key -- pass only the actionName
    [SettingsUIKeyboardBinding("SecretFeature")]
    public ProxyBinding SecretFeatureBinding { get; set; }
}</code></pre>

<h3>Blocking Input with Barriers</h3>

<p>Temporarily prevent an action from firing (e.g., while a text field has focus).</p>

<pre><code class="language-csharp">private InputBarrier _barrier;

public void OnTextFieldFocused()
{
    _barrier = _hotkeyAction.CreateBarrier("TextFieldFocus");
}

public void OnTextFieldBlurred()
{
    _barrier?.Dispose();
    _barrier = null;
}</code></pre>

<!-- ============================================================ -->
<h2>Key Points to Remember</h2>

<ul>
  <li><strong>Map name</strong> is <code>ModSetting.id</code> (format: <code>{Assembly}.{Namespace}.{ModType}</code>).</li>
  <li><strong>Action name</strong> in <code>[SettingsUIKeyboardBinding]</code> must match the name in <code>[SettingsUIKeyboardAction]</code>. If omitted, it defaults to the property name.</li>
  <li><strong>Registration order</strong> is flexible: all three calls (<code>RegisterInOptionsUI()</code>, <code>LoadSettings()</code>, <code>RegisterKeyBindings()</code>) must happen, but working mods use different orderings successfully.</li>
  <li><strong>Rebinding</strong> comes free with <code>RegisterInOptionsUI()</code> -- players see bindings in Options and can change them.</li>
  <li><strong>Persistence</strong> is automatic via <code>AssetDatabase</code>.</li>
  <li><strong>Barriers</strong> block input temporarily; <strong>Activators</strong> enable/disable per device type.</li>
</ul>

<!-- ============================================================ -->
<h2>Mouse Action with Binding Mimic</h2>

<p>
  Register a mouse action and copy a vanilla binding at runtime. This ensures the mod's tool
  responds to whatever mouse button the user has configured for the vanilla action.
</p>

<pre><code class="language-csharp">// Settings: declare a custom mouse action
[SettingsUIMouseAction(nameof(FindIt) + "Apply", "CustomUsage")]
public class FindItSettings : ModSetting
{
    [SettingsUIMouseBinding(nameof(FindIt) + "Apply"), SettingsUIHidden]
    public ProxyBinding ApplyMimic { get; set; }
}

// System: copy vanilla Apply binding to our action
var builtInApply = InputManager.instance.FindAction(InputManager.kToolMap, "Apply");
var mimicBinding = _applyAction.bindings
    .FirstOrDefault(b =&gt; b.device == InputManager.DeviceType.Mouse);
var builtInBinding = builtInApply.bindings
    .FirstOrDefault(b =&gt; b.device == InputManager.DeviceType.Mouse);

mimicBinding.path = builtInBinding.path;
mimicBinding.modifiers = builtInBinding.modifiers;
InputManager.instance.SetBinding(mimicBinding, out _);</code></pre>

<h3>Mirroring Vanilla Keybindings with ProxyBinding.Watcher</h3>

<p>Use <code>ProxyBinding.Watcher</code> to automatically keep a mod action in sync with a vanilla keybinding. When the player rebinds the vanilla action, the watcher fires a callback so you can copy the new binding to your mod's action.</p>

<pre><code class="language-csharp">using Game.Input;
using Game.Modding;

public partial class MirrorBindingSystem : GameSystemBase
{
    private ProxyAction _modApplyAction;
    private ProxyBinding.Watcher _vanillaWatcher;

    protected override void OnCreate()
    {
        base.OnCreate();
        _modApplyAction = Mod.Settings.GetAction("ModApply");

        // Find the vanilla Apply action to mirror
        var vanillaApply = InputManager.instance.FindAction(
            InputManager.kToolMap, "Apply");

        // Get the vanilla action's current mouse binding
        var vanillaBinding = vanillaApply.bindings
            .FirstOrDefault(b =&gt; b.m_Device == InputManager.DeviceType.Mouse);

        // Copy it to our mod action immediately
        CopyBindingToModAction(vanillaBinding);

        // Create a watcher that fires whenever the vanilla binding changes
        _vanillaWatcher = new ProxyBinding.Watcher(
            vanillaBinding,
            OnVanillaBindingChanged);
    }

    private void OnVanillaBindingChanged(ProxyBinding updatedBinding)
    {
        // Player rebinds the vanilla Apply action -- mirror it to our action
        CopyBindingToModAction(updatedBinding);
    }

    private void CopyBindingToModAction(ProxyBinding sourceBinding)
    {
        // Find our mod action's corresponding binding
        var modBinding = _modApplyAction.bindings
            .FirstOrDefault(b =&gt; b.m_Device == sourceBinding.m_Device);

        if (modBinding.isSet || sourceBinding.isSet)
        {
            // Use ProxyBinding.Copy() to clone path and modifiers
            var copied = ProxyBinding.Copy(sourceBinding, modBinding);

            // Apply the copied binding via InputManager
            InputManager.instance.SetBinding(copied, out _);
        }
    }

    protected override void OnDestroy()
    {
        // Dispose the watcher to stop receiving callbacks
        _vanillaWatcher?.Dispose();
        _vanillaWatcher = null;
        base.OnDestroy();
    }

    protected override void OnUpdate() { }
}</code></pre>

<p>Key techniques:</p>
<ul>
  <li><strong><code>ProxyBinding.Watcher</code></strong>: Watches a specific binding for changes. The constructor takes the binding to watch and a callback delegate.</li>
  <li><strong><code>ProxyBinding.Copy(source, target)</code></strong>: Creates a new <code>ProxyBinding</code> that copies <code>path</code> and <code>modifiers</code> from the source into the target's map/action/device context.</li>
  <li><strong><code>InputManager.instance.SetBinding(binding, out result)</code></strong>: Applies a binding change. Must be called after modifying binding properties.</li>
  <li><strong>Disposal lifecycle</strong>: Always dispose the watcher in <code>OnDestroy()</code> to prevent callbacks on a destroyed system. Watchers hold references that prevent garbage collection if not disposed.</li>
</ul>

<p>Use this pattern when your mod adds a tool that should use the same mouse button as the vanilla Apply/Cancel actions and you want it to stay in sync when the player rebinds.</p>

<h3>Raw Unity InputAction for Modifier+Mouse Combos</h3>

<p>The <code>ProxyAction</code> / <code>ModSettings</code> attribute system does not support modifier key + mouse button combinations (e.g., Ctrl+Right Click). For these cases, fall back to Unity's <code>InputAction</code> API directly with a <code>ButtonWithOneModifier</code> composite.</p>

<pre><code class="language-csharp">using Game;
using UnityEngine.InputSystem;

/// &lt;summary&gt;
/// Registers a raw Unity InputAction for Ctrl+Right Click.
/// This bypasses the CO ProxyAction system because ProxyAction does not
/// support modifier+mouse button composites.
/// &lt;/summary&gt;
public partial class CtrlClickSystem : GameSystemBase
{
    private InputAction _ctrlRightClick;

    protected override void OnCreate()
    {
        base.OnCreate();

        // Create a raw Unity InputAction with a ButtonWithOneModifier composite.
        // "modifier" is the modifier key, "button" is the primary input.
        _ctrlRightClick = new InputAction("CtrlRightClick", type: InputActionType.Button);
        _ctrlRightClick.AddCompositeBinding("ButtonWithOneModifier")
            .With("modifier", "&lt;Keyboard&gt;/ctrl")
            .With("button", "&lt;Mouse&gt;/rightButton");

        _ctrlRightClick.Enable();
    }

    protected override void OnUpdate()
    {
        if (_ctrlRightClick.WasPressedThisFrame())
        {
            // Ctrl+Right Click detected
            Mod.Log.Info("Ctrl+Right Click pressed");
        }
    }

    protected override void OnDestroy()
    {
        // Always disable and dispose raw InputActions
        _ctrlRightClick?.Disable();
        _ctrlRightClick?.Dispose();
        _ctrlRightClick = null;
        base.OnDestroy();
    }
}</code></pre>

<p>Key points:</p>
<ul>
  <li><strong><code>ButtonWithOneModifier</code></strong> is a Unity Input System composite that requires one modifier key to be held while the button is pressed. For two modifiers, use <code>ButtonWithTwoModifiers</code>.</li>
  <li><strong>Modifier path</strong>: Use Unity input paths like <code>&lt;Keyboard&gt;/ctrl</code>, <code>&lt;Keyboard&gt;/shift</code>, <code>&lt;Keyboard&gt;/alt</code>.</li>
  <li><strong>Button path</strong>: Use <code>&lt;Mouse&gt;/leftButton</code>, <code>&lt;Mouse&gt;/rightButton</code>, <code>&lt;Mouse&gt;/middleButton</code>, or any other input path.</li>
  <li><strong>No rebinding UI</strong>: Raw <code>InputAction</code> objects are not registered with <code>InputManager</code> and will not appear in the game's Options screen. Players cannot rebind them. Use this only as a last resort when <code>ProxyAction</code> cannot express the desired binding.</li>
  <li><strong>Lifecycle</strong>: Always call <code>Disable()</code> and <code>Dispose()</code> on raw <code>InputAction</code> objects in <code>OnDestroy()</code>. Unlike <code>ProxyAction</code>, these are not managed by the CO input framework.</li>
</ul>

<h2>Open Questions</h2>

<ul>
  <li>How does <code>shouldBeEnabled</code> interact with the automatic enabling done by <code>RegisterKeyBindings()</code>? Is it necessary to set it explicitly for mod actions?</li>
  <li>What happens if two mods register the same action name in different maps? Cross-mod conflict resolution is unclear.</li>
  <li>How does the <code>Usages</code> system filter when actions are active (gameplay vs. menus)?</li>
  <li>What is the full <code>InputBarrier</code> lifecycle? When should mods create and dispose barriers?</li>
</ul>

<footer>
  <p>Source: Decompiled from Game.dll (Cities: Skylines II) using ilspycmd v9.1 (.NET 8.0).</p>
  <p>Reference: <a href="https://cs2.paradoxwikis.com/Mod_Key_Binding">Mod Key Binding - CS2 Wiki</a></p>
  <div class="attribution-footer">
    <p>This documentation was generated using Claude (Anthropic), supervised by the repository owner.</p>
  </div>
</footer>

  </main>

</div>

</body>
</html>
